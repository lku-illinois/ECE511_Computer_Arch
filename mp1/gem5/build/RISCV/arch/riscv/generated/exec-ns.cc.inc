// DO NOT EDIT
// This file was automatically generated from an ISA description:
//   riscv/isa/main.isa

#if !defined(__SPLIT) || (__SPLIT == 1)

// CIAddi4spnOp::c_addi4spn((['\n            imm = CIMM8<1:1> << 2 |\n                  CIMM8<0:0> << 3 |\n                  CIMM8<7:6> << 4 |\n                  CIMM8<5:2> << 6;\n        ', '\n            if (imm == 0)\n                return std::make_shared<IllegalInstFault>("immediate = 0",\n                                                           machInst);\n            Rp2 = rvSext(sp + imm);\n        ', 'uint64_t'], {}))

    Fault
    C_addi4spn::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        uint64_t sp = 0;
uint64_t Rp2 = 0;
;
        sp = xc->getRegOperand(this, 0);
;
        
            if (imm == 0)
                return std::make_shared<IllegalInstFault>("immediate = 0",
                                                           machInst);
            Rp2 = rvSext(sp + imm);
        ;
        
        {
            RegVal final_val = Rp2;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    C_addi4spn::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// CompressedLoad::c_fld(['\n                    offset = CIMM3 << 3 | CIMM2 << 6;\n                ', '\n                    STATUS status = xc->readMiscReg(MISCREG_STATUS);\n                    if (status.fs == FPUStatus::OFF)\n                        return std::make_shared<IllegalInstFault>("FPU is off",\n                                                                   machInst);\n\n                    // Mutating any floating point register changes the FS bit\n                    // of the STATUS CSR.\n                    status.fs = FPUStatus::DIRTY;\n                    xc->setMiscReg(MISCREG_STATUS, status);\n\n                    Fp2_bits = Mem;\n                ', '\n                    EA = rvSext(Rp1 + offset);\n                '],{})

    Fault
    C_fld::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rp1 = 0;
uint64_t Fp2_bits = 0;
uint64_t Mem = {};
;
        Rp1 = xc->getRegOperand(this, 0);
;
        
                    EA = rvSext(Rp1 + offset);
                ;

        {
            Fault fault =
                readMemAtomicLE(xc, traceData, EA, Mem, memAccessFlags);
            if (fault != NoFault)
                return fault;
        }

        
                    STATUS status = xc->readMiscReg(MISCREG_STATUS);
                    if (status.fs == FPUStatus::OFF)
                        return std::make_shared<IllegalInstFault>("FPU is off",
                                                                   machInst);

                    // Mutating any floating point register changes the FS bit
                    // of the STATUS CSR.
                    status.fs = FPUStatus::DIRTY;
                    xc->setMiscReg(MISCREG_STATUS, status);

                    Fp2_bits = Mem;
                ;

        
        {
            RegVal final_val = Fp2_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

    Fault
    C_fld::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rp1 = 0;
uint64_t Mem = {};
;
        Rp1 = xc->getRegOperand(this, 0);
;
        
                    EA = rvSext(Rp1 + offset);
                ;

        return initiateMemRead(xc, traceData, EA, Mem, memAccessFlags);
    }

    Fault
    C_fld::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Fp2_bits = 0;
uint64_t Mem = {};
;
        ;

        getMemLE(pkt, Mem, traceData);

        
                    STATUS status = xc->readMiscReg(MISCREG_STATUS);
                    if (status.fs == FPUStatus::OFF)
                        return std::make_shared<IllegalInstFault>("FPU is off",
                                                                   machInst);

                    // Mutating any floating point register changes the FS bit
                    // of the STATUS CSR.
                    status.fs = FPUStatus::DIRTY;
                    xc->setMiscReg(MISCREG_STATUS, status);

                    Fp2_bits = Mem;
                ;
        
        {
            RegVal final_val = Fp2_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// Unknown::unknown(([], {}))

// CompressedLoad::c_lw(['\n                offset = CIMM2<1:1> << 2 |\n                         CIMM3 << 3 |\n                         CIMM2<0:0> << 6;\n            ', '\n                Rp2_sd = Mem_sw;\n            ', '\n                EA = rvSext(Rp1 + offset);\n            '],{})

    Fault
    C_lw::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rp1 = 0;
int64_t Rp2 = 0;
int32_t Mem = {};
;
        Rp1 = xc->getRegOperand(this, 0);
;
        
                EA = rvSext(Rp1 + offset);
            ;

        {
            Fault fault =
                readMemAtomicLE(xc, traceData, EA, Mem, memAccessFlags);
            if (fault != NoFault)
                return fault;
        }

        
                Rp2 = Mem;
            ;

        
        {
            RegVal final_val = Rp2;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

    Fault
    C_lw::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rp1 = 0;
int32_t Mem = {};
;
        Rp1 = xc->getRegOperand(this, 0);
;
        
                EA = rvSext(Rp1 + offset);
            ;

        return initiateMemRead(xc, traceData, EA, Mem, memAccessFlags);
    }

    Fault
    C_lw::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int64_t Rp2 = 0;
int32_t Mem = {};
;
        ;

        getMemLE(pkt, Mem, traceData);

        
                Rp2 = Mem;
            ;
        
        {
            RegVal final_val = Rp2;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// CompressedLoad::c_flw(['\n                    offset = CIMM2<1:1> << 2 |\n                             CIMM3 << 3 |\n                             CIMM2<0:0> << 6;\n                ', '\n                    STATUS status = xc->readMiscReg(MISCREG_STATUS);\n                    if (status.fs == FPUStatus::OFF)\n                        return std::make_shared<IllegalInstFault>("FPU is off",\n                                                                   machInst);\n\n                    status.fs = FPUStatus::DIRTY;\n                    xc->setMiscReg(MISCREG_STATUS, status);\n\n                    freg_t fd = freg(f32(Mem_uw));\n                    Fp2_bits = fd.v;\n                ', '\n                    EA = rvSext(Rp1 + offset);\n                '],{})

    Fault
    C_flw::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rp1 = 0;
uint64_t Fp2_bits = 0;
uint32_t Mem = {};
;
        Rp1 = xc->getRegOperand(this, 0);
;
        
                    EA = rvSext(Rp1 + offset);
                ;

        {
            Fault fault =
                readMemAtomicLE(xc, traceData, EA, Mem, memAccessFlags);
            if (fault != NoFault)
                return fault;
        }

        
                    STATUS status = xc->readMiscReg(MISCREG_STATUS);
                    if (status.fs == FPUStatus::OFF)
                        return std::make_shared<IllegalInstFault>("FPU is off",
                                                                   machInst);

                    status.fs = FPUStatus::DIRTY;
                    xc->setMiscReg(MISCREG_STATUS, status);

                    freg_t fd = freg(f32(Mem));
                    Fp2_bits = fd.v;
                ;

        
        {
            RegVal final_val = Fp2_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

    Fault
    C_flw::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rp1 = 0;
uint32_t Mem = {};
;
        Rp1 = xc->getRegOperand(this, 0);
;
        
                    EA = rvSext(Rp1 + offset);
                ;

        return initiateMemRead(xc, traceData, EA, Mem, memAccessFlags);
    }

    Fault
    C_flw::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Fp2_bits = 0;
uint32_t Mem = {};
;
        ;

        getMemLE(pkt, Mem, traceData);

        
                    STATUS status = xc->readMiscReg(MISCREG_STATUS);
                    if (status.fs == FPUStatus::OFF)
                        return std::make_shared<IllegalInstFault>("FPU is off",
                                                                   machInst);

                    status.fs = FPUStatus::DIRTY;
                    xc->setMiscReg(MISCREG_STATUS, status);

                    freg_t fd = freg(f32(Mem));
                    Fp2_bits = fd.v;
                ;
        
        {
            RegVal final_val = Fp2_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// CompressedLoad::c_ld(['\n                    offset = CIMM3 << 3 | CIMM2 << 6;\n                ', '\n                    Rp2_sd = Mem_sd;\n                ', '\n                    EA = Rp1 + offset;\n                '],{})

    Fault
    C_ld::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rp1 = 0;
int64_t Rp2 = 0;
int64_t Mem = {};
;
        Rp1 = xc->getRegOperand(this, 0);
;
        
                    EA = Rp1 + offset;
                ;

        {
            Fault fault =
                readMemAtomicLE(xc, traceData, EA, Mem, memAccessFlags);
            if (fault != NoFault)
                return fault;
        }

        
                    Rp2 = Mem;
                ;

        
        {
            RegVal final_val = Rp2;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

    Fault
    C_ld::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rp1 = 0;
int64_t Mem = {};
;
        Rp1 = xc->getRegOperand(this, 0);
;
        
                    EA = Rp1 + offset;
                ;

        return initiateMemRead(xc, traceData, EA, Mem, memAccessFlags);
    }

    Fault
    C_ld::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int64_t Rp2 = 0;
int64_t Mem = {};
;
        ;

        getMemLE(pkt, Mem, traceData);

        
                    Rp2 = Mem;
                ;
        
        {
            RegVal final_val = Rp2;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// Unknown::unknown(([], {}))

// CompressedLoad::c_lbu(['\n                    offset = (CIMM2<0:0> << 1) | CIMM2<1:1>;\n                ', '\n                    Rp2 = Mem_ub;\n                ', '\n                    EA = rvSext(Rp1 + offset);\n                '],{})

    Fault
    C_lbu::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rp1 = 0;
uint64_t Rp2 = 0;
uint8_t Mem = {};
;
        Rp1 = xc->getRegOperand(this, 0);
;
        
                    EA = rvSext(Rp1 + offset);
                ;

        {
            Fault fault =
                readMemAtomicLE(xc, traceData, EA, Mem, memAccessFlags);
            if (fault != NoFault)
                return fault;
        }

        
                    Rp2 = Mem;
                ;

        
        {
            RegVal final_val = Rp2;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

    Fault
    C_lbu::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rp1 = 0;
uint8_t Mem = {};
;
        Rp1 = xc->getRegOperand(this, 0);
;
        
                    EA = rvSext(Rp1 + offset);
                ;

        return initiateMemRead(xc, traceData, EA, Mem, memAccessFlags);
    }

    Fault
    C_lbu::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rp2 = 0;
uint8_t Mem = {};
;
        ;

        getMemLE(pkt, Mem, traceData);

        
                    Rp2 = Mem;
                ;
        
        {
            RegVal final_val = Rp2;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// CompressedLoad::c_lhu(['\n                        offset = CIMM2<0:0> << 1;\n                    ', '\n                        Rp2 = Mem_uh;\n                    ', '\n                        EA = rvSext(Rp1 + offset);\n                    '],{})

    Fault
    C_lhu::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rp1 = 0;
uint64_t Rp2 = 0;
uint16_t Mem = {};
;
        Rp1 = xc->getRegOperand(this, 0);
;
        
                        EA = rvSext(Rp1 + offset);
                    ;

        {
            Fault fault =
                readMemAtomicLE(xc, traceData, EA, Mem, memAccessFlags);
            if (fault != NoFault)
                return fault;
        }

        
                        Rp2 = Mem;
                    ;

        
        {
            RegVal final_val = Rp2;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

    Fault
    C_lhu::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rp1 = 0;
uint16_t Mem = {};
;
        Rp1 = xc->getRegOperand(this, 0);
;
        
                        EA = rvSext(Rp1 + offset);
                    ;

        return initiateMemRead(xc, traceData, EA, Mem, memAccessFlags);
    }

    Fault
    C_lhu::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rp2 = 0;
uint16_t Mem = {};
;
        ;

        getMemLE(pkt, Mem, traceData);

        
                        Rp2 = Mem;
                    ;
        
        {
            RegVal final_val = Rp2;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// CompressedLoad::c_lh(['\n                        offset = CIMM2<0:0> << 1;\n                    ', '\n                        Rp2_sd = Mem_sh;\n                    ', '\n                        EA = rvSext(Rp1 + offset);\n                    '],{})

    Fault
    C_lh::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rp1 = 0;
int64_t Rp2 = 0;
int16_t Mem = {};
;
        Rp1 = xc->getRegOperand(this, 0);
;
        
                        EA = rvSext(Rp1 + offset);
                    ;

        {
            Fault fault =
                readMemAtomicLE(xc, traceData, EA, Mem, memAccessFlags);
            if (fault != NoFault)
                return fault;
        }

        
                        Rp2 = Mem;
                    ;

        
        {
            RegVal final_val = Rp2;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

    Fault
    C_lh::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rp1 = 0;
int16_t Mem = {};
;
        Rp1 = xc->getRegOperand(this, 0);
;
        
                        EA = rvSext(Rp1 + offset);
                    ;

        return initiateMemRead(xc, traceData, EA, Mem, memAccessFlags);
    }

    Fault
    C_lh::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int64_t Rp2 = 0;
int16_t Mem = {};
;
        ;

        getMemLE(pkt, Mem, traceData);

        
                        Rp2 = Mem;
                    ;
        
        {
            RegVal final_val = Rp2;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// Unknown::unknown(([], {}))

// CompressedStore::c_sb(['\n                    offset = (CIMM2<0:0> << 1) | CIMM2<1:1>;\n                ', '\n                    Mem_ub = Rp2_ub;\n                '],{'ea_code': '\n                    EA = rvSext(Rp1 + offset);\n                '})

    Fault
    C_sb::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rp1 = 0;
uint8_t Rp2 = 0;
uint8_t Mem = {};
;
        Rp1 = xc->getRegOperand(this, 0);
Rp2 = xc->getRegOperand(this, 1);
;
        
                    EA = rvSext(Rp1 + offset);
                ;

        
                    Mem = Rp2;
                ;

        {
            Fault fault =
                writeMemAtomicLE(xc, traceData, Mem, EA, memAccessFlags,
                        nullptr);
            if (fault != NoFault)
                return fault;
        }

        ;
        ;

        return NoFault;
    }

    Fault
    C_sb::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rp1 = 0;
uint8_t Rp2 = 0;
uint8_t Mem = {};
;
        Rp1 = xc->getRegOperand(this, 0);
Rp2 = xc->getRegOperand(this, 1);
;
        
                    EA = rvSext(Rp1 + offset);
                ;

        
                    Mem = Rp2;
                ;

        {
            Fault fault = writeMemTimingLE(xc, traceData, Mem, EA,
                memAccessFlags, nullptr);
            if (fault != NoFault)
                return fault;
        }

        ;

        return NoFault;
    }

    Fault
    C_sb::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        return NoFault;
    }

// CompressedStore::c_sh(['\n                    offset = (CIMM2<0:0> << 1);\n                ', '\n                    Mem_uh = Rp2_uh;\n                '],{'ea_code': '\n                    EA = rvSext(Rp1 + offset);\n                '})

    Fault
    C_sh::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rp1 = 0;
uint16_t Rp2 = 0;
uint16_t Mem = {};
;
        Rp1 = xc->getRegOperand(this, 0);
Rp2 = xc->getRegOperand(this, 1);
;
        
                    EA = rvSext(Rp1 + offset);
                ;

        
                    Mem = Rp2;
                ;

        {
            Fault fault =
                writeMemAtomicLE(xc, traceData, Mem, EA, memAccessFlags,
                        nullptr);
            if (fault != NoFault)
                return fault;
        }

        ;
        ;

        return NoFault;
    }

    Fault
    C_sh::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rp1 = 0;
uint16_t Rp2 = 0;
uint16_t Mem = {};
;
        Rp1 = xc->getRegOperand(this, 0);
Rp2 = xc->getRegOperand(this, 1);
;
        
                    EA = rvSext(Rp1 + offset);
                ;

        
                    Mem = Rp2;
                ;

        {
            Fault fault = writeMemTimingLE(xc, traceData, Mem, EA,
                memAccessFlags, nullptr);
            if (fault != NoFault)
                return fault;
        }

        ;

        return NoFault;
    }

    Fault
    C_sh::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        return NoFault;
    }

// Unknown::unknown(([], {}))

// CompressedStore::c_fsd(['\n                    offset = CIMM3 << 3 | CIMM2 << 6;\n                ', '\n                    STATUS status = xc->readMiscReg(MISCREG_STATUS);\n                    if (status.fs == FPUStatus::OFF)\n                        return std::make_shared<IllegalInstFault>("FPU is off",\n                                                                   machInst);\n\n                    Mem = Fp2_bits;\n                ', '\n                    EA = rvSext(Rp1 + offset);\n                '],{})

    Fault
    C_fsd::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rp1 = 0;
uint64_t Fp2_bits = 0;
uint64_t Mem = {};
;
        Rp1 = xc->getRegOperand(this, 0);
Fp2_bits = xc->getRegOperand(this, 1);
;
        
                    EA = rvSext(Rp1 + offset);
                ;

        
                    STATUS status = xc->readMiscReg(MISCREG_STATUS);
                    if (status.fs == FPUStatus::OFF)
                        return std::make_shared<IllegalInstFault>("FPU is off",
                                                                   machInst);

                    Mem = Fp2_bits;
                ;

        {
            Fault fault =
                writeMemAtomicLE(xc, traceData, Mem, EA, memAccessFlags,
                        nullptr);
            if (fault != NoFault)
                return fault;
        }

        ;
        ;

        return NoFault;
    }

    Fault
    C_fsd::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rp1 = 0;
uint64_t Fp2_bits = 0;
uint64_t Mem = {};
;
        Rp1 = xc->getRegOperand(this, 0);
Fp2_bits = xc->getRegOperand(this, 1);
;
        
                    EA = rvSext(Rp1 + offset);
                ;

        
                    STATUS status = xc->readMiscReg(MISCREG_STATUS);
                    if (status.fs == FPUStatus::OFF)
                        return std::make_shared<IllegalInstFault>("FPU is off",
                                                                   machInst);

                    Mem = Fp2_bits;
                ;

        {
            Fault fault = writeMemTimingLE(xc, traceData, Mem, EA,
                memAccessFlags, nullptr);
            if (fault != NoFault)
                return fault;
        }

        ;

        return NoFault;
    }

    Fault
    C_fsd::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        return NoFault;
    }

// Unknown::unknown(([], {}))

// CompressedStore::c_sw(['\n                offset = CIMM2<1:1> << 2 |\n                         CIMM3 << 3 |\n                         CIMM2<0:0> << 6;\n            ', '\n                Mem_uw = Rp2_uw;\n            '],{'ea_code': '\n                EA = rvSext(Rp1 + offset);\n            '})

    Fault
    C_sw::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rp1 = 0;
uint32_t Rp2 = 0;
uint32_t Mem = {};
;
        Rp1 = xc->getRegOperand(this, 0);
Rp2 = xc->getRegOperand(this, 1);
;
        
                EA = rvSext(Rp1 + offset);
            ;

        
                Mem = Rp2;
            ;

        {
            Fault fault =
                writeMemAtomicLE(xc, traceData, Mem, EA, memAccessFlags,
                        nullptr);
            if (fault != NoFault)
                return fault;
        }

        ;
        ;

        return NoFault;
    }

    Fault
    C_sw::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rp1 = 0;
uint32_t Rp2 = 0;
uint32_t Mem = {};
;
        Rp1 = xc->getRegOperand(this, 0);
Rp2 = xc->getRegOperand(this, 1);
;
        
                EA = rvSext(Rp1 + offset);
            ;

        
                Mem = Rp2;
            ;

        {
            Fault fault = writeMemTimingLE(xc, traceData, Mem, EA,
                memAccessFlags, nullptr);
            if (fault != NoFault)
                return fault;
        }

        ;

        return NoFault;
    }

    Fault
    C_sw::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        return NoFault;
    }

// CompressedStore::c_fsw(['\n                    offset = CIMM2<1:1> << 2 |\n                             CIMM3 << 3 |\n                             CIMM2<0:0> << 6;\n                ', '\n                    STATUS status = xc->readMiscReg(MISCREG_STATUS);\n                    if (status.fs == FPUStatus::OFF)\n                        return std::make_shared<IllegalInstFault>("FPU is off",\n                                                                   machInst);\n\n                    Mem_uw = unboxF32(boxF32(Fp2_bits));\n                ', '\n                    EA = rvSext(Rp1_uw + offset);\n                '],{})

    Fault
    C_fsw::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint32_t Rp1 = 0;
uint64_t Fp2_bits = 0;
uint32_t Mem = {};
;
        Rp1 = xc->getRegOperand(this, 0);
Fp2_bits = xc->getRegOperand(this, 1);
;
        
                    EA = rvSext(Rp1 + offset);
                ;

        
                    STATUS status = xc->readMiscReg(MISCREG_STATUS);
                    if (status.fs == FPUStatus::OFF)
                        return std::make_shared<IllegalInstFault>("FPU is off",
                                                                   machInst);

                    Mem = unboxF32(boxF32(Fp2_bits));
                ;

        {
            Fault fault =
                writeMemAtomicLE(xc, traceData, Mem, EA, memAccessFlags,
                        nullptr);
            if (fault != NoFault)
                return fault;
        }

        ;
        ;

        return NoFault;
    }

    Fault
    C_fsw::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint32_t Rp1 = 0;
uint64_t Fp2_bits = 0;
uint32_t Mem = {};
;
        Rp1 = xc->getRegOperand(this, 0);
Fp2_bits = xc->getRegOperand(this, 1);
;
        
                    EA = rvSext(Rp1 + offset);
                ;

        
                    STATUS status = xc->readMiscReg(MISCREG_STATUS);
                    if (status.fs == FPUStatus::OFF)
                        return std::make_shared<IllegalInstFault>("FPU is off",
                                                                   machInst);

                    Mem = unboxF32(boxF32(Fp2_bits));
                ;

        {
            Fault fault = writeMemTimingLE(xc, traceData, Mem, EA,
                memAccessFlags, nullptr);
            if (fault != NoFault)
                return fault;
        }

        ;

        return NoFault;
    }

    Fault
    C_fsw::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        return NoFault;
    }

// CompressedStore::c_sd(['\n                    offset = CIMM3 << 3 | CIMM2 << 6;\n                ', '\n                    Mem_ud = Rp2_ud;\n                ', '\n                    EA = Rp1 + offset;\n                '],{})

    Fault
    C_sd::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rp1 = 0;
uint64_t Rp2 = 0;
uint64_t Mem = {};
;
        Rp1 = xc->getRegOperand(this, 0);
Rp2 = xc->getRegOperand(this, 1);
;
        
                    EA = Rp1 + offset;
                ;

        
                    Mem = Rp2;
                ;

        {
            Fault fault =
                writeMemAtomicLE(xc, traceData, Mem, EA, memAccessFlags,
                        nullptr);
            if (fault != NoFault)
                return fault;
        }

        ;
        ;

        return NoFault;
    }

    Fault
    C_sd::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rp1 = 0;
uint64_t Rp2 = 0;
uint64_t Mem = {};
;
        Rp1 = xc->getRegOperand(this, 0);
Rp2 = xc->getRegOperand(this, 1);
;
        
                    EA = Rp1 + offset;
                ;

        
                    Mem = Rp2;
                ;

        {
            Fault fault = writeMemTimingLE(xc, traceData, Mem, EA,
                memAccessFlags, nullptr);
            if (fault != NoFault)
                return fault;
        }

        ;

        return NoFault;
    }

    Fault
    C_sd::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        return NoFault;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// CIOp::c_addi((['\n            imm = sext<6>(CIMM5 | (CIMM1 << 5));\n        ', '\n            if ((RC1 == 0) != (imm == 0)) {\n                if (RC1 == 0) {\n                    // imm != 0 is HINT\n                } else {\n                    // imm == 0 is HINT\n                }\n            }\n            Rc1_sd = rvSext(Rc1_sd + imm);\n        '], {}))

    Fault
    C_addi::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        int64_t Rc1 = 0;
;
        Rc1 = xc->getRegOperand(this, 0);
;
        
            if ((RC1 == 0) != (imm == 0)) {
                if (RC1 == 0) {
                    // imm != 0 is HINT
                } else {
                    // imm == 0 is HINT
                }
            }
            Rc1 = rvSext(Rc1 + imm);
        ;
        
        {
            RegVal final_val = Rc1;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    C_addi::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// CJOp::c_jal((['\n                ra = rvSext(NPC);\n                NPC = rvSext(PC + imm);\n            ', 'IsDirectControl', 'IsUncondControl', 'IsCall'], {}))

    Fault
    C_jal::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t ra = 0;
uint64_t PC = 0;
uint64_t NPC = 0;
RiscvISAInst::PCState __parserAutoPCState;
;
        set(__parserAutoPCState, xc->pcState());
PC = __parserAutoPCState.pc();
NPC = __parserAutoPCState.npc();
;
        
                ra = rvSext(NPC);
                NPC = rvSext(PC + imm);
            ;
        
        {
            RegVal final_val = ra;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        }__parserAutoPCState.npc(NPC);
xc->pcState(__parserAutoPCState);
;
        return NoFault;
    }

    std::unique_ptr<PCStateBase>
    C_jal::branchTarget(const PCStateBase &branch_pc) const
    {
        auto &rpc = branch_pc.as<RiscvISA::PCState>();
        std::unique_ptr<PCState> npc(dynamic_cast<PCState*>(rpc.clone()));
        npc->set(rvSext(rpc.pc() + imm));
        return npc;
    }

    std::string
    C_jal::generateDisassembly(
            Addr pc, const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// CIOp::c_addiw((['\n                imm = sext<6>(CIMM5 | (CIMM1 << 5));\n            ', '\n                if (RC1 == 0) {\n                    return std::make_shared<IllegalInstFault>(\n                            "source reg x0", machInst);\n                }\n                Rc1_sw = (int32_t)(Rc1_sw + imm);\n            '], {}))

    Fault
    C_addiw::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        int32_t Rc1 = 0;
;
        Rc1 = xc->getRegOperand(this, 0);
;
        
                if (RC1 == 0) {
                    return std::make_shared<IllegalInstFault>(
                            "source reg x0", machInst);
                }
                Rc1 = (int32_t)(Rc1 + imm);
            ;
        
        {
            RegVal final_val = Rc1;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    C_addiw::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// Unknown::unknown(([], {}))

// CIOp::c_li((['\n            imm = sext<6>(CIMM5 | (CIMM1 << 5));\n        ', '\n            // RC1 == 0 is HINT\n            Rc1_sd = imm;\n        '], {}))

    Fault
    C_li::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        int64_t Rc1 = 0;
;
        ;
        
            // RC1 == 0 is HINT
            Rc1 = imm;
        ;
        
        {
            RegVal final_val = Rc1;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    C_li::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// CIOp::c_addi16sp((['\n                imm = sext<10>((CIMM5<4:4> << 4) |\n                               (CIMM5<0:0> << 5) |\n                               (CIMM5<3:3> << 6) |\n                               (CIMM5<2:1> << 7) |\n                               (CIMM1 << 9));\n            ', '\n                if (imm == 0) {\n                    return std::make_shared<IllegalInstFault>(\n                            "immediate = 0", machInst);\n                }\n                sp_sd = rvSext(sp_sd + imm);\n            '], {}))

    Fault
    C_addi16sp::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        int64_t sp = 0;
;
        sp = xc->getRegOperand(this, 0);
;
        
                if (imm == 0) {
                    return std::make_shared<IllegalInstFault>(
                            "immediate = 0", machInst);
                }
                sp = rvSext(sp + imm);
            ;
        
        {
            RegVal final_val = sp;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    C_addi16sp::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// CIOp::c_lui((['\n                imm = sext<6>(CIMM5 | (CIMM1 << 5)) << 12;\n            ', '\n                // RC1 == 0 is HINT\n                if (imm == 0) {\n                    return std::make_shared<IllegalInstFault>(\n                            "immediate = 0", machInst);\n                }\n                Rc1_sd = imm;\n            '], {}))

    Fault
    C_lui::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        int64_t Rc1 = 0;
;
        ;
        
                // RC1 == 0 is HINT
                if (imm == 0) {
                    return std::make_shared<IllegalInstFault>(
                            "immediate = 0", machInst);
                }
                Rc1 = imm;
            ;
        
        {
            RegVal final_val = Rc1;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    C_lui::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        // To be compliant with GCC, the immediate is formated to a 20-bit
        // signed integer.
        ss << ((((uint64_t)imm) >> 12) & 0xFFFFF);
        return ss.str();
    }

// CIOp::c_srli(['\n                    imm = CIMM5 | (CIMM1 << 5);\n                ', '\n                    if (rvSelect((bool)CIMM1, false)) {\n                        return std::make_shared<IllegalInstFault>(\n                                "shmat[5] != 0", machInst);\n                    }\n                    if (imm == 0) {\n                        // C.SRLI64, HINT for RV32/RV64\n                    }\n                    // The MSB can never be 1, hence no need to sign ext.\n                    Rp1 = rvZext(Rp1) >> imm;\n                ', 'uint64_t'],{})

    Fault
    C_srli::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        uint64_t Rp1 = 0;
;
        Rp1 = xc->getRegOperand(this, 0);
;
        
                    if (rvSelect((bool)CIMM1, false)) {
                        return std::make_shared<IllegalInstFault>(
                                "shmat[5] != 0", machInst);
                    }
                    if (imm == 0) {
                        // C.SRLI64, HINT for RV32/RV64
                    }
                    // The MSB can never be 1, hence no need to sign ext.
                    Rp1 = rvZext(Rp1) >> imm;
                ;
        
        {
            RegVal final_val = Rp1;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    C_srli::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// CIOp::c_srai(['\n                    imm = CIMM5 | (CIMM1 << 5);\n                ', '\n                    if (rvSelect((bool)CIMM1, false)) {\n                        return std::make_shared<IllegalInstFault>(\n                                "shmat[5] != 0", machInst);\n                    }\n                    if (imm == 0) {\n                        // C.SRAI64, HINT for RV32/RV64\n                    }\n                    Rp1_sd = rvSext(Rp1_sd) >> imm;\n                ', 'uint64_t'],{})

    Fault
    C_srai::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        int64_t Rp1 = 0;
;
        Rp1 = xc->getRegOperand(this, 0);
;
        
                    if (rvSelect((bool)CIMM1, false)) {
                        return std::make_shared<IllegalInstFault>(
                                "shmat[5] != 0", machInst);
                    }
                    if (imm == 0) {
                        // C.SRAI64, HINT for RV32/RV64
                    }
                    Rp1 = rvSext(Rp1) >> imm;
                ;
        
        {
            RegVal final_val = Rp1;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    C_srai::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// CIOp::c_andi(['\n                    imm = CIMM5;\n                    if (CIMM1 > 0)\n                        imm |= ~((uint64_t)0x1F);\n                ', '\n                    Rp1 = rvSext(Rp1 & imm);\n                ', 'uint64_t'],{})

    Fault
    C_andi::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        uint64_t Rp1 = 0;
;
        Rp1 = xc->getRegOperand(this, 0);
;
        
                    Rp1 = rvSext(Rp1 & imm);
                ;
        
        {
            RegVal final_val = Rp1;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    C_andi::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// CompressedROp::c_sub(['\n                            Rp1 = rvSext(Rp1 - Rp2);\n                        '],{})

    Fault
    C_sub::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rp1 = 0;
uint64_t Rp2 = 0;
;
        Rp1 = xc->getRegOperand(this, 0);
Rp2 = xc->getRegOperand(this, 1);
;
        
                            Rp1 = rvSext(Rp1 - Rp2);
                        ;
        
        {
            RegVal final_val = Rp1;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    C_sub::generateDisassembly(
            Addr pc, const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(1)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        ss << registerName(indices[0]);
        if (_numSrcRegs >= 2)
            ss << ", " << registerName(indices[1]);
        return ss.str();
    }

// CompressedROp::c_xor(['\n                            Rp1 = rvSext(Rp1 ^ Rp2);\n                        '],{})

    Fault
    C_xor::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rp1 = 0;
uint64_t Rp2 = 0;
;
        Rp1 = xc->getRegOperand(this, 0);
Rp2 = xc->getRegOperand(this, 1);
;
        
                            Rp1 = rvSext(Rp1 ^ Rp2);
                        ;
        
        {
            RegVal final_val = Rp1;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    C_xor::generateDisassembly(
            Addr pc, const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(1)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        ss << registerName(indices[0]);
        if (_numSrcRegs >= 2)
            ss << ", " << registerName(indices[1]);
        return ss.str();
    }

// CompressedROp::c_or(['\n                            Rp1 = rvSext(Rp1 | Rp2);\n                        '],{})

    Fault
    C_or::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rp1 = 0;
uint64_t Rp2 = 0;
;
        Rp1 = xc->getRegOperand(this, 0);
Rp2 = xc->getRegOperand(this, 1);
;
        
                            Rp1 = rvSext(Rp1 | Rp2);
                        ;
        
        {
            RegVal final_val = Rp1;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    C_or::generateDisassembly(
            Addr pc, const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(1)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        ss << registerName(indices[0]);
        if (_numSrcRegs >= 2)
            ss << ", " << registerName(indices[1]);
        return ss.str();
    }

// CompressedROp::c_and(['\n                            Rp1 = rvSext(Rp1 & Rp2);\n                        '],{})

    Fault
    C_and::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rp1 = 0;
uint64_t Rp2 = 0;
;
        Rp1 = xc->getRegOperand(this, 0);
Rp2 = xc->getRegOperand(this, 1);
;
        
                            Rp1 = rvSext(Rp1 & Rp2);
                        ;
        
        {
            RegVal final_val = Rp1;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    C_and::generateDisassembly(
            Addr pc, const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(1)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        ss << registerName(indices[0]);
        if (_numSrcRegs >= 2)
            ss << ", " << registerName(indices[1]);
        return ss.str();
    }

// Unknown::unknown(([], {}))

// CompressedROp::c_subw(['\n                                Rp1_sd = (int32_t)Rp1_sd - Rp2_sw;\n                            '],{})

    Fault
    C_subw::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int64_t Rp1 = 0;
int32_t Rp2 = 0;
;
        Rp1 = xc->getRegOperand(this, 0);
Rp2 = xc->getRegOperand(this, 1);
;
        
                                Rp1 = (int32_t)Rp1 - Rp2;
                            ;
        
        {
            RegVal final_val = Rp1;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    C_subw::generateDisassembly(
            Addr pc, const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(1)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        ss << registerName(indices[0]);
        if (_numSrcRegs >= 2)
            ss << ", " << registerName(indices[1]);
        return ss.str();
    }

// Unknown::unknown(([], {}))

// CompressedROp::c_addw(['\n                                Rp1_sd = (int32_t)Rp1_sd + Rp2_sw;\n                            '],{})

    Fault
    C_addw::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int64_t Rp1 = 0;
int32_t Rp2 = 0;
;
        Rp1 = xc->getRegOperand(this, 0);
Rp2 = xc->getRegOperand(this, 1);
;
        
                                Rp1 = (int32_t)Rp1 + Rp2;
                            ;
        
        {
            RegVal final_val = Rp1;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    C_addw::generateDisassembly(
            Addr pc, const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(1)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        ss << registerName(indices[0]);
        if (_numSrcRegs >= 2)
            ss << ", " << registerName(indices[1]);
        return ss.str();
    }

// Unknown::unknown(([], {}))

// CompressedROp::c_mul(['\n                            Rp1_sd = rvSext(Rp1_sd * Rp2_sd);\n                        ', 'IntMultOp'],{})

    Fault
    C_mul::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int64_t Rp1 = 0;
int64_t Rp2 = 0;
;
        Rp1 = xc->getRegOperand(this, 0);
Rp2 = xc->getRegOperand(this, 1);
;
        
                            Rp1 = rvSext(Rp1 * Rp2);
                        ;
        
        {
            RegVal final_val = Rp1;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    C_mul::generateDisassembly(
            Addr pc, const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(1)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        ss << registerName(indices[0]);
        if (_numSrcRegs >= 2)
            ss << ", " << registerName(indices[1]);
        return ss.str();
    }

// CompressedROp::c_zext_b(['\n                                Rp1 = Rp1 & 0xFFULL;\n                            '],{})

    Fault
    C_zext_b::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rp1 = 0;
;
        Rp1 = xc->getRegOperand(this, 0);
;
        
                                Rp1 = Rp1 & 0xFFULL;
                            ;
        
        {
            RegVal final_val = Rp1;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    C_zext_b::generateDisassembly(
            Addr pc, const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(1)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        ss << registerName(indices[0]);
        if (_numSrcRegs >= 2)
            ss << ", " << registerName(indices[1]);
        return ss.str();
    }

// CompressedROp::c_sext_b(['\n                                Rp1 = sext<8>(Rp1 & 0xFFULL);\n                            '],{})

    Fault
    C_sext_b::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rp1 = 0;
;
        Rp1 = xc->getRegOperand(this, 0);
;
        
                                Rp1 = sext<8>(Rp1 & 0xFFULL);
                            ;
        
        {
            RegVal final_val = Rp1;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    C_sext_b::generateDisassembly(
            Addr pc, const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(1)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        ss << registerName(indices[0]);
        if (_numSrcRegs >= 2)
            ss << ", " << registerName(indices[1]);
        return ss.str();
    }

// CompressedROp::c_zext_h(['\n                                Rp1 = Rp1 & 0xFFFFULL;\n                            '],{})

    Fault
    C_zext_h::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rp1 = 0;
;
        Rp1 = xc->getRegOperand(this, 0);
;
        
                                Rp1 = Rp1 & 0xFFFFULL;
                            ;
        
        {
            RegVal final_val = Rp1;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    C_zext_h::generateDisassembly(
            Addr pc, const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(1)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        ss << registerName(indices[0]);
        if (_numSrcRegs >= 2)
            ss << ", " << registerName(indices[1]);
        return ss.str();
    }

// CompressedROp::c_sext_h(['\n                                Rp1 = sext<16>(Rp1 & 0xFFFFULL);\n                            '],{})

    Fault
    C_sext_h::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rp1 = 0;
;
        Rp1 = xc->getRegOperand(this, 0);
;
        
                                Rp1 = sext<16>(Rp1 & 0xFFFFULL);
                            ;
        
        {
            RegVal final_val = Rp1;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    C_sext_h::generateDisassembly(
            Addr pc, const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(1)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        ss << registerName(indices[0]);
        if (_numSrcRegs >= 2)
            ss << ", " << registerName(indices[1]);
        return ss.str();
    }

// CompressedROp::c_zext_w(['\n                                    Rp1 = bits(Rp1, 31, 0);\n                                '],{})

    Fault
    C_zext_w::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rp1 = 0;
;
        Rp1 = xc->getRegOperand(this, 0);
;
        
                                    Rp1 = bits(Rp1, 31, 0);
                                ;
        
        {
            RegVal final_val = Rp1;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    C_zext_w::generateDisassembly(
            Addr pc, const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(1)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        ss << registerName(indices[0]);
        if (_numSrcRegs >= 2)
            ss << ", " << registerName(indices[1]);
        return ss.str();
    }

// Unknown::unknown(([], {}))

// CompressedROp::c_not(['\n                                Rp1 = ~Rp1;\n                            '],{})

    Fault
    C_not::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rp1 = 0;
;
        Rp1 = xc->getRegOperand(this, 0);
;
        
                                Rp1 = ~Rp1;
                            ;
        
        {
            RegVal final_val = Rp1;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    C_not::generateDisassembly(
            Addr pc, const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(1)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        ss << registerName(indices[0]);
        if (_numSrcRegs >= 2)
            ss << ", " << registerName(indices[1]);
        return ss.str();
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// CJOp::c_j((['\n            NPC = rvSext(PC + imm);\n        ', 'IsDirectControl', 'IsUncondControl'], {}))

    Fault
    C_j::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t PC = 0;
uint64_t NPC = 0;
RiscvISAInst::PCState __parserAutoPCState;
;
        set(__parserAutoPCState, xc->pcState());
PC = __parserAutoPCState.pc();
;
        
            NPC = rvSext(PC + imm);
        ;
        __parserAutoPCState.npc(NPC);
xc->pcState(__parserAutoPCState);
;
        return NoFault;
    }

    std::unique_ptr<PCStateBase>
    C_j::branchTarget(const PCStateBase &branch_pc) const
    {
        auto &rpc = branch_pc.as<RiscvISA::PCState>();
        std::unique_ptr<PCState> npc(dynamic_cast<PCState*>(rpc.clone()));
        npc->set(rvSext(rpc.pc() + imm));
        return npc;
    }

    std::string
    C_j::generateDisassembly(
            Addr pc, const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// CBOp::c_beqz(['\n                if (rvSext(Rp1) == 0)\n                    NPC = rvSext(PC + imm);\n                else\n                    NPC = NPC;\n            ', 'IsDirectControl', 'IsCondControl'],{})

    Fault
    C_beqz::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rp1 = 0;
uint64_t PC = 0;
uint64_t NPC = 0;
RiscvISAInst::PCState __parserAutoPCState;
;
        set(__parserAutoPCState, xc->pcState());
Rp1 = xc->getRegOperand(this, 0);
PC = __parserAutoPCState.pc();
NPC = __parserAutoPCState.npc();
;
        
                if (rvSext(Rp1) == 0)
                    NPC = rvSext(PC + imm);
                else
                    NPC = NPC;
            ;
        __parserAutoPCState.npc(NPC);
xc->pcState(__parserAutoPCState);
;
        return NoFault;
    }

    std::unique_ptr<PCStateBase>
    C_beqz::branchTarget(const PCStateBase &branch_pc) const
    {
        auto &rpc = branch_pc.as<RiscvISA::PCState>();
        std::unique_ptr<PCState> npc(dynamic_cast<PCState*>(rpc.clone()));
        npc->set(rvSext(rpc.pc() + imm));
        return npc;
    }

    std::string
    C_beqz::generateDisassembly(
            Addr pc, const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {srcRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// CBOp::c_bnez(['\n                if (rvSext(Rp1) != 0)\n                    NPC = rvSext(PC + imm);\n                else\n                    NPC = NPC;\n            ', 'IsDirectControl', 'IsCondControl'],{})

    Fault
    C_bnez::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rp1 = 0;
uint64_t PC = 0;
uint64_t NPC = 0;
RiscvISAInst::PCState __parserAutoPCState;
;
        set(__parserAutoPCState, xc->pcState());
Rp1 = xc->getRegOperand(this, 0);
PC = __parserAutoPCState.pc();
NPC = __parserAutoPCState.npc();
;
        
                if (rvSext(Rp1) != 0)
                    NPC = rvSext(PC + imm);
                else
                    NPC = NPC;
            ;
        __parserAutoPCState.npc(NPC);
xc->pcState(__parserAutoPCState);
;
        return NoFault;
    }

    std::unique_ptr<PCStateBase>
    C_bnez::branchTarget(const PCStateBase &branch_pc) const
    {
        auto &rpc = branch_pc.as<RiscvISA::PCState>();
        std::unique_ptr<PCState> npc(dynamic_cast<PCState*>(rpc.clone()));
        npc->set(rvSext(rpc.pc() + imm));
        return npc;
    }

    std::string
    C_bnez::generateDisassembly(
            Addr pc, const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {srcRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// Unknown::unknown(([], {}))

// CIOp::c_slli((['\n            imm = CIMM5 | (CIMM1 << 5);\n        ', '\n            if (rvSelect((bool)CIMM1, false)) {\n                return std::make_shared<IllegalInstFault>(\n                        "shmat[5] != 0", machInst);\n            }\n            if (imm == 0) {\n                // C.SLLI64, HINT for RV32/RV64\n            }\n            // RC1 == 0 is HINT\n            Rc1 = rvSext(Rc1 << imm);\n        ', 'uint64_t'], {}))

    Fault
    C_slli::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        uint64_t Rc1 = 0;
;
        Rc1 = xc->getRegOperand(this, 0);
;
        
            if (rvSelect((bool)CIMM1, false)) {
                return std::make_shared<IllegalInstFault>(
                        "shmat[5] != 0", machInst);
            }
            if (imm == 0) {
                // C.SLLI64, HINT for RV32/RV64
            }
            // RC1 == 0 is HINT
            Rc1 = rvSext(Rc1 << imm);
        ;
        
        {
            RegVal final_val = Rc1;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    C_slli::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// CompressedLoad::c_fldsp(['\n                    offset = CIMM5<4:3> << 3 |\n                             CIMM1 << 5 |\n                             CIMM5<2:0> << 6;\n                ', '\n                    STATUS status = xc->readMiscReg(MISCREG_STATUS);\n                    if (status.fs == FPUStatus::OFF)\n                        return std::make_shared<IllegalInstFault>("FPU is off",\n                                                                   machInst);\n\n                    status.fs = FPUStatus::DIRTY;\n                    xc->setMiscReg(MISCREG_STATUS, status);\n\n                    Fc1_bits = Mem;\n                ', '\n                    EA = rvSext(sp + offset);\n                '],{})

    Fault
    C_fldsp::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Fc1_bits = 0;
uint64_t sp = 0;
uint64_t Mem = {};
;
        sp = xc->getRegOperand(this, 0);
;
        
                    EA = rvSext(sp + offset);
                ;

        {
            Fault fault =
                readMemAtomicLE(xc, traceData, EA, Mem, memAccessFlags);
            if (fault != NoFault)
                return fault;
        }

        
                    STATUS status = xc->readMiscReg(MISCREG_STATUS);
                    if (status.fs == FPUStatus::OFF)
                        return std::make_shared<IllegalInstFault>("FPU is off",
                                                                   machInst);

                    status.fs = FPUStatus::DIRTY;
                    xc->setMiscReg(MISCREG_STATUS, status);

                    Fc1_bits = Mem;
                ;

        
        {
            RegVal final_val = Fc1_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

    Fault
    C_fldsp::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t sp = 0;
uint64_t Mem = {};
;
        sp = xc->getRegOperand(this, 0);
;
        
                    EA = rvSext(sp + offset);
                ;

        return initiateMemRead(xc, traceData, EA, Mem, memAccessFlags);
    }

    Fault
    C_fldsp::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Fc1_bits = 0;
uint64_t Mem = {};
;
        ;

        getMemLE(pkt, Mem, traceData);

        
                    STATUS status = xc->readMiscReg(MISCREG_STATUS);
                    if (status.fs == FPUStatus::OFF)
                        return std::make_shared<IllegalInstFault>("FPU is off",
                                                                   machInst);

                    status.fs = FPUStatus::DIRTY;
                    xc->setMiscReg(MISCREG_STATUS, status);

                    Fc1_bits = Mem;
                ;
        
        {
            RegVal final_val = Fc1_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// Unknown::unknown(([], {}))

// CompressedLoad::c_lwsp(['\n                offset = CIMM5<4:2> << 2 |\n                         CIMM1 << 5 |\n                         CIMM5<1:0> << 6;\n            ', '\n                if (RC1 == 0) {\n                    return std::make_shared<IllegalInstFault>(\n                            "source reg x0", machInst);\n                }\n                Rc1_sw = Mem_sw;\n            ', '\n                EA = rvSext(sp + offset);\n            '],{})

    Fault
    C_lwsp::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t sp = 0;
int32_t Rc1 = 0;
int32_t Mem = {};
;
        sp = xc->getRegOperand(this, 0);
;
        
                EA = rvSext(sp + offset);
            ;

        {
            Fault fault =
                readMemAtomicLE(xc, traceData, EA, Mem, memAccessFlags);
            if (fault != NoFault)
                return fault;
        }

        
                if (RC1 == 0) {
                    return std::make_shared<IllegalInstFault>(
                            "source reg x0", machInst);
                }
                Rc1 = Mem;
            ;

        
        {
            RegVal final_val = Rc1;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

    Fault
    C_lwsp::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t sp = 0;
int32_t Mem = {};
;
        sp = xc->getRegOperand(this, 0);
;
        
                EA = rvSext(sp + offset);
            ;

        return initiateMemRead(xc, traceData, EA, Mem, memAccessFlags);
    }

    Fault
    C_lwsp::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int32_t Rc1 = 0;
int32_t Mem = {};
;
        ;

        getMemLE(pkt, Mem, traceData);

        
                if (RC1 == 0) {
                    return std::make_shared<IllegalInstFault>(
                            "source reg x0", machInst);
                }
                Rc1 = Mem;
            ;
        
        {
            RegVal final_val = Rc1;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// CompressedLoad::c_flwsp(['\n                    offset = CIMM5<4:2> << 2 |\n                             CIMM1 << 5 |\n                             CIMM5<1:0> << 6;\n                ', '\n                    STATUS status = xc->readMiscReg(MISCREG_STATUS);\n                    if (status.fs == FPUStatus::OFF)\n                        return std::make_shared<IllegalInstFault>("FPU is off",\n                                                                   machInst);\n\n                    status.fs = FPUStatus::DIRTY;\n                    xc->setMiscReg(MISCREG_STATUS, status);\n\n                    freg_t fd;\n                    fd = freg(f32(Mem_uw));\n                    Fc1_bits = fd.v;\n                ', '\n                    EA = rvSext(sp_uw + offset);\n                '],{})

    Fault
    C_flwsp::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Fc1_bits = 0;
uint32_t sp = 0;
uint32_t Mem = {};
;
        sp = xc->getRegOperand(this, 0);
;
        
                    EA = rvSext(sp + offset);
                ;

        {
            Fault fault =
                readMemAtomicLE(xc, traceData, EA, Mem, memAccessFlags);
            if (fault != NoFault)
                return fault;
        }

        
                    STATUS status = xc->readMiscReg(MISCREG_STATUS);
                    if (status.fs == FPUStatus::OFF)
                        return std::make_shared<IllegalInstFault>("FPU is off",
                                                                   machInst);

                    status.fs = FPUStatus::DIRTY;
                    xc->setMiscReg(MISCREG_STATUS, status);

                    freg_t fd;
                    fd = freg(f32(Mem));
                    Fc1_bits = fd.v;
                ;

        
        {
            RegVal final_val = Fc1_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

    Fault
    C_flwsp::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint32_t sp = 0;
uint32_t Mem = {};
;
        sp = xc->getRegOperand(this, 0);
;
        
                    EA = rvSext(sp + offset);
                ;

        return initiateMemRead(xc, traceData, EA, Mem, memAccessFlags);
    }

    Fault
    C_flwsp::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Fc1_bits = 0;
uint32_t Mem = {};
;
        ;

        getMemLE(pkt, Mem, traceData);

        
                    STATUS status = xc->readMiscReg(MISCREG_STATUS);
                    if (status.fs == FPUStatus::OFF)
                        return std::make_shared<IllegalInstFault>("FPU is off",
                                                                   machInst);

                    status.fs = FPUStatus::DIRTY;
                    xc->setMiscReg(MISCREG_STATUS, status);

                    freg_t fd;
                    fd = freg(f32(Mem));
                    Fc1_bits = fd.v;
                ;
        
        {
            RegVal final_val = Fc1_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// CompressedLoad::c_ldsp(['\n                    offset = CIMM5<4:3> << 3 |\n                             CIMM1 << 5 |\n                             CIMM5<2:0> << 6;\n                ', '\n                    if (RC1 == 0) {\n                        return std::make_shared<IllegalInstFault>(\n                                "source reg x0", machInst);\n                    }\n                    Rc1_sd = Mem_sd;\n                ', '\n                    EA = sp + offset;\n                '],{})

    Fault
    C_ldsp::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t sp = 0;
int64_t Rc1 = 0;
int64_t Mem = {};
;
        sp = xc->getRegOperand(this, 0);
;
        
                    EA = sp + offset;
                ;

        {
            Fault fault =
                readMemAtomicLE(xc, traceData, EA, Mem, memAccessFlags);
            if (fault != NoFault)
                return fault;
        }

        
                    if (RC1 == 0) {
                        return std::make_shared<IllegalInstFault>(
                                "source reg x0", machInst);
                    }
                    Rc1 = Mem;
                ;

        
        {
            RegVal final_val = Rc1;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

    Fault
    C_ldsp::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t sp = 0;
int64_t Mem = {};
;
        sp = xc->getRegOperand(this, 0);
;
        
                    EA = sp + offset;
                ;

        return initiateMemRead(xc, traceData, EA, Mem, memAccessFlags);
    }

    Fault
    C_ldsp::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int64_t Rc1 = 0;
int64_t Mem = {};
;
        ;

        getMemLE(pkt, Mem, traceData);

        
                    if (RC1 == 0) {
                        return std::make_shared<IllegalInstFault>(
                                "source reg x0", machInst);
                    }
                    Rc1 = Mem;
                ;
        
        {
            RegVal final_val = Rc1;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// Unknown::unknown(([], {}))

// CJump::c_jr((['\n                    if (RC1 == 0) {\n                        return std::make_shared<IllegalInstFault>(\n                                "source reg x0", machInst);\n                    }\n                    NPC = rvSext(Rc1 & (~0x1));\n                ', 'IsIndirectControl', 'IsUncondControl'], {}))

    Fault
    C_jr::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        uint64_t Rc1 = 0;
uint64_t NPC = 0;
RiscvISAInst::PCState __parserAutoPCState;
;
        set(__parserAutoPCState, xc->pcState());
Rc1 = xc->getRegOperand(this, 0);
;
        
                    if (RC1 == 0) {
                        return std::make_shared<IllegalInstFault>(
                                "source reg x0", machInst);
                    }
                    NPC = rvSext(Rc1 & (~0x1));
                ;
        __parserAutoPCState.npc(NPC);
xc->pcState(__parserAutoPCState);
;
        return NoFault;
    }

    std::unique_ptr<PCStateBase>
    C_jr::branchTarget(ThreadContext *tc) const
    {
        PCStateBase *pc_ptr = tc->pcState().clone();
        pc_ptr->as<PCState>().set(rvSext(tc->getReg(srcRegIdx(0)) & ~0x1));
        return std::unique_ptr<PCStateBase>{pc_ptr};
    }

    std::string
    C_jr::generateDisassembly(
            Addr pc, const loader::SymbolTable *symtab) const
    {
        std::stringstream ss;
        ss << mnemonic << ' ' << registerName(srcRegIdx(0));
        return ss.str();
    }

// CROp::c_mv((['\n                    // RC1 == 0 is HINT\n                    Rc1 = rvSext(Rc2);\n                '], {}))

    Fault
    C_mv::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rc1 = 0;
uint64_t Rc2 = 0;
;
        Rc2 = xc->getRegOperand(this, 0);
;
        
                    // RC1 == 0 is HINT
                    Rc1 = rvSext(Rc2);
                ;
        
        {
            RegVal final_val = Rc1;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// SystemOp::c_ebreak((['\n                        // NB: Semihosting spec requires uncompressed ebreak,\n                        // so this instruction does not check for semihosting.\n                        return std::make_shared<BreakpointFault>(\n                            xc->pcState());\n                    ', 'IsSerializeAfter', 'IsNonSpeculative', 'No_OpClass'], {}))

    Fault
    C_ebreak::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        ;
        ;
        
                        // NB: Semihosting spec requires uncompressed ebreak,
                        // so this instruction does not check for semihosting.
                        return std::make_shared<BreakpointFault>(
                            xc->pcState());
                    ;
        ;
        return NoFault;
    }

// CJump::c_jalr((['\n                        ra = rvSext(NPC);\n                        NPC = rvSext(Rc1 & (~0x1));\n                    ', 'IsIndirectControl', 'IsUncondControl', 'IsCall'], {}))

    Fault
    C_jalr::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        uint64_t ra = 0;
uint64_t Rc1 = 0;
uint64_t NPC = 0;
RiscvISAInst::PCState __parserAutoPCState;
;
        set(__parserAutoPCState, xc->pcState());
Rc1 = xc->getRegOperand(this, 0);
NPC = __parserAutoPCState.npc();
;
        
                        ra = rvSext(NPC);
                        NPC = rvSext(Rc1 & (~0x1));
                    ;
        
        {
            RegVal final_val = ra;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        }__parserAutoPCState.npc(NPC);
xc->pcState(__parserAutoPCState);
;
        return NoFault;
    }

    std::unique_ptr<PCStateBase>
    C_jalr::branchTarget(ThreadContext *tc) const
    {
        PCStateBase *pc_ptr = tc->pcState().clone();
        pc_ptr->as<PCState>().set(rvSext(tc->getReg(srcRegIdx(0)) & ~0x1));
        return std::unique_ptr<PCStateBase>{pc_ptr};
    }

    std::string
    C_jalr::generateDisassembly(
            Addr pc, const loader::SymbolTable *symtab) const
    {
        std::stringstream ss;
        ss << mnemonic << ' ' << registerName(srcRegIdx(0));
        return ss.str();
    }

// CompressedROp::c_add((['\n                    // RC1 == 0 is HINT\n                    Rc1_sd = rvSext(Rc1_sd + Rc2_sd);\n                '], {}))

    Fault
    C_add::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int64_t Rc1 = 0;
int64_t Rc2 = 0;
;
        Rc1 = xc->getRegOperand(this, 0);
Rc2 = xc->getRegOperand(this, 1);
;
        
                    // RC1 == 0 is HINT
                    Rc1 = rvSext(Rc1 + Rc2);
                ;
        
        {
            RegVal final_val = Rc1;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    C_add::generateDisassembly(
            Addr pc, const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(1)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        ss << registerName(indices[0]);
        if (_numSrcRegs >= 2)
            ss << ", " << registerName(indices[1]);
        return ss.str();
    }

// Unknown::unknown(([], {}))

// CmMvsa01::cm_mvsa01(([], {}))

    std::string
    Cm_mvsa01::generateDisassembly(
        Addr pc, const loader::SymbolTable *symtab) const
    {
        std::stringstream ss;
        ss << mnemonic << ' ' << registerName(StackRegs[machInst.r1s])
            << ", " << registerName(StackRegs[machInst.r2s]);
        return ss.str();
    }

    Fault
    Cm_mvsa01MvMicroInst::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        uint64_t CmPopReg = 0;
uint64_t CmPushReg = 0;
;
        CmPushReg = xc->getRegOperand(this, 0);
;
        CmPopReg = CmPushReg;;
        
        {
            RegVal final_val = CmPopReg;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    Cm_mvsa01MvMicroInst::generateDisassembly(
        Addr pc, const loader::SymbolTable *symtab) const
    {
        std::stringstream ss;
        ss << mnemonic << ' ' << registerName(destRegIdx(0)) << ", "
            << registerName(srcRegIdx(0));
        return ss.str();
    }

// CmMva01s::cm_mva01s(([], {}))

    std::string
    Cm_mva01s::generateDisassembly(
        Addr pc, const loader::SymbolTable *symtab) const
    {
        std::stringstream ss;
        ss << mnemonic << ' ' << registerName(StackRegs[machInst.r1s])
            << ", " << registerName(StackRegs[machInst.r2s]);
        return ss.str();
    }

    Fault
    Cm_mva01sMvMicroInst::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        uint64_t CmPopReg = 0;
uint64_t CmPushReg = 0;
;
        CmPushReg = xc->getRegOperand(this, 0);
;
        CmPopReg = CmPushReg;;
        
        {
            RegVal final_val = CmPopReg;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    Cm_mva01sMvMicroInst::generateDisassembly(
        Addr pc, const loader::SymbolTable *symtab) const
    {
        std::stringstream ss;
        ss << mnemonic << ' ' << registerName(destRegIdx(0)) << ", "
            << registerName(srcRegIdx(0));
        return ss.str();
    }

// Unknown::unknown(([], {}))

// CmPush::cm_push(([], {}))

    std::string
    Cm_push::generateDisassembly(
        Addr pc, const loader::SymbolTable *symtab) const
    {
        std::stringstream ss;
        ss << mnemonic << ' ' << getRlistStr() << ", " << (int64_t)-stackAdj();
        return ss.str();
    }

    Fault
    Cm_push32MicroInst::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t sp = 0;
int32_t CmPushReg = 0;
int32_t Mem = {};
;
        sp = xc->getRegOperand(this, 0);
CmPushReg = xc->getRegOperand(this, 1);
;
        EA = rvSext(sp + offset);;

        Mem = CmPushReg;;

        {
            Fault fault =
                writeMemAtomicLE(xc, traceData, Mem, EA, memAccessFlags,
                        nullptr);
            if (fault != NoFault)
                return fault;
        }

        ;

        return NoFault;
    }

    std::string
    Cm_push32MicroInst::generateDisassembly(
        Addr pc, const loader::SymbolTable *symtab) const
    {
        std::stringstream ss;
        ss << mnemonic << ' ' << registerName(srcRegIdx(1)) << ", " <<
            offset << '(' << registerName(srcRegIdx(0)) << ')';
        return ss.str();
    }

    Fault
    Cm_push32MicroInst::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t sp = 0;
int32_t CmPushReg = 0;
int32_t Mem = {};
;
        sp = xc->getRegOperand(this, 0);
CmPushReg = xc->getRegOperand(this, 1);
;
        EA = rvSext(sp + offset);;

        Mem = CmPushReg;;

        {
            Fault fault = writeMemTimingLE(xc, traceData, Mem, EA,
                memAccessFlags, nullptr);
            if (fault != NoFault)
                return fault;
        }

        ;

        return NoFault;
    }

    Fault
    Cm_push32MicroInst::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault
    Cm_push64MicroInst::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t sp = 0;
uint64_t CmPushReg = 0;
uint64_t Mem = {};
;
        sp = xc->getRegOperand(this, 0);
CmPushReg = xc->getRegOperand(this, 1);
;
        EA = rvSext(sp + offset);;

        Mem = CmPushReg;;

        {
            Fault fault =
                writeMemAtomicLE(xc, traceData, Mem, EA, memAccessFlags,
                        nullptr);
            if (fault != NoFault)
                return fault;
        }

        ;

        return NoFault;
    }

    std::string
    Cm_push64MicroInst::generateDisassembly(
        Addr pc, const loader::SymbolTable *symtab) const
    {
        std::stringstream ss;
        ss << mnemonic << ' ' << registerName(srcRegIdx(1)) << ", " <<
            offset << '(' << registerName(srcRegIdx(0)) << ')';
        return ss.str();
    }

    Fault
    Cm_push64MicroInst::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t sp = 0;
uint64_t CmPushReg = 0;
uint64_t Mem = {};
;
        sp = xc->getRegOperand(this, 0);
CmPushReg = xc->getRegOperand(this, 1);
;
        EA = rvSext(sp + offset);;

        Mem = CmPushReg;;

        {
            Fault fault = writeMemTimingLE(xc, traceData, Mem, EA,
                memAccessFlags, nullptr);
            if (fault != NoFault)
                return fault;
        }

        ;

        return NoFault;
    }

    Fault
    Cm_push64MicroInst::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault
    Cm_pushSpAdjMicroInst::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        uint64_t spd = 0;
uint64_t sp = 0;
;
        sp = xc->getRegOperand(this, 0);
;
        spd = rvSext(sp + adj);;
        
        {
            RegVal final_val = spd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    Cm_pushSpAdjMicroInst::generateDisassembly(
        Addr pc, const loader::SymbolTable *symtab) const
    {
        std::stringstream ss;
        ss << mnemonic << ' ' << registerName(destRegIdx(0)) << ", "
            << registerName(srcRegIdx(0)) << ", " << adj;
        return ss.str();
    }

// CmPop::cm_pop(([], {}))

    std::string
    Cm_pop::generateDisassembly(
        Addr pc, const loader::SymbolTable *symtab) const
    {
        std::stringstream ss;
        ss << mnemonic << ' ' << getRlistStr() << ", " << stackAdj();
        return ss.str();
    }

    Fault
    Cm_pop32MicroInst::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        Addr EA;

        int32_t CmPopReg = 0;
uint64_t sp = 0;
int32_t Mem = {};
;
        sp = xc->getRegOperand(this, 0);
;
        EA = rvSext(sp + offset);;

        {
            Fault fault =
                readMemAtomicLE(xc, traceData, EA, Mem, memAccessFlags);
            if (fault != NoFault)
                return fault;
        }

        CmPopReg = Mem;;

        
        {
            RegVal final_val = CmPopReg;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

    std::string
    Cm_pop32MicroInst::generateDisassembly(
        Addr pc, const loader::SymbolTable *symtab) const
    {
        std::stringstream ss;
        ss << mnemonic << ' ' << registerName(destRegIdx(0)) << ", " <<
            offset << '(' << registerName(srcRegIdx(0)) << ')';
        return ss.str();
    }

    Fault
    Cm_pop32MicroInst::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t sp = 0;
int32_t Mem = {};
;
        sp = xc->getRegOperand(this, 0);
;
        EA = rvSext(sp + offset);;

        return initiateMemRead(xc, traceData, EA, Mem, memAccessFlags);
    }

    Fault
    Cm_pop32MicroInst::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int32_t CmPopReg = 0;
int32_t Mem = {};
;
        ;

        getMemLE(pkt, Mem, traceData);

        CmPopReg = Mem;;
        
        {
            RegVal final_val = CmPopReg;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

    Fault
    Cm_pop64MicroInst::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t CmPopReg = 0;
uint64_t sp = 0;
uint64_t Mem = {};
;
        sp = xc->getRegOperand(this, 0);
;
        EA = rvSext(sp + offset);;

        {
            Fault fault =
                readMemAtomicLE(xc, traceData, EA, Mem, memAccessFlags);
            if (fault != NoFault)
                return fault;
        }

        CmPopReg = Mem;;

        
        {
            RegVal final_val = CmPopReg;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

    std::string
    Cm_pop64MicroInst::generateDisassembly(
        Addr pc, const loader::SymbolTable *symtab) const
    {
        std::stringstream ss;
        ss << mnemonic << ' ' << registerName(destRegIdx(0)) << ", " <<
            offset << '(' << registerName(srcRegIdx(0)) << ')';
        return ss.str();
    }

    Fault
    Cm_pop64MicroInst::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t sp = 0;
uint64_t Mem = {};
;
        sp = xc->getRegOperand(this, 0);
;
        EA = rvSext(sp + offset);;

        return initiateMemRead(xc, traceData, EA, Mem, memAccessFlags);
    }

    Fault
    Cm_pop64MicroInst::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t CmPopReg = 0;
uint64_t Mem = {};
;
        ;

        getMemLE(pkt, Mem, traceData);

        CmPopReg = Mem;;
        
        {
            RegVal final_val = CmPopReg;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

    Fault
    Cm_popSpAdjMicroInst::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        uint64_t spd = 0;
uint64_t sp = 0;
;
        sp = xc->getRegOperand(this, 0);
;
        spd = rvSext(sp + adj);;
        
        {
            RegVal final_val = spd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    Cm_popSpAdjMicroInst::generateDisassembly(
        Addr pc, const loader::SymbolTable *symtab) const
    {
        std::stringstream ss;
        ss << mnemonic << ' ' << registerName(destRegIdx(0)) << ", "
            << registerName(srcRegIdx(0)) << ", " << adj;
        return ss.str();
    }

// Unknown::unknown(([], {}))

// CmPop::cm_popretz(([], {'is_ret': 'True', 'has_a0': 'True'}))

    std::string
    Cm_popretz::generateDisassembly(
        Addr pc, const loader::SymbolTable *symtab) const
    {
        std::stringstream ss;
        ss << mnemonic << ' ' << getRlistStr() << ", " << stackAdj();
        return ss.str();
    }

    Fault
    Cm_popretz32MicroInst::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        Addr EA;

        int32_t CmPopReg = 0;
uint64_t sp = 0;
int32_t Mem = {};
;
        sp = xc->getRegOperand(this, 0);
;
        EA = rvSext(sp + offset);;

        {
            Fault fault =
                readMemAtomicLE(xc, traceData, EA, Mem, memAccessFlags);
            if (fault != NoFault)
                return fault;
        }

        CmPopReg = Mem;;

        
        {
            RegVal final_val = CmPopReg;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

    std::string
    Cm_popretz32MicroInst::generateDisassembly(
        Addr pc, const loader::SymbolTable *symtab) const
    {
        std::stringstream ss;
        ss << mnemonic << ' ' << registerName(destRegIdx(0)) << ", " <<
            offset << '(' << registerName(srcRegIdx(0)) << ')';
        return ss.str();
    }

    Fault
    Cm_popretz32MicroInst::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t sp = 0;
int32_t Mem = {};
;
        sp = xc->getRegOperand(this, 0);
;
        EA = rvSext(sp + offset);;

        return initiateMemRead(xc, traceData, EA, Mem, memAccessFlags);
    }

    Fault
    Cm_popretz32MicroInst::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int32_t CmPopReg = 0;
int32_t Mem = {};
;
        ;

        getMemLE(pkt, Mem, traceData);

        CmPopReg = Mem;;
        
        {
            RegVal final_val = CmPopReg;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

    Fault
    Cm_popretz64MicroInst::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t CmPopReg = 0;
uint64_t sp = 0;
uint64_t Mem = {};
;
        sp = xc->getRegOperand(this, 0);
;
        EA = rvSext(sp + offset);;

        {
            Fault fault =
                readMemAtomicLE(xc, traceData, EA, Mem, memAccessFlags);
            if (fault != NoFault)
                return fault;
        }

        CmPopReg = Mem;;

        
        {
            RegVal final_val = CmPopReg;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

    std::string
    Cm_popretz64MicroInst::generateDisassembly(
        Addr pc, const loader::SymbolTable *symtab) const
    {
        std::stringstream ss;
        ss << mnemonic << ' ' << registerName(destRegIdx(0)) << ", " <<
            offset << '(' << registerName(srcRegIdx(0)) << ')';
        return ss.str();
    }

    Fault
    Cm_popretz64MicroInst::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t sp = 0;
uint64_t Mem = {};
;
        sp = xc->getRegOperand(this, 0);
;
        EA = rvSext(sp + offset);;

        return initiateMemRead(xc, traceData, EA, Mem, memAccessFlags);
    }

    Fault
    Cm_popretz64MicroInst::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t CmPopReg = 0;
uint64_t Mem = {};
;
        ;

        getMemLE(pkt, Mem, traceData);

        CmPopReg = Mem;;
        
        {
            RegVal final_val = CmPopReg;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

    Fault
    Cm_popretzSpAdjMicroInst::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        uint64_t spd = 0;
uint64_t sp = 0;
;
        sp = xc->getRegOperand(this, 0);
;
        spd = rvSext(sp + adj);;
        
        {
            RegVal final_val = spd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    Cm_popretzSpAdjMicroInst::generateDisassembly(
        Addr pc, const loader::SymbolTable *symtab) const
    {
        std::stringstream ss;
        ss << mnemonic << ' ' << registerName(destRegIdx(0)) << ", "
            << registerName(srcRegIdx(0)) << ", " << adj;
        return ss.str();
    }

    Fault
    Cm_popretzMvMicroInst::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        uint64_t CmPopReg = 0;
uint64_t CmPushReg = 0;
;
        CmPushReg = xc->getRegOperand(this, 0);
;
        CmPopReg = CmPushReg;;
        
        {
            RegVal final_val = CmPopReg;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    Cm_popretzMvMicroInst::generateDisassembly(
        Addr pc, const loader::SymbolTable *symtab) const
    {
        std::stringstream ss;
        ss << mnemonic << ' ' << registerName(destRegIdx(0)) << ", "
            << registerName(srcRegIdx(0));
        return ss.str();
    }

    Fault
    Cm_popretzRetMicroInst::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        uint64_t ra = 0;
uint64_t NPC = 0;
RiscvISAInst::PCState __parserAutoPCState;
;
        set(__parserAutoPCState, xc->pcState());
ra = xc->getRegOperand(this, 0);
;
        NPC = rvSext(ra & (~0x1));;
        __parserAutoPCState.npc(NPC);
xc->pcState(__parserAutoPCState);
;
        return NoFault;
    }

    std::unique_ptr<PCStateBase>
    Cm_popretzRetMicroInst::branchTarget(ThreadContext *tc) const
    {
        PCStateBase *pc_ptr = tc->pcState().clone();
        pc_ptr->as<PCState>().set(rvSext(tc->getReg(srcRegIdx(0)) & ~0x1));
        return std::unique_ptr<PCStateBase>{pc_ptr};
    }

    std::string
    Cm_popretzRetMicroInst::generateDisassembly(
        Addr pc, const loader::SymbolTable *symtab) const
    {
        std::stringstream ss;
        ss << mnemonic << ' ' << registerName(srcRegIdx(0));
        return ss.str();
    }

// CmPop::cm_popret(([], {'is_ret': 'True'}))

    std::string
    Cm_popret::generateDisassembly(
        Addr pc, const loader::SymbolTable *symtab) const
    {
        std::stringstream ss;
        ss << mnemonic << ' ' << getRlistStr() << ", " << stackAdj();
        return ss.str();
    }

    Fault
    Cm_popret32MicroInst::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        Addr EA;

        int32_t CmPopReg = 0;
uint64_t sp = 0;
int32_t Mem = {};
;
        sp = xc->getRegOperand(this, 0);
;
        EA = rvSext(sp + offset);;

        {
            Fault fault =
                readMemAtomicLE(xc, traceData, EA, Mem, memAccessFlags);
            if (fault != NoFault)
                return fault;
        }

        CmPopReg = Mem;;

        
        {
            RegVal final_val = CmPopReg;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

    std::string
    Cm_popret32MicroInst::generateDisassembly(
        Addr pc, const loader::SymbolTable *symtab) const
    {
        std::stringstream ss;
        ss << mnemonic << ' ' << registerName(destRegIdx(0)) << ", " <<
            offset << '(' << registerName(srcRegIdx(0)) << ')';
        return ss.str();
    }

    Fault
    Cm_popret32MicroInst::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t sp = 0;
int32_t Mem = {};
;
        sp = xc->getRegOperand(this, 0);
;
        EA = rvSext(sp + offset);;

        return initiateMemRead(xc, traceData, EA, Mem, memAccessFlags);
    }

    Fault
    Cm_popret32MicroInst::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int32_t CmPopReg = 0;
int32_t Mem = {};
;
        ;

        getMemLE(pkt, Mem, traceData);

        CmPopReg = Mem;;
        
        {
            RegVal final_val = CmPopReg;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

    Fault
    Cm_popret64MicroInst::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t CmPopReg = 0;
uint64_t sp = 0;
uint64_t Mem = {};
;
        sp = xc->getRegOperand(this, 0);
;
        EA = rvSext(sp + offset);;

        {
            Fault fault =
                readMemAtomicLE(xc, traceData, EA, Mem, memAccessFlags);
            if (fault != NoFault)
                return fault;
        }

        CmPopReg = Mem;;

        
        {
            RegVal final_val = CmPopReg;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

    std::string
    Cm_popret64MicroInst::generateDisassembly(
        Addr pc, const loader::SymbolTable *symtab) const
    {
        std::stringstream ss;
        ss << mnemonic << ' ' << registerName(destRegIdx(0)) << ", " <<
            offset << '(' << registerName(srcRegIdx(0)) << ')';
        return ss.str();
    }

    Fault
    Cm_popret64MicroInst::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t sp = 0;
uint64_t Mem = {};
;
        sp = xc->getRegOperand(this, 0);
;
        EA = rvSext(sp + offset);;

        return initiateMemRead(xc, traceData, EA, Mem, memAccessFlags);
    }

    Fault
    Cm_popret64MicroInst::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t CmPopReg = 0;
uint64_t Mem = {};
;
        ;

        getMemLE(pkt, Mem, traceData);

        CmPopReg = Mem;;
        
        {
            RegVal final_val = CmPopReg;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

    Fault
    Cm_popretSpAdjMicroInst::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        uint64_t spd = 0;
uint64_t sp = 0;
;
        sp = xc->getRegOperand(this, 0);
;
        spd = rvSext(sp + adj);;
        
        {
            RegVal final_val = spd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    Cm_popretSpAdjMicroInst::generateDisassembly(
        Addr pc, const loader::SymbolTable *symtab) const
    {
        std::stringstream ss;
        ss << mnemonic << ' ' << registerName(destRegIdx(0)) << ", "
            << registerName(srcRegIdx(0)) << ", " << adj;
        return ss.str();
    }

    Fault
    Cm_popretRetMicroInst::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        uint64_t ra = 0;
uint64_t NPC = 0;
RiscvISAInst::PCState __parserAutoPCState;
;
        set(__parserAutoPCState, xc->pcState());
ra = xc->getRegOperand(this, 0);
;
        NPC = rvSext(ra & (~0x1));;
        __parserAutoPCState.npc(NPC);
xc->pcState(__parserAutoPCState);
;
        return NoFault;
    }

    std::unique_ptr<PCStateBase>
    Cm_popretRetMicroInst::branchTarget(ThreadContext *tc) const
    {
        PCStateBase *pc_ptr = tc->pcState().clone();
        pc_ptr->as<PCState>().set(rvSext(tc->getReg(srcRegIdx(0)) & ~0x1));
        return std::unique_ptr<PCStateBase>{pc_ptr};
    }

    std::string
    Cm_popretRetMicroInst::generateDisassembly(
        Addr pc, const loader::SymbolTable *symtab) const
    {
        std::stringstream ss;
        ss << mnemonic << ' ' << registerName(srcRegIdx(0));
        return ss.str();
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// CompressedStore::c_fsdsp(['\n                    offset = CIMM6<5:3> << 3 |\n                             CIMM6<2:0> << 6;\n                ', '\n                    STATUS status = xc->readMiscReg(MISCREG_STATUS);\n                    if (status.fs == FPUStatus::OFF)\n                        return std::make_shared<IllegalInstFault>("FPU is off",\n                                                                   machInst);\n\n                    Mem_ud = Fc2_bits;\n                ', '\n                    EA = rvSext(sp + offset);\n                '],{})

    Fault
    C_fsdsp::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t sp = 0;
uint64_t Fc2_bits = 0;
uint64_t Mem = {};
;
        sp = xc->getRegOperand(this, 0);
Fc2_bits = xc->getRegOperand(this, 1);
;
        
                    EA = rvSext(sp + offset);
                ;

        
                    STATUS status = xc->readMiscReg(MISCREG_STATUS);
                    if (status.fs == FPUStatus::OFF)
                        return std::make_shared<IllegalInstFault>("FPU is off",
                                                                   machInst);

                    Mem = Fc2_bits;
                ;

        {
            Fault fault =
                writeMemAtomicLE(xc, traceData, Mem, EA, memAccessFlags,
                        nullptr);
            if (fault != NoFault)
                return fault;
        }

        ;
        ;

        return NoFault;
    }

    Fault
    C_fsdsp::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t sp = 0;
uint64_t Fc2_bits = 0;
uint64_t Mem = {};
;
        sp = xc->getRegOperand(this, 0);
Fc2_bits = xc->getRegOperand(this, 1);
;
        
                    EA = rvSext(sp + offset);
                ;

        
                    STATUS status = xc->readMiscReg(MISCREG_STATUS);
                    if (status.fs == FPUStatus::OFF)
                        return std::make_shared<IllegalInstFault>("FPU is off",
                                                                   machInst);

                    Mem = Fc2_bits;
                ;

        {
            Fault fault = writeMemTimingLE(xc, traceData, Mem, EA,
                memAccessFlags, nullptr);
            if (fault != NoFault)
                return fault;
        }

        ;

        return NoFault;
    }

    Fault
    C_fsdsp::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        return NoFault;
    }

// Unknown::unknown(([], {}))

// CompressedStore::c_swsp(['\n                offset = CIMM6<5:2> << 2 |\n                         CIMM6<1:0> << 6;\n            ', '\n                Mem_uw = Rc2_uw;\n            ', '\n                EA = rvSext(sp + offset);\n            '],{})

    Fault
    C_swsp::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t sp = 0;
uint32_t Rc2 = 0;
uint32_t Mem = {};
;
        sp = xc->getRegOperand(this, 0);
Rc2 = xc->getRegOperand(this, 1);
;
        
                EA = rvSext(sp + offset);
            ;

        
                Mem = Rc2;
            ;

        {
            Fault fault =
                writeMemAtomicLE(xc, traceData, Mem, EA, memAccessFlags,
                        nullptr);
            if (fault != NoFault)
                return fault;
        }

        ;
        ;

        return NoFault;
    }

    Fault
    C_swsp::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t sp = 0;
uint32_t Rc2 = 0;
uint32_t Mem = {};
;
        sp = xc->getRegOperand(this, 0);
Rc2 = xc->getRegOperand(this, 1);
;
        
                EA = rvSext(sp + offset);
            ;

        
                Mem = Rc2;
            ;

        {
            Fault fault = writeMemTimingLE(xc, traceData, Mem, EA,
                memAccessFlags, nullptr);
            if (fault != NoFault)
                return fault;
        }

        ;

        return NoFault;
    }

    Fault
    C_swsp::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        return NoFault;
    }

// CompressedStore::c_fswsp(['\n                    offset = CIMM6<5:2> << 2 |\n                             CIMM6<1:0> << 6;\n                ', '\n                    STATUS status = xc->readMiscReg(MISCREG_STATUS);\n                    if (status.fs == FPUStatus::OFF)\n                        return std::make_shared<IllegalInstFault>("FPU is off",\n                                                                   machInst);\n\n                    Mem_uw = unboxF32(boxF32(Fc2_bits));\n                ', '\n                    EA = rvSext(sp_uw + offset);\n                '],{})

    Fault
    C_fswsp::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint32_t sp = 0;
uint64_t Fc2_bits = 0;
uint32_t Mem = {};
;
        sp = xc->getRegOperand(this, 0);
Fc2_bits = xc->getRegOperand(this, 1);
;
        
                    EA = rvSext(sp + offset);
                ;

        
                    STATUS status = xc->readMiscReg(MISCREG_STATUS);
                    if (status.fs == FPUStatus::OFF)
                        return std::make_shared<IllegalInstFault>("FPU is off",
                                                                   machInst);

                    Mem = unboxF32(boxF32(Fc2_bits));
                ;

        {
            Fault fault =
                writeMemAtomicLE(xc, traceData, Mem, EA, memAccessFlags,
                        nullptr);
            if (fault != NoFault)
                return fault;
        }

        ;
        ;

        return NoFault;
    }

    Fault
    C_fswsp::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint32_t sp = 0;
uint64_t Fc2_bits = 0;
uint32_t Mem = {};
;
        sp = xc->getRegOperand(this, 0);
Fc2_bits = xc->getRegOperand(this, 1);
;
        
                    EA = rvSext(sp + offset);
                ;

        
                    STATUS status = xc->readMiscReg(MISCREG_STATUS);
                    if (status.fs == FPUStatus::OFF)
                        return std::make_shared<IllegalInstFault>("FPU is off",
                                                                   machInst);

                    Mem = unboxF32(boxF32(Fc2_bits));
                ;

        {
            Fault fault = writeMemTimingLE(xc, traceData, Mem, EA,
                memAccessFlags, nullptr);
            if (fault != NoFault)
                return fault;
        }

        ;

        return NoFault;
    }

    Fault
    C_fswsp::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        return NoFault;
    }

// CompressedStore::c_sdsp(['\n                    offset = CIMM6<5:3> << 3 |\n                             CIMM6<2:0> << 6;\n                ', '\n                    Mem = Rc2;\n                ', '\n                    EA = sp + offset;\n                '],{})

    Fault
    C_sdsp::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t sp = 0;
uint64_t Rc2 = 0;
uint64_t Mem = {};
;
        sp = xc->getRegOperand(this, 0);
Rc2 = xc->getRegOperand(this, 1);
;
        
                    EA = sp + offset;
                ;

        
                    Mem = Rc2;
                ;

        {
            Fault fault =
                writeMemAtomicLE(xc, traceData, Mem, EA, memAccessFlags,
                        nullptr);
            if (fault != NoFault)
                return fault;
        }

        ;
        ;

        return NoFault;
    }

    Fault
    C_sdsp::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t sp = 0;
uint64_t Rc2 = 0;
uint64_t Mem = {};
;
        sp = xc->getRegOperand(this, 0);
Rc2 = xc->getRegOperand(this, 1);
;
        
                    EA = sp + offset;
                ;

        
                    Mem = Rc2;
                ;

        {
            Fault fault = writeMemTimingLE(xc, traceData, Mem, EA,
                memAccessFlags, nullptr);
            if (fault != NoFault)
                return fault;
        }

        ;

        return NoFault;
    }

    Fault
    C_sdsp::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        return NoFault;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Load::lb(['\n                    Rd_sd = Mem_sb;\n                '],{})

    Fault
    Lb::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        Addr EA;

        int64_t Rd = 0;
uint64_t Rs1 = 0;
int8_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
;
        EA = rvSext(Rs1 + offset);;

        {
            Fault fault =
                readMemAtomicLE(xc, traceData, EA, Mem, memAccessFlags);
            if (fault != NoFault)
                return fault;
        }

        
                    Rd = Mem;
                ;

        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

    Fault
    Lb::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
int8_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
;
        EA = rvSext(Rs1 + offset);;

        return initiateMemRead(xc, traceData, EA, Mem, memAccessFlags);
    }

    Fault
    Lb::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int8_t Mem = {};
;
        ;

        getMemLE(pkt, Mem, traceData);

        
                    Rd = Mem;
                ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// Load::lh(['\n                    Rd_sd = Mem_sh;\n                '],{})

    Fault
    Lh::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        Addr EA;

        int64_t Rd = 0;
uint64_t Rs1 = 0;
int16_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
;
        EA = rvSext(Rs1 + offset);;

        {
            Fault fault =
                readMemAtomicLE(xc, traceData, EA, Mem, memAccessFlags);
            if (fault != NoFault)
                return fault;
        }

        
                    Rd = Mem;
                ;

        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

    Fault
    Lh::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
int16_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
;
        EA = rvSext(Rs1 + offset);;

        return initiateMemRead(xc, traceData, EA, Mem, memAccessFlags);
    }

    Fault
    Lh::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int16_t Mem = {};
;
        ;

        getMemLE(pkt, Mem, traceData);

        
                    Rd = Mem;
                ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// Load::lw(['\n                    Rd_sd = Mem_sw;\n                '],{})

    Fault
    Lw::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        Addr EA;

        int64_t Rd = 0;
uint64_t Rs1 = 0;
int32_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
;
        EA = rvSext(Rs1 + offset);;

        {
            Fault fault =
                readMemAtomicLE(xc, traceData, EA, Mem, memAccessFlags);
            if (fault != NoFault)
                return fault;
        }

        
                    Rd = Mem;
                ;

        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

    Fault
    Lw::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
int32_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
;
        EA = rvSext(Rs1 + offset);;

        return initiateMemRead(xc, traceData, EA, Mem, memAccessFlags);
    }

    Fault
    Lw::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int32_t Mem = {};
;
        ;

        getMemLE(pkt, Mem, traceData);

        
                    Rd = Mem;
                ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// Load::ld(['\n                        Rd_sd = Mem_sd;\n                    '],{})

    Fault
    Ld::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        Addr EA;

        int64_t Rd = 0;
uint64_t Rs1 = 0;
int64_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
;
        EA = rvSext(Rs1 + offset);;

        {
            Fault fault =
                readMemAtomicLE(xc, traceData, EA, Mem, memAccessFlags);
            if (fault != NoFault)
                return fault;
        }

        
                        Rd = Mem;
                    ;

        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

    Fault
    Ld::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
int64_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
;
        EA = rvSext(Rs1 + offset);;

        return initiateMemRead(xc, traceData, EA, Mem, memAccessFlags);
    }

    Fault
    Ld::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int64_t Mem = {};
;
        ;

        getMemLE(pkt, Mem, traceData);

        
                        Rd = Mem;
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// Unknown::unknown(([], {}))

// Load::lbu(['\n                    Rd = Mem_ub;\n                '],{})

    Fault
    Lbu::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rd = 0;
uint64_t Rs1 = 0;
uint8_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
;
        EA = rvSext(Rs1 + offset);;

        {
            Fault fault =
                readMemAtomicLE(xc, traceData, EA, Mem, memAccessFlags);
            if (fault != NoFault)
                return fault;
        }

        
                    Rd = Mem;
                ;

        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

    Fault
    Lbu::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
uint8_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
;
        EA = rvSext(Rs1 + offset);;

        return initiateMemRead(xc, traceData, EA, Mem, memAccessFlags);
    }

    Fault
    Lbu::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint8_t Mem = {};
;
        ;

        getMemLE(pkt, Mem, traceData);

        
                    Rd = Mem;
                ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// Load::lhu(['\n                    Rd = Mem_uh;\n                '],{})

    Fault
    Lhu::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rd = 0;
uint64_t Rs1 = 0;
uint16_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
;
        EA = rvSext(Rs1 + offset);;

        {
            Fault fault =
                readMemAtomicLE(xc, traceData, EA, Mem, memAccessFlags);
            if (fault != NoFault)
                return fault;
        }

        
                    Rd = Mem;
                ;

        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

    Fault
    Lhu::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
uint16_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
;
        EA = rvSext(Rs1 + offset);;

        return initiateMemRead(xc, traceData, EA, Mem, memAccessFlags);
    }

    Fault
    Lhu::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint16_t Mem = {};
;
        ;

        getMemLE(pkt, Mem, traceData);

        
                    Rd = Mem;
                ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// Load::lwu(['\n                        Rd = Mem_uw;\n                    '],{})

    Fault
    Lwu::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rd = 0;
uint64_t Rs1 = 0;
uint32_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
;
        EA = rvSext(Rs1 + offset);;

        {
            Fault fault =
                readMemAtomicLE(xc, traceData, EA, Mem, memAccessFlags);
            if (fault != NoFault)
                return fault;
        }

        
                        Rd = Mem;
                    ;

        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

    Fault
    Lwu::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
uint32_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
;
        EA = rvSext(Rs1 + offset);;

        return initiateMemRead(xc, traceData, EA, Mem, memAccessFlags);
    }

    Fault
    Lwu::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint32_t Mem = {};
;
        ;

        getMemLE(pkt, Mem, traceData);

        
                        Rd = Mem;
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Load::flh(['\n                    STATUS status = xc->readMiscReg(MISCREG_STATUS);\n                    if (status.fs == FPUStatus::OFF)\n                        return std::make_shared<IllegalInstFault>(\n                                    "FPU is off", machInst);\n\n                    status.fs = FPUStatus::DIRTY;\n                    xc->setMiscReg(MISCREG_STATUS, status);\n\n                    freg_t fd;\n                    fd = freg(f16(Mem_uh));\n                    Fd_bits = fd.v;\n                '],{'inst_flags': 'FloatMemReadOp'})

    Fault
    Flh::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Fd_bits = 0;
uint64_t Rs1 = 0;
uint16_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
;
        EA = rvSext(Rs1 + offset);;

        {
            Fault fault =
                readMemAtomicLE(xc, traceData, EA, Mem, memAccessFlags);
            if (fault != NoFault)
                return fault;
        }

        
                    STATUS status = xc->readMiscReg(MISCREG_STATUS);
                    if (status.fs == FPUStatus::OFF)
                        return std::make_shared<IllegalInstFault>(
                                    "FPU is off", machInst);

                    status.fs = FPUStatus::DIRTY;
                    xc->setMiscReg(MISCREG_STATUS, status);

                    freg_t fd;
                    fd = freg(f16(Mem));
                    Fd_bits = fd.v;
                ;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

    Fault
    Flh::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
uint16_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
;
        EA = rvSext(Rs1 + offset);;

        return initiateMemRead(xc, traceData, EA, Mem, memAccessFlags);
    }

    Fault
    Flh::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Fd_bits = 0;
uint16_t Mem = {};
;
        ;

        getMemLE(pkt, Mem, traceData);

        
                    STATUS status = xc->readMiscReg(MISCREG_STATUS);
                    if (status.fs == FPUStatus::OFF)
                        return std::make_shared<IllegalInstFault>(
                                    "FPU is off", machInst);

                    status.fs = FPUStatus::DIRTY;
                    xc->setMiscReg(MISCREG_STATUS, status);

                    freg_t fd;
                    fd = freg(f16(Mem));
                    Fd_bits = fd.v;
                ;
        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// Load::flw(['\n                    STATUS status = xc->readMiscReg(MISCREG_STATUS);\n                    if (status.fs == FPUStatus::OFF)\n                        return std::make_shared<IllegalInstFault>(\n                                    "FPU is off", machInst);\n\n                    status.fs = FPUStatus::DIRTY;\n                    xc->setMiscReg(MISCREG_STATUS, status);\n\n                    freg_t fd;\n                    fd = freg(f32(Mem_uw));\n                    Fd_bits = fd.v;\n                '],{'inst_flags': 'FloatMemReadOp'})

    Fault
    Flw::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Fd_bits = 0;
uint64_t Rs1 = 0;
uint32_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
;
        EA = rvSext(Rs1 + offset);;

        {
            Fault fault =
                readMemAtomicLE(xc, traceData, EA, Mem, memAccessFlags);
            if (fault != NoFault)
                return fault;
        }

        
                    STATUS status = xc->readMiscReg(MISCREG_STATUS);
                    if (status.fs == FPUStatus::OFF)
                        return std::make_shared<IllegalInstFault>(
                                    "FPU is off", machInst);

                    status.fs = FPUStatus::DIRTY;
                    xc->setMiscReg(MISCREG_STATUS, status);

                    freg_t fd;
                    fd = freg(f32(Mem));
                    Fd_bits = fd.v;
                ;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

    Fault
    Flw::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
uint32_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
;
        EA = rvSext(Rs1 + offset);;

        return initiateMemRead(xc, traceData, EA, Mem, memAccessFlags);
    }

    Fault
    Flw::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Fd_bits = 0;
uint32_t Mem = {};
;
        ;

        getMemLE(pkt, Mem, traceData);

        
                    STATUS status = xc->readMiscReg(MISCREG_STATUS);
                    if (status.fs == FPUStatus::OFF)
                        return std::make_shared<IllegalInstFault>(
                                    "FPU is off", machInst);

                    status.fs = FPUStatus::DIRTY;
                    xc->setMiscReg(MISCREG_STATUS, status);

                    freg_t fd;
                    fd = freg(f32(Mem));
                    Fd_bits = fd.v;
                ;
        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// Load::fld(['\n                    STATUS status = xc->readMiscReg(MISCREG_STATUS);\n                    if (status.fs == FPUStatus::OFF)\n                        return std::make_shared<IllegalInstFault>(\n                                    "FPU is off", machInst);\n\n                    status.fs = FPUStatus::DIRTY;\n                    xc->setMiscReg(MISCREG_STATUS, status);\n\n                    freg_t fd;\n                    fd = freg(f64(Mem));\n                    Fd_bits = fd.v;\n                '],{'inst_flags': 'FloatMemReadOp'})

    Fault
    Fld::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Fd_bits = 0;
uint64_t Rs1 = 0;
uint64_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
;
        EA = rvSext(Rs1 + offset);;

        {
            Fault fault =
                readMemAtomicLE(xc, traceData, EA, Mem, memAccessFlags);
            if (fault != NoFault)
                return fault;
        }

        
                    STATUS status = xc->readMiscReg(MISCREG_STATUS);
                    if (status.fs == FPUStatus::OFF)
                        return std::make_shared<IllegalInstFault>(
                                    "FPU is off", machInst);

                    status.fs = FPUStatus::DIRTY;
                    xc->setMiscReg(MISCREG_STATUS, status);

                    freg_t fd;
                    fd = freg(f64(Mem));
                    Fd_bits = fd.v;
                ;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

    Fault
    Fld::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
uint64_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
;
        EA = rvSext(Rs1 + offset);;

        return initiateMemRead(xc, traceData, EA, Mem, memAccessFlags);
    }

    Fault
    Fld::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Fd_bits = 0;
uint64_t Mem = {};
;
        ;

        getMemLE(pkt, Mem, traceData);

        
                    STATUS status = xc->readMiscReg(MISCREG_STATUS);
                    if (status.fs == FPUStatus::OFF)
                        return std::make_shared<IllegalInstFault>(
                                    "FPU is off", machInst);

                    status.fs = FPUStatus::DIRTY;
                    xc->setMiscReg(MISCREG_STATUS, status);

                    freg_t fd;
                    fd = freg(f64(Mem));
                    Fd_bits = fd.v;
                ;
        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// VleOp::vle8_v((['\n                            if ((machInst.vm || elem_mask(v0, ei)) &&\n                                i < this->microVl) {\n                                Vd_ub[i] = Mem_vc.as<uint8_t>()[i];\n                            }\n                        '], {'inst_flags': 'SimdUnitStrideLoadOp'}))


Fault
Vle8_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);

    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint32_t mem_size = width_EEW(machInst.width) / 8 * this->microVl;

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = xc->readMem(EA, Mem.as<uint8_t>(), mem_size, memAccessFlags,
                              byte_enable);

    ;

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    if (fault != NoFault)
        return fault;

    size_t ei;

    for (size_t i = 0; i < micro_vlmax; i++) {
        ei = i + micro_vlmax * microIdx;
        
                            if ((machInst.vm || elem_mask(v0, ei)) &&
                                i < this->microVl) {
                                Vd[i] = Mem.as<uint8_t>()[i];
                            }
                        ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return fault;
}



Fault
Vle8_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;

    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    uint32_t mem_size = width_EEW(this->machInst.width) / 8 * this->microVl;

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = initiateMemRead(xc, EA, mem_size, memAccessFlags,
                                  byte_enable);

    ;

    return fault;
}



Fault
Vle8_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    // tail/mask policy: both undisturbed if one is, 1s if none
    
    if (!machInst.vtype8.vta || (!machInst.vm && !machInst.vtype8.vma)) {
        RiscvISA::vreg_t old_vd;
        xc->getRegOperand(this, 1, &old_vd);
        tmp_d0 = old_vd;
    } else {
        tmp_d0.set(0xff);
    }
    

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    if (xc->readMemAccPredicate()) {
        memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());
    }

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    size_t ei;
    for (size_t i = 0; i < micro_vlmax; i++) {
        ei = i + micro_vlmax * microIdx;
        
                            if ((machInst.vm || elem_mask(v0, ei)) &&
                                i < this->microVl) {
                                Vd[i] = Mem.as<uint8_t>()[i];
                            }
                        ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// VlSegOp::vlseg2e8_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 2)) &&\n                                    i < this->microVl) {\n                                    Vd_ub[i] = Mem_vc.as<uint8_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


Fault
Vlseg2e8_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    uint32_t mem_size = width_EEW(machInst.width) / 8 * microVl;

    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);

    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = xc->readMem(EA, Mem.as<uint8_t>(), mem_size, memAccessFlags,
                              byte_enable);

    if (fault != NoFault)
        return fault;

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;

    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 2)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint8_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return fault;
}



Fault
Vlseg2e8_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;
    uint32_t mem_size = width_EEW(this->machInst.width) / 8 * this->microVl;

    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = initiateMemRead(xc, EA, mem_size, memAccessFlags,
                                  byte_enable);
    return fault;
}



Fault
Vlseg2e8_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    // tail/mask policy: both undisturbed if one is, 1s if none
    
    if (!machInst.vtype8.vta || (!machInst.vm && !machInst.vtype8.vma)) {
        RiscvISA::vreg_t old_vd;
        xc->getRegOperand(this, 1, &old_vd);
        tmp_d0 = old_vd;
    } else {
        tmp_d0.set(0xff);
    }
    

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;
    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 2)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint8_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// VlSegOp::vlseg3e8_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 3)) &&\n                                    i < this->microVl) {\n                                    Vd_ub[i] = Mem_vc.as<uint8_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


Fault
Vlseg3e8_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    uint32_t mem_size = width_EEW(machInst.width) / 8 * microVl;

    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);

    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = xc->readMem(EA, Mem.as<uint8_t>(), mem_size, memAccessFlags,
                              byte_enable);

    if (fault != NoFault)
        return fault;

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;

    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 3)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint8_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return fault;
}



Fault
Vlseg3e8_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;
    uint32_t mem_size = width_EEW(this->machInst.width) / 8 * this->microVl;

    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = initiateMemRead(xc, EA, mem_size, memAccessFlags,
                                  byte_enable);
    return fault;
}



Fault
Vlseg3e8_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    // tail/mask policy: both undisturbed if one is, 1s if none
    
    if (!machInst.vtype8.vta || (!machInst.vm && !machInst.vtype8.vma)) {
        RiscvISA::vreg_t old_vd;
        xc->getRegOperand(this, 1, &old_vd);
        tmp_d0 = old_vd;
    } else {
        tmp_d0.set(0xff);
    }
    

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;
    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 3)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint8_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// VlSegOp::vlseg4e8_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 4)) &&\n                                    i < this->microVl) {\n                                    Vd_ub[i] = Mem_vc.as<uint8_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


Fault
Vlseg4e8_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    uint32_t mem_size = width_EEW(machInst.width) / 8 * microVl;

    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);

    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = xc->readMem(EA, Mem.as<uint8_t>(), mem_size, memAccessFlags,
                              byte_enable);

    if (fault != NoFault)
        return fault;

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;

    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 4)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint8_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return fault;
}



Fault
Vlseg4e8_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;
    uint32_t mem_size = width_EEW(this->machInst.width) / 8 * this->microVl;

    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = initiateMemRead(xc, EA, mem_size, memAccessFlags,
                                  byte_enable);
    return fault;
}



Fault
Vlseg4e8_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    // tail/mask policy: both undisturbed if one is, 1s if none
    
    if (!machInst.vtype8.vta || (!machInst.vm && !machInst.vtype8.vma)) {
        RiscvISA::vreg_t old_vd;
        xc->getRegOperand(this, 1, &old_vd);
        tmp_d0 = old_vd;
    } else {
        tmp_d0.set(0xff);
    }
    

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;
    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 4)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint8_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// VlSegOp::vlseg5e8_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 5)) &&\n                                    i < this->microVl) {\n                                    Vd_ub[i] = Mem_vc.as<uint8_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


Fault
Vlseg5e8_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    uint32_t mem_size = width_EEW(machInst.width) / 8 * microVl;

    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);

    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = xc->readMem(EA, Mem.as<uint8_t>(), mem_size, memAccessFlags,
                              byte_enable);

    if (fault != NoFault)
        return fault;

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;

    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 5)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint8_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return fault;
}



Fault
Vlseg5e8_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;
    uint32_t mem_size = width_EEW(this->machInst.width) / 8 * this->microVl;

    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = initiateMemRead(xc, EA, mem_size, memAccessFlags,
                                  byte_enable);
    return fault;
}



Fault
Vlseg5e8_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    // tail/mask policy: both undisturbed if one is, 1s if none
    
    if (!machInst.vtype8.vta || (!machInst.vm && !machInst.vtype8.vma)) {
        RiscvISA::vreg_t old_vd;
        xc->getRegOperand(this, 1, &old_vd);
        tmp_d0 = old_vd;
    } else {
        tmp_d0.set(0xff);
    }
    

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;
    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 5)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint8_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// VlSegOp::vlseg6e8_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 6)) &&\n                                    i < this->microVl) {\n                                    Vd_ub[i] = Mem_vc.as<uint8_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


Fault
Vlseg6e8_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    uint32_t mem_size = width_EEW(machInst.width) / 8 * microVl;

    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);

    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = xc->readMem(EA, Mem.as<uint8_t>(), mem_size, memAccessFlags,
                              byte_enable);

    if (fault != NoFault)
        return fault;

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;

    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 6)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint8_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return fault;
}



Fault
Vlseg6e8_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;
    uint32_t mem_size = width_EEW(this->machInst.width) / 8 * this->microVl;

    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = initiateMemRead(xc, EA, mem_size, memAccessFlags,
                                  byte_enable);
    return fault;
}



Fault
Vlseg6e8_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    // tail/mask policy: both undisturbed if one is, 1s if none
    
    if (!machInst.vtype8.vta || (!machInst.vm && !machInst.vtype8.vma)) {
        RiscvISA::vreg_t old_vd;
        xc->getRegOperand(this, 1, &old_vd);
        tmp_d0 = old_vd;
    } else {
        tmp_d0.set(0xff);
    }
    

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;
    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 6)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint8_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// VlSegOp::vlseg7e8_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 7)) &&\n                                    i < this->microVl) {\n                                    Vd_ub[i] = Mem_vc.as<uint8_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


Fault
Vlseg7e8_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    uint32_t mem_size = width_EEW(machInst.width) / 8 * microVl;

    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);

    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = xc->readMem(EA, Mem.as<uint8_t>(), mem_size, memAccessFlags,
                              byte_enable);

    if (fault != NoFault)
        return fault;

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;

    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 7)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint8_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return fault;
}



Fault
Vlseg7e8_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;
    uint32_t mem_size = width_EEW(this->machInst.width) / 8 * this->microVl;

    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = initiateMemRead(xc, EA, mem_size, memAccessFlags,
                                  byte_enable);
    return fault;
}



Fault
Vlseg7e8_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    // tail/mask policy: both undisturbed if one is, 1s if none
    
    if (!machInst.vtype8.vta || (!machInst.vm && !machInst.vtype8.vma)) {
        RiscvISA::vreg_t old_vd;
        xc->getRegOperand(this, 1, &old_vd);
        tmp_d0 = old_vd;
    } else {
        tmp_d0.set(0xff);
    }
    

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;
    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 7)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint8_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// VlSegOp::vlseg8e8_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 8)) &&\n                                    i < this->microVl) {\n                                    Vd_ub[i] = Mem_vc.as<uint8_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


Fault
Vlseg8e8_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    uint32_t mem_size = width_EEW(machInst.width) / 8 * microVl;

    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);

    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = xc->readMem(EA, Mem.as<uint8_t>(), mem_size, memAccessFlags,
                              byte_enable);

    if (fault != NoFault)
        return fault;

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;

    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 8)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint8_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return fault;
}



Fault
Vlseg8e8_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;
    uint32_t mem_size = width_EEW(this->machInst.width) / 8 * this->microVl;

    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = initiateMemRead(xc, EA, mem_size, memAccessFlags,
                                  byte_enable);
    return fault;
}



Fault
Vlseg8e8_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    // tail/mask policy: both undisturbed if one is, 1s if none
    
    if (!machInst.vtype8.vta || (!machInst.vm && !machInst.vtype8.vma)) {
        RiscvISA::vreg_t old_vd;
        xc->getRegOperand(this, 1, &old_vd);
        tmp_d0 = old_vd;
    } else {
        tmp_d0.set(0xff);
    }
    

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;
    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 8)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint8_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// Unknown::unknown(([], {}))

// VlWholeOp::vl1re8_v(['\n                                Vd_ub[i] = Mem_vc.as<uint8_t>()[i];\n                            '],{'inst_flags': 'SimdWholeRegisterLoadOp'})


Fault
Vl1re8_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    Fault fault = readMemAtomicLE(xc, traceData, EA,
                            *(vreg_t::Container*)(&Mem), vlenb,
                            memAccessFlags);
    if (fault != NoFault)
        return fault;

    size_t elem_per_reg = vlen / width_EEW(machInst.width);
    for (size_t i = 0; i < elem_per_reg; i++) {
        
                                Vd[i] = Mem.as<uint8_t>()[i];
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}



Fault
Vl1re8_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    const std::vector<bool> byte_enable(vlenb, true);
    Fault fault = initiateMemRead(xc, EA, vlenb, memAccessFlags, byte_enable);
    return fault;
}



Fault
Vl1re8_vMicro::completeAcc(PacketPtr pkt, ExecContext* xc,
        trace::InstRecord* traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());

    size_t elem_per_reg = vlen / width_EEW(machInst.width);
    for (size_t i = 0; i < elem_per_reg; ++i) {
        
                                Vd[i] = Mem.as<uint8_t>()[i];
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// VlWholeOp::vl2re8_v(['\n                                Vd_ub[i] = Mem_vc.as<uint8_t>()[i];\n                            '],{'inst_flags': 'SimdWholeRegisterLoadOp'})


Fault
Vl2re8_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    Fault fault = readMemAtomicLE(xc, traceData, EA,
                            *(vreg_t::Container*)(&Mem), vlenb,
                            memAccessFlags);
    if (fault != NoFault)
        return fault;

    size_t elem_per_reg = vlen / width_EEW(machInst.width);
    for (size_t i = 0; i < elem_per_reg; i++) {
        
                                Vd[i] = Mem.as<uint8_t>()[i];
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}



Fault
Vl2re8_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    const std::vector<bool> byte_enable(vlenb, true);
    Fault fault = initiateMemRead(xc, EA, vlenb, memAccessFlags, byte_enable);
    return fault;
}



Fault
Vl2re8_vMicro::completeAcc(PacketPtr pkt, ExecContext* xc,
        trace::InstRecord* traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());

    size_t elem_per_reg = vlen / width_EEW(machInst.width);
    for (size_t i = 0; i < elem_per_reg; ++i) {
        
                                Vd[i] = Mem.as<uint8_t>()[i];
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// VlWholeOp::vl4re8_v(['\n                                Vd_ub[i] = Mem_vc.as<uint8_t>()[i];\n                            '],{'inst_flags': 'SimdWholeRegisterLoadOp'})


Fault
Vl4re8_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    Fault fault = readMemAtomicLE(xc, traceData, EA,
                            *(vreg_t::Container*)(&Mem), vlenb,
                            memAccessFlags);
    if (fault != NoFault)
        return fault;

    size_t elem_per_reg = vlen / width_EEW(machInst.width);
    for (size_t i = 0; i < elem_per_reg; i++) {
        
                                Vd[i] = Mem.as<uint8_t>()[i];
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}



Fault
Vl4re8_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    const std::vector<bool> byte_enable(vlenb, true);
    Fault fault = initiateMemRead(xc, EA, vlenb, memAccessFlags, byte_enable);
    return fault;
}



Fault
Vl4re8_vMicro::completeAcc(PacketPtr pkt, ExecContext* xc,
        trace::InstRecord* traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());

    size_t elem_per_reg = vlen / width_EEW(machInst.width);
    for (size_t i = 0; i < elem_per_reg; ++i) {
        
                                Vd[i] = Mem.as<uint8_t>()[i];
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// VlWholeOp::vl8re8_v(['\n                                Vd_ub[i] = Mem_vc.as<uint8_t>()[i];\n                            '],{'inst_flags': 'SimdWholeRegisterLoadOp'})


Fault
Vl8re8_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    Fault fault = readMemAtomicLE(xc, traceData, EA,
                            *(vreg_t::Container*)(&Mem), vlenb,
                            memAccessFlags);
    if (fault != NoFault)
        return fault;

    size_t elem_per_reg = vlen / width_EEW(machInst.width);
    for (size_t i = 0; i < elem_per_reg; i++) {
        
                                Vd[i] = Mem.as<uint8_t>()[i];
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}



Fault
Vl8re8_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    const std::vector<bool> byte_enable(vlenb, true);
    Fault fault = initiateMemRead(xc, EA, vlenb, memAccessFlags, byte_enable);
    return fault;
}



Fault
Vl8re8_vMicro::completeAcc(PacketPtr pkt, ExecContext* xc,
        trace::InstRecord* traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());

    size_t elem_per_reg = vlen / width_EEW(machInst.width);
    for (size_t i = 0; i < elem_per_reg; ++i) {
        
                                Vd[i] = Mem.as<uint8_t>()[i];
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// Unknown::unknown(([], {}))

// VlmOp::vlm_v((['\n                        Vd_ub[i] = Mem_vc.as<uint8_t>()[i];\n                    '], {'inst_flags': 'SimdUnitStrideMaskLoadOp'}))

// VleOp::vle8ff_v((['\n                        if ((machInst.vm || elem_mask(v0, ei)) &&\n                            i < this->microVl && i < this->faultIdx) {\n                            Vd_ub[i] = Mem_vc.as<uint8_t>()[i];\n                        }\n                    '], {'inst_flags': 'SimdUnitStrideFaultOnlyFirstLoadOp'}))


Fault
Vle8ff_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);

    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint32_t mem_size = width_EEW(machInst.width) / 8 * this->microVl;

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = xc->readMem(EA, Mem.as<uint8_t>(), mem_size, memAccessFlags,
                              byte_enable);

    
    Addr fault_addr;
    if (fault != NoFault && getFaultVAddr(fault, fault_addr)) {
        assert(fault_addr >= EA);
        faultIdx = (fault_addr - EA) / (width_EEW(machInst.width) / 8);
        if (microIdx != 0 || faultIdx != 0) {
            fault = NoFault;
            trimVl = true;
        }
    }
    ;

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    if (fault != NoFault)
        return fault;

    size_t ei;

    for (size_t i = 0; i < micro_vlmax; i++) {
        ei = i + micro_vlmax * microIdx;
        
                        if ((machInst.vm || elem_mask(v0, ei)) &&
                            i < this->microVl && i < this->faultIdx) {
                            Vd[i] = Mem.as<uint8_t>()[i];
                        }
                    ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return fault;
}



Fault
Vle8ff_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;

    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    uint32_t mem_size = width_EEW(this->machInst.width) / 8 * this->microVl;

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = initiateMemRead(xc, EA, mem_size, memAccessFlags,
                                  byte_enable);

    
    Addr fault_addr;
    if (fault != NoFault && getFaultVAddr(fault, fault_addr)) {
        assert(fault_addr >= EA);
        faultIdx = (fault_addr - EA) / (width_EEW(machInst.width) / 8);
        if (microIdx != 0 || faultIdx != 0) {
            fault = NoFault;
            trimVl = true;
        }
    }
    ;

    return fault;
}



Fault
Vle8ff_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    // tail/mask policy: both undisturbed if one is, 1s if none
    
    if (!machInst.vtype8.vta || (!machInst.vm && !machInst.vtype8.vma)) {
        RiscvISA::vreg_t old_vd;
        xc->getRegOperand(this, 1, &old_vd);
        tmp_d0 = old_vd;
    } else {
        tmp_d0.set(0xff);
    }
    

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    if (xc->readMemAccPredicate()) {
        memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());
    }

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    size_t ei;
    for (size_t i = 0; i < micro_vlmax; i++) {
        ei = i + micro_vlmax * microIdx;
        
                        if ((machInst.vm || elem_mask(v0, ei)) &&
                            i < this->microVl && i < this->faultIdx) {
                            Vd[i] = Mem.as<uint8_t>()[i];
                        }
                    ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// Unknown::unknown(([], {}))

// VlIndexOp::vluxei8_v((['\n                    Vd_vu[vdElemIdx] = Mem_vc.as<vu>()[0];\n                ', '\n                    EA = Rs1 + Vs2_ub[vs2ElemIdx];\n                '], {'inst_flags': 'SimdIndexedLoadOp'}))


template<typename ElemType>
Fault
Vluxei8_vMicro<ElemType>::execute(ExecContext *xc,
    trace::InstRecord *traceData)const
{
    using vu = std::make_unsigned_t<ElemType>;
    Fault fault = NoFault;
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    uint64_t Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<uint8_t>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
                    EA = Rs1 + Vs2[vs2ElemIdx];
                ;
    constexpr uint8_t elem_size = sizeof(Vd[0]);
    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint32_t mem_size = elem_size;
    const std::vector<bool> byte_enable(mem_size, true);
    size_t ei = this->vdRegIdx * vlenb / elem_size + this->vdElemIdx;
    if (machInst.vm || elem_mask(v0, ei)) {
        fault = xc->readMem(EA, Mem.as<uint8_t>(), mem_size,
                                memAccessFlags, byte_enable);
        if (fault != NoFault)
            return fault;
        
                    Vd[vdElemIdx] = Mem.as<vu>()[0];
                ; /* Vd[this->vdElemIdx] = Mem[0]; */
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return fault;
}



template<typename ElemType>
Fault
Vluxei8_vMicro<ElemType>::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    using vu = std::make_unsigned_t<ElemType>;
    Fault fault = NoFault;
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    uint64_t Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<uint8_t>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    constexpr uint8_t elem_size = sizeof(Vd[0]);
    
                    EA = Rs1 + Vs2[vs2ElemIdx];
                ; // ea_code depends on elem_size

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint32_t mem_size = elem_size;

    size_t ei = this->vdRegIdx * vlenb / elem_size + this->vdElemIdx;
    bool need_load = machInst.vm || elem_mask(v0, ei);
    const std::vector<bool> byte_enable(mem_size, need_load);
    fault = initiateMemRead(xc, EA, mem_size, memAccessFlags, byte_enable);
    return fault;
}



template<typename ElemType>
Fault
Vluxei8_vMicro<ElemType>::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    using vu = std::make_unsigned_t<ElemType>;
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    constexpr uint8_t elem_size = sizeof(Vd[0]);

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    size_t ei = this->vdRegIdx * vlenb / elem_size + this->vdElemIdx;
    if (machInst.vm || elem_mask(v0, ei)) {
        memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());
        
                    Vd[vdElemIdx] = Mem.as<vu>()[0];
                ; /* Vd[this->microIdx] = Mem[0]; */
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


    template class Vluxei8_vMicro<uint8_t>;
    template class Vluxei8_vMicro<uint16_t>;
    template class Vluxei8_vMicro<uint32_t>;
    template class Vluxei8_vMicro<uint64_t>;
    ;


// VlStrideOp::vlse8_v((['\n                    Vd_ub[microIdx] = Mem_vc.as<uint8_t>()[0];\n                '], {'inst_flags': 'SimdStridedLoadOp'}))


Fault
Vlse8_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Fault fault = NoFault;
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    constexpr uint8_t elem_size = sizeof(Vd[0]);
    
        EA = Rs1 + Rs2 * (regIdx * vlenb / elem_size + microIdx);
    ; // ea_code depends on elem_size

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint32_t mem_size = elem_size;
    const std::vector<bool> byte_enable(mem_size, true);

    size_t ei = this->regIdx * vlenb / elem_size + this->microIdx;
    if (machInst.vm || elem_mask(v0, ei)) {
        fault = xc->readMem(EA, Mem.as<uint8_t>(), mem_size,
                                memAccessFlags, byte_enable);
        if (fault != NoFault)
            return fault;
        
                    Vd[microIdx] = Mem.as<uint8_t>()[0];
                ; /* Vd[this->microIdx] = Mem[0]; */
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return fault;
}



Fault
Vlse8_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    Fault fault = NoFault;
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    constexpr uint8_t elem_size = sizeof(Vd[0]);
    
        EA = Rs1 + Rs2 * (regIdx * vlenb / elem_size + microIdx);
    ; // ea_code depends on elem_size

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint32_t mem_size = elem_size;
    size_t ei = this->regIdx * vlenb / elem_size + this->microIdx;
    bool need_load = machInst.vm || elem_mask(v0, ei);
    const std::vector<bool> byte_enable(mem_size, need_load);
    fault = initiateMemRead(xc, EA, mem_size, memAccessFlags, byte_enable);
    return fault;
}



Fault
Vlse8_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    size_t ei = this->regIdx * vlenb / sizeof(Vd[0]) + this->microIdx;
    if (machInst.vm || elem_mask(v0, ei)) {
        memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());
        
                    Vd[microIdx] = Mem.as<uint8_t>()[0];
                ; /* Vd[this->microIdx] = Mem[0]; */
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// VlIndexOp::vloxei8_v((['\n                    Vd_vu[vdElemIdx] = Mem_vc.as<vu>()[0];\n                ', '\n                    EA = Rs1 + Vs2_ub[vs2ElemIdx];\n                '], {'inst_flags': 'SimdIndexedLoadOp'}))


template<typename ElemType>
Fault
Vloxei8_vMicro<ElemType>::execute(ExecContext *xc,
    trace::InstRecord *traceData)const
{
    using vu = std::make_unsigned_t<ElemType>;
    Fault fault = NoFault;
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    uint64_t Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<uint8_t>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
                    EA = Rs1 + Vs2[vs2ElemIdx];
                ;
    constexpr uint8_t elem_size = sizeof(Vd[0]);
    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint32_t mem_size = elem_size;
    const std::vector<bool> byte_enable(mem_size, true);
    size_t ei = this->vdRegIdx * vlenb / elem_size + this->vdElemIdx;
    if (machInst.vm || elem_mask(v0, ei)) {
        fault = xc->readMem(EA, Mem.as<uint8_t>(), mem_size,
                                memAccessFlags, byte_enable);
        if (fault != NoFault)
            return fault;
        
                    Vd[vdElemIdx] = Mem.as<vu>()[0];
                ; /* Vd[this->vdElemIdx] = Mem[0]; */
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return fault;
}



template<typename ElemType>
Fault
Vloxei8_vMicro<ElemType>::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    using vu = std::make_unsigned_t<ElemType>;
    Fault fault = NoFault;
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    uint64_t Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<uint8_t>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    constexpr uint8_t elem_size = sizeof(Vd[0]);
    
                    EA = Rs1 + Vs2[vs2ElemIdx];
                ; // ea_code depends on elem_size

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint32_t mem_size = elem_size;

    size_t ei = this->vdRegIdx * vlenb / elem_size + this->vdElemIdx;
    bool need_load = machInst.vm || elem_mask(v0, ei);
    const std::vector<bool> byte_enable(mem_size, need_load);
    fault = initiateMemRead(xc, EA, mem_size, memAccessFlags, byte_enable);
    return fault;
}



template<typename ElemType>
Fault
Vloxei8_vMicro<ElemType>::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    using vu = std::make_unsigned_t<ElemType>;
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    constexpr uint8_t elem_size = sizeof(Vd[0]);

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    size_t ei = this->vdRegIdx * vlenb / elem_size + this->vdElemIdx;
    if (machInst.vm || elem_mask(v0, ei)) {
        memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());
        
                    Vd[vdElemIdx] = Mem.as<vu>()[0];
                ; /* Vd[this->microIdx] = Mem[0]; */
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


    template class Vloxei8_vMicro<uint8_t>;
    template class Vloxei8_vMicro<uint16_t>;
    template class Vloxei8_vMicro<uint32_t>;
    template class Vloxei8_vMicro<uint64_t>;
    ;


// Unknown::unknown(([], {}))

// VleOp::vle16_v((['\n                            if ((machInst.vm || elem_mask(v0, ei)) &&\n                                i < this->microVl) {\n                                Vd_uh[i] = Mem_vc.as<uint16_t>()[i];\n                            }\n                        '], {'inst_flags': 'SimdUnitStrideLoadOp'}))


Fault
Vle16_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint16_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);

    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint32_t mem_size = width_EEW(machInst.width) / 8 * this->microVl;

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = xc->readMem(EA, Mem.as<uint8_t>(), mem_size, memAccessFlags,
                              byte_enable);

    ;

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    if (fault != NoFault)
        return fault;

    size_t ei;

    for (size_t i = 0; i < micro_vlmax; i++) {
        ei = i + micro_vlmax * microIdx;
        
                            if ((machInst.vm || elem_mask(v0, ei)) &&
                                i < this->microVl) {
                                Vd[i] = Mem.as<uint16_t>()[i];
                            }
                        ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return fault;
}



Fault
Vle16_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;

    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    uint32_t mem_size = width_EEW(this->machInst.width) / 8 * this->microVl;

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = initiateMemRead(xc, EA, mem_size, memAccessFlags,
                                  byte_enable);

    ;

    return fault;
}



Fault
Vle16_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint16_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    // tail/mask policy: both undisturbed if one is, 1s if none
    
    if (!machInst.vtype8.vta || (!machInst.vm && !machInst.vtype8.vma)) {
        RiscvISA::vreg_t old_vd;
        xc->getRegOperand(this, 1, &old_vd);
        tmp_d0 = old_vd;
    } else {
        tmp_d0.set(0xff);
    }
    

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    if (xc->readMemAccPredicate()) {
        memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());
    }

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    size_t ei;
    for (size_t i = 0; i < micro_vlmax; i++) {
        ei = i + micro_vlmax * microIdx;
        
                            if ((machInst.vm || elem_mask(v0, ei)) &&
                                i < this->microVl) {
                                Vd[i] = Mem.as<uint16_t>()[i];
                            }
                        ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// VlSegOp::vlseg2e16_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 2)) &&\n                                    i < this->microVl) {\n                                    Vd_uh[i] = Mem_vc.as<uint16_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


Fault
Vlseg2e16_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    uint32_t mem_size = width_EEW(machInst.width) / 8 * microVl;

    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint16_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);

    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = xc->readMem(EA, Mem.as<uint8_t>(), mem_size, memAccessFlags,
                              byte_enable);

    if (fault != NoFault)
        return fault;

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;

    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 2)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint16_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return fault;
}



Fault
Vlseg2e16_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;
    uint32_t mem_size = width_EEW(this->machInst.width) / 8 * this->microVl;

    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = initiateMemRead(xc, EA, mem_size, memAccessFlags,
                                  byte_enable);
    return fault;
}



Fault
Vlseg2e16_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint16_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    // tail/mask policy: both undisturbed if one is, 1s if none
    
    if (!machInst.vtype8.vta || (!machInst.vm && !machInst.vtype8.vma)) {
        RiscvISA::vreg_t old_vd;
        xc->getRegOperand(this, 1, &old_vd);
        tmp_d0 = old_vd;
    } else {
        tmp_d0.set(0xff);
    }
    

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;
    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 2)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint16_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// VlSegOp::vlseg3e16_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 3)) &&\n                                    i < this->microVl) {\n                                    Vd_uh[i] = Mem_vc.as<uint16_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


Fault
Vlseg3e16_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    uint32_t mem_size = width_EEW(machInst.width) / 8 * microVl;

    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint16_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);

    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = xc->readMem(EA, Mem.as<uint8_t>(), mem_size, memAccessFlags,
                              byte_enable);

    if (fault != NoFault)
        return fault;

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;

    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 3)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint16_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return fault;
}



Fault
Vlseg3e16_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;
    uint32_t mem_size = width_EEW(this->machInst.width) / 8 * this->microVl;

    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = initiateMemRead(xc, EA, mem_size, memAccessFlags,
                                  byte_enable);
    return fault;
}



Fault
Vlseg3e16_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint16_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    // tail/mask policy: both undisturbed if one is, 1s if none
    
    if (!machInst.vtype8.vta || (!machInst.vm && !machInst.vtype8.vma)) {
        RiscvISA::vreg_t old_vd;
        xc->getRegOperand(this, 1, &old_vd);
        tmp_d0 = old_vd;
    } else {
        tmp_d0.set(0xff);
    }
    

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;
    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 3)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint16_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// VlSegOp::vlseg4e16_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 4)) &&\n                                    i < this->microVl) {\n                                    Vd_uh[i] = Mem_vc.as<uint16_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


Fault
Vlseg4e16_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    uint32_t mem_size = width_EEW(machInst.width) / 8 * microVl;

    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint16_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);

    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = xc->readMem(EA, Mem.as<uint8_t>(), mem_size, memAccessFlags,
                              byte_enable);

    if (fault != NoFault)
        return fault;

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;

    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 4)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint16_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return fault;
}



Fault
Vlseg4e16_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;
    uint32_t mem_size = width_EEW(this->machInst.width) / 8 * this->microVl;

    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = initiateMemRead(xc, EA, mem_size, memAccessFlags,
                                  byte_enable);
    return fault;
}



Fault
Vlseg4e16_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint16_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    // tail/mask policy: both undisturbed if one is, 1s if none
    
    if (!machInst.vtype8.vta || (!machInst.vm && !machInst.vtype8.vma)) {
        RiscvISA::vreg_t old_vd;
        xc->getRegOperand(this, 1, &old_vd);
        tmp_d0 = old_vd;
    } else {
        tmp_d0.set(0xff);
    }
    

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;
    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 4)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint16_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// VlSegOp::vlseg5e16_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 5)) &&\n                                    i < this->microVl) {\n                                    Vd_uh[i] = Mem_vc.as<uint16_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


Fault
Vlseg5e16_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    uint32_t mem_size = width_EEW(machInst.width) / 8 * microVl;

    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint16_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);

    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = xc->readMem(EA, Mem.as<uint8_t>(), mem_size, memAccessFlags,
                              byte_enable);

    if (fault != NoFault)
        return fault;

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;

    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 5)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint16_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return fault;
}



Fault
Vlseg5e16_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;
    uint32_t mem_size = width_EEW(this->machInst.width) / 8 * this->microVl;

    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = initiateMemRead(xc, EA, mem_size, memAccessFlags,
                                  byte_enable);
    return fault;
}



Fault
Vlseg5e16_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint16_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    // tail/mask policy: both undisturbed if one is, 1s if none
    
    if (!machInst.vtype8.vta || (!machInst.vm && !machInst.vtype8.vma)) {
        RiscvISA::vreg_t old_vd;
        xc->getRegOperand(this, 1, &old_vd);
        tmp_d0 = old_vd;
    } else {
        tmp_d0.set(0xff);
    }
    

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;
    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 5)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint16_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// VlSegOp::vlseg6e16_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 6)) &&\n                                    i < this->microVl) {\n                                    Vd_uh[i] = Mem_vc.as<uint16_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


Fault
Vlseg6e16_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    uint32_t mem_size = width_EEW(machInst.width) / 8 * microVl;

    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint16_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);

    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = xc->readMem(EA, Mem.as<uint8_t>(), mem_size, memAccessFlags,
                              byte_enable);

    if (fault != NoFault)
        return fault;

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;

    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 6)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint16_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return fault;
}



Fault
Vlseg6e16_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;
    uint32_t mem_size = width_EEW(this->machInst.width) / 8 * this->microVl;

    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = initiateMemRead(xc, EA, mem_size, memAccessFlags,
                                  byte_enable);
    return fault;
}



Fault
Vlseg6e16_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint16_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    // tail/mask policy: both undisturbed if one is, 1s if none
    
    if (!machInst.vtype8.vta || (!machInst.vm && !machInst.vtype8.vma)) {
        RiscvISA::vreg_t old_vd;
        xc->getRegOperand(this, 1, &old_vd);
        tmp_d0 = old_vd;
    } else {
        tmp_d0.set(0xff);
    }
    

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;
    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 6)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint16_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// VlSegOp::vlseg7e16_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 7)) &&\n                                    i < this->microVl) {\n                                    Vd_uh[i] = Mem_vc.as<uint16_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


Fault
Vlseg7e16_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    uint32_t mem_size = width_EEW(machInst.width) / 8 * microVl;

    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint16_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);

    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = xc->readMem(EA, Mem.as<uint8_t>(), mem_size, memAccessFlags,
                              byte_enable);

    if (fault != NoFault)
        return fault;

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;

    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 7)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint16_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return fault;
}



Fault
Vlseg7e16_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;
    uint32_t mem_size = width_EEW(this->machInst.width) / 8 * this->microVl;

    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = initiateMemRead(xc, EA, mem_size, memAccessFlags,
                                  byte_enable);
    return fault;
}



Fault
Vlseg7e16_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint16_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    // tail/mask policy: both undisturbed if one is, 1s if none
    
    if (!machInst.vtype8.vta || (!machInst.vm && !machInst.vtype8.vma)) {
        RiscvISA::vreg_t old_vd;
        xc->getRegOperand(this, 1, &old_vd);
        tmp_d0 = old_vd;
    } else {
        tmp_d0.set(0xff);
    }
    

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;
    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 7)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint16_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// VlSegOp::vlseg8e16_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 8)) &&\n                                    i < this->microVl) {\n                                    Vd_uh[i] = Mem_vc.as<uint16_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


Fault
Vlseg8e16_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    uint32_t mem_size = width_EEW(machInst.width) / 8 * microVl;

    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint16_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);

    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = xc->readMem(EA, Mem.as<uint8_t>(), mem_size, memAccessFlags,
                              byte_enable);

    if (fault != NoFault)
        return fault;

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;

    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 8)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint16_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return fault;
}



Fault
Vlseg8e16_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;
    uint32_t mem_size = width_EEW(this->machInst.width) / 8 * this->microVl;

    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = initiateMemRead(xc, EA, mem_size, memAccessFlags,
                                  byte_enable);
    return fault;
}



Fault
Vlseg8e16_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint16_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    // tail/mask policy: both undisturbed if one is, 1s if none
    
    if (!machInst.vtype8.vta || (!machInst.vm && !machInst.vtype8.vma)) {
        RiscvISA::vreg_t old_vd;
        xc->getRegOperand(this, 1, &old_vd);
        tmp_d0 = old_vd;
    } else {
        tmp_d0.set(0xff);
    }
    

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;
    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 8)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint16_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// Unknown::unknown(([], {}))

// VlWholeOp::vl1re16_v(['\n                                Vd_uh[i] = Mem_vc.as<uint16_t>()[i];\n                            '],{'inst_flags': 'SimdWholeRegisterLoadOp'})


Fault
Vl1re16_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint16_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    Fault fault = readMemAtomicLE(xc, traceData, EA,
                            *(vreg_t::Container*)(&Mem), vlenb,
                            memAccessFlags);
    if (fault != NoFault)
        return fault;

    size_t elem_per_reg = vlen / width_EEW(machInst.width);
    for (size_t i = 0; i < elem_per_reg; i++) {
        
                                Vd[i] = Mem.as<uint16_t>()[i];
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}



Fault
Vl1re16_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    const std::vector<bool> byte_enable(vlenb, true);
    Fault fault = initiateMemRead(xc, EA, vlenb, memAccessFlags, byte_enable);
    return fault;
}



Fault
Vl1re16_vMicro::completeAcc(PacketPtr pkt, ExecContext* xc,
        trace::InstRecord* traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint16_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());

    size_t elem_per_reg = vlen / width_EEW(machInst.width);
    for (size_t i = 0; i < elem_per_reg; ++i) {
        
                                Vd[i] = Mem.as<uint16_t>()[i];
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// VlWholeOp::vl2re16_v(['\n                                Vd_uh[i] = Mem_vc.as<uint16_t>()[i];\n                            '],{'inst_flags': 'SimdWholeRegisterLoadOp'})


Fault
Vl2re16_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint16_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    Fault fault = readMemAtomicLE(xc, traceData, EA,
                            *(vreg_t::Container*)(&Mem), vlenb,
                            memAccessFlags);
    if (fault != NoFault)
        return fault;

    size_t elem_per_reg = vlen / width_EEW(machInst.width);
    for (size_t i = 0; i < elem_per_reg; i++) {
        
                                Vd[i] = Mem.as<uint16_t>()[i];
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}



Fault
Vl2re16_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    const std::vector<bool> byte_enable(vlenb, true);
    Fault fault = initiateMemRead(xc, EA, vlenb, memAccessFlags, byte_enable);
    return fault;
}



Fault
Vl2re16_vMicro::completeAcc(PacketPtr pkt, ExecContext* xc,
        trace::InstRecord* traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint16_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());

    size_t elem_per_reg = vlen / width_EEW(machInst.width);
    for (size_t i = 0; i < elem_per_reg; ++i) {
        
                                Vd[i] = Mem.as<uint16_t>()[i];
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// VlWholeOp::vl4re16_v(['\n                                Vd_uh[i] = Mem_vc.as<uint16_t>()[i];\n                            '],{'inst_flags': 'SimdWholeRegisterLoadOp'})


Fault
Vl4re16_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint16_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    Fault fault = readMemAtomicLE(xc, traceData, EA,
                            *(vreg_t::Container*)(&Mem), vlenb,
                            memAccessFlags);
    if (fault != NoFault)
        return fault;

    size_t elem_per_reg = vlen / width_EEW(machInst.width);
    for (size_t i = 0; i < elem_per_reg; i++) {
        
                                Vd[i] = Mem.as<uint16_t>()[i];
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}



Fault
Vl4re16_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    const std::vector<bool> byte_enable(vlenb, true);
    Fault fault = initiateMemRead(xc, EA, vlenb, memAccessFlags, byte_enable);
    return fault;
}



Fault
Vl4re16_vMicro::completeAcc(PacketPtr pkt, ExecContext* xc,
        trace::InstRecord* traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint16_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());

    size_t elem_per_reg = vlen / width_EEW(machInst.width);
    for (size_t i = 0; i < elem_per_reg; ++i) {
        
                                Vd[i] = Mem.as<uint16_t>()[i];
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// VlWholeOp::vl8re16_v(['\n                                Vd_uh[i] = Mem_vc.as<uint16_t>()[i];\n                            '],{'inst_flags': 'SimdWholeRegisterLoadOp'})


Fault
Vl8re16_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint16_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    Fault fault = readMemAtomicLE(xc, traceData, EA,
                            *(vreg_t::Container*)(&Mem), vlenb,
                            memAccessFlags);
    if (fault != NoFault)
        return fault;

    size_t elem_per_reg = vlen / width_EEW(machInst.width);
    for (size_t i = 0; i < elem_per_reg; i++) {
        
                                Vd[i] = Mem.as<uint16_t>()[i];
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}



Fault
Vl8re16_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    const std::vector<bool> byte_enable(vlenb, true);
    Fault fault = initiateMemRead(xc, EA, vlenb, memAccessFlags, byte_enable);
    return fault;
}



Fault
Vl8re16_vMicro::completeAcc(PacketPtr pkt, ExecContext* xc,
        trace::InstRecord* traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint16_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());

    size_t elem_per_reg = vlen / width_EEW(machInst.width);
    for (size_t i = 0; i < elem_per_reg; ++i) {
        
                                Vd[i] = Mem.as<uint16_t>()[i];
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// Unknown::unknown(([], {}))

// VleOp::vle16ff_v((['\n                        if ((machInst.vm || elem_mask(v0, ei)) &&\n                            i < this->microVl && i < this->faultIdx) {\n                            Vd_uh[i] = Mem_vc.as<uint16_t>()[i];\n                        }\n                    '], {'inst_flags': 'SimdUnitStrideFaultOnlyFirstLoadOp'}))


Fault
Vle16ff_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint16_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);

    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint32_t mem_size = width_EEW(machInst.width) / 8 * this->microVl;

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = xc->readMem(EA, Mem.as<uint8_t>(), mem_size, memAccessFlags,
                              byte_enable);

    
    Addr fault_addr;
    if (fault != NoFault && getFaultVAddr(fault, fault_addr)) {
        assert(fault_addr >= EA);
        faultIdx = (fault_addr - EA) / (width_EEW(machInst.width) / 8);
        if (microIdx != 0 || faultIdx != 0) {
            fault = NoFault;
            trimVl = true;
        }
    }
    ;

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    if (fault != NoFault)
        return fault;

    size_t ei;

    for (size_t i = 0; i < micro_vlmax; i++) {
        ei = i + micro_vlmax * microIdx;
        
                        if ((machInst.vm || elem_mask(v0, ei)) &&
                            i < this->microVl && i < this->faultIdx) {
                            Vd[i] = Mem.as<uint16_t>()[i];
                        }
                    ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return fault;
}



Fault
Vle16ff_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;

    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    uint32_t mem_size = width_EEW(this->machInst.width) / 8 * this->microVl;

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = initiateMemRead(xc, EA, mem_size, memAccessFlags,
                                  byte_enable);

    
    Addr fault_addr;
    if (fault != NoFault && getFaultVAddr(fault, fault_addr)) {
        assert(fault_addr >= EA);
        faultIdx = (fault_addr - EA) / (width_EEW(machInst.width) / 8);
        if (microIdx != 0 || faultIdx != 0) {
            fault = NoFault;
            trimVl = true;
        }
    }
    ;

    return fault;
}



Fault
Vle16ff_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint16_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    // tail/mask policy: both undisturbed if one is, 1s if none
    
    if (!machInst.vtype8.vta || (!machInst.vm && !machInst.vtype8.vma)) {
        RiscvISA::vreg_t old_vd;
        xc->getRegOperand(this, 1, &old_vd);
        tmp_d0 = old_vd;
    } else {
        tmp_d0.set(0xff);
    }
    

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    if (xc->readMemAccPredicate()) {
        memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());
    }

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    size_t ei;
    for (size_t i = 0; i < micro_vlmax; i++) {
        ei = i + micro_vlmax * microIdx;
        
                        if ((machInst.vm || elem_mask(v0, ei)) &&
                            i < this->microVl && i < this->faultIdx) {
                            Vd[i] = Mem.as<uint16_t>()[i];
                        }
                    ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// Unknown::unknown(([], {}))

// VlIndexOp::vluxei16_v((['\n                    Vd_vu[vdElemIdx] = Mem_vc.as<vu>()[0];\n                ', '\n                    EA = Rs1 + Vs2_uh[vs2ElemIdx];\n                '], {'inst_flags': 'SimdIndexedLoadOp'}))


template<typename ElemType>
Fault
Vluxei16_vMicro<ElemType>::execute(ExecContext *xc,
    trace::InstRecord *traceData)const
{
    using vu = std::make_unsigned_t<ElemType>;
    Fault fault = NoFault;
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    uint64_t Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<uint16_t>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
                    EA = Rs1 + Vs2[vs2ElemIdx];
                ;
    constexpr uint8_t elem_size = sizeof(Vd[0]);
    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint32_t mem_size = elem_size;
    const std::vector<bool> byte_enable(mem_size, true);
    size_t ei = this->vdRegIdx * vlenb / elem_size + this->vdElemIdx;
    if (machInst.vm || elem_mask(v0, ei)) {
        fault = xc->readMem(EA, Mem.as<uint8_t>(), mem_size,
                                memAccessFlags, byte_enable);
        if (fault != NoFault)
            return fault;
        
                    Vd[vdElemIdx] = Mem.as<vu>()[0];
                ; /* Vd[this->vdElemIdx] = Mem[0]; */
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return fault;
}



template<typename ElemType>
Fault
Vluxei16_vMicro<ElemType>::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    using vu = std::make_unsigned_t<ElemType>;
    Fault fault = NoFault;
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    uint64_t Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<uint16_t>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    constexpr uint8_t elem_size = sizeof(Vd[0]);
    
                    EA = Rs1 + Vs2[vs2ElemIdx];
                ; // ea_code depends on elem_size

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint32_t mem_size = elem_size;

    size_t ei = this->vdRegIdx * vlenb / elem_size + this->vdElemIdx;
    bool need_load = machInst.vm || elem_mask(v0, ei);
    const std::vector<bool> byte_enable(mem_size, need_load);
    fault = initiateMemRead(xc, EA, mem_size, memAccessFlags, byte_enable);
    return fault;
}



template<typename ElemType>
Fault
Vluxei16_vMicro<ElemType>::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    using vu = std::make_unsigned_t<ElemType>;
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    constexpr uint8_t elem_size = sizeof(Vd[0]);

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    size_t ei = this->vdRegIdx * vlenb / elem_size + this->vdElemIdx;
    if (machInst.vm || elem_mask(v0, ei)) {
        memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());
        
                    Vd[vdElemIdx] = Mem.as<vu>()[0];
                ; /* Vd[this->microIdx] = Mem[0]; */
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


    template class Vluxei16_vMicro<uint8_t>;
    template class Vluxei16_vMicro<uint16_t>;
    template class Vluxei16_vMicro<uint32_t>;
    template class Vluxei16_vMicro<uint64_t>;
    ;


// VlStrideOp::vlse16_v((['\n                    Vd_uh[microIdx] = Mem_vc.as<uint16_t>()[0];\n                '], {'inst_flags': 'SimdStridedLoadOp'}))


Fault
Vlse16_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Fault fault = NoFault;
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint16_t>();
Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    constexpr uint8_t elem_size = sizeof(Vd[0]);
    
        EA = Rs1 + Rs2 * (regIdx * vlenb / elem_size + microIdx);
    ; // ea_code depends on elem_size

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint32_t mem_size = elem_size;
    const std::vector<bool> byte_enable(mem_size, true);

    size_t ei = this->regIdx * vlenb / elem_size + this->microIdx;
    if (machInst.vm || elem_mask(v0, ei)) {
        fault = xc->readMem(EA, Mem.as<uint8_t>(), mem_size,
                                memAccessFlags, byte_enable);
        if (fault != NoFault)
            return fault;
        
                    Vd[microIdx] = Mem.as<uint16_t>()[0];
                ; /* Vd[this->microIdx] = Mem[0]; */
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return fault;
}



Fault
Vlse16_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    Fault fault = NoFault;
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint16_t>();
Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    constexpr uint8_t elem_size = sizeof(Vd[0]);
    
        EA = Rs1 + Rs2 * (regIdx * vlenb / elem_size + microIdx);
    ; // ea_code depends on elem_size

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint32_t mem_size = elem_size;
    size_t ei = this->regIdx * vlenb / elem_size + this->microIdx;
    bool need_load = machInst.vm || elem_mask(v0, ei);
    const std::vector<bool> byte_enable(mem_size, need_load);
    fault = initiateMemRead(xc, EA, mem_size, memAccessFlags, byte_enable);
    return fault;
}



Fault
Vlse16_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint16_t>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    size_t ei = this->regIdx * vlenb / sizeof(Vd[0]) + this->microIdx;
    if (machInst.vm || elem_mask(v0, ei)) {
        memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());
        
                    Vd[microIdx] = Mem.as<uint16_t>()[0];
                ; /* Vd[this->microIdx] = Mem[0]; */
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// VlIndexOp::vloxei16_v((['\n                    Vd_vu[vdElemIdx] = Mem_vc.as<vu>()[0];\n                ', '\n                    EA = Rs1 + Vs2_uh[vs2ElemIdx];\n                '], {'inst_flags': 'SimdIndexedLoadOp'}))


template<typename ElemType>
Fault
Vloxei16_vMicro<ElemType>::execute(ExecContext *xc,
    trace::InstRecord *traceData)const
{
    using vu = std::make_unsigned_t<ElemType>;
    Fault fault = NoFault;
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    uint64_t Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<uint16_t>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
                    EA = Rs1 + Vs2[vs2ElemIdx];
                ;
    constexpr uint8_t elem_size = sizeof(Vd[0]);
    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint32_t mem_size = elem_size;
    const std::vector<bool> byte_enable(mem_size, true);
    size_t ei = this->vdRegIdx * vlenb / elem_size + this->vdElemIdx;
    if (machInst.vm || elem_mask(v0, ei)) {
        fault = xc->readMem(EA, Mem.as<uint8_t>(), mem_size,
                                memAccessFlags, byte_enable);
        if (fault != NoFault)
            return fault;
        
                    Vd[vdElemIdx] = Mem.as<vu>()[0];
                ; /* Vd[this->vdElemIdx] = Mem[0]; */
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return fault;
}



template<typename ElemType>
Fault
Vloxei16_vMicro<ElemType>::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    using vu = std::make_unsigned_t<ElemType>;
    Fault fault = NoFault;
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    uint64_t Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<uint16_t>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    constexpr uint8_t elem_size = sizeof(Vd[0]);
    
                    EA = Rs1 + Vs2[vs2ElemIdx];
                ; // ea_code depends on elem_size

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint32_t mem_size = elem_size;

    size_t ei = this->vdRegIdx * vlenb / elem_size + this->vdElemIdx;
    bool need_load = machInst.vm || elem_mask(v0, ei);
    const std::vector<bool> byte_enable(mem_size, need_load);
    fault = initiateMemRead(xc, EA, mem_size, memAccessFlags, byte_enable);
    return fault;
}



template<typename ElemType>
Fault
Vloxei16_vMicro<ElemType>::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    using vu = std::make_unsigned_t<ElemType>;
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    constexpr uint8_t elem_size = sizeof(Vd[0]);

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    size_t ei = this->vdRegIdx * vlenb / elem_size + this->vdElemIdx;
    if (machInst.vm || elem_mask(v0, ei)) {
        memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());
        
                    Vd[vdElemIdx] = Mem.as<vu>()[0];
                ; /* Vd[this->microIdx] = Mem[0]; */
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


    template class Vloxei16_vMicro<uint8_t>;
    template class Vloxei16_vMicro<uint16_t>;
    template class Vloxei16_vMicro<uint32_t>;
    template class Vloxei16_vMicro<uint64_t>;
    ;


// Unknown::unknown(([], {}))

// VleOp::vle32_v((['\n                            if ((machInst.vm || elem_mask(v0, ei)) &&\n                                i < this->microVl) {\n                                Vd_uw[i] = Mem_vc.as<uint32_t>()[i];\n                            }\n                        '], {'inst_flags': 'SimdUnitStrideLoadOp'}))


Fault
Vle32_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint32_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);

    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint32_t mem_size = width_EEW(machInst.width) / 8 * this->microVl;

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = xc->readMem(EA, Mem.as<uint8_t>(), mem_size, memAccessFlags,
                              byte_enable);

    ;

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    if (fault != NoFault)
        return fault;

    size_t ei;

    for (size_t i = 0; i < micro_vlmax; i++) {
        ei = i + micro_vlmax * microIdx;
        
                            if ((machInst.vm || elem_mask(v0, ei)) &&
                                i < this->microVl) {
                                Vd[i] = Mem.as<uint32_t>()[i];
                            }
                        ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return fault;
}



Fault
Vle32_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;

    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    uint32_t mem_size = width_EEW(this->machInst.width) / 8 * this->microVl;

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = initiateMemRead(xc, EA, mem_size, memAccessFlags,
                                  byte_enable);

    ;

    return fault;
}



Fault
Vle32_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint32_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    // tail/mask policy: both undisturbed if one is, 1s if none
    
    if (!machInst.vtype8.vta || (!machInst.vm && !machInst.vtype8.vma)) {
        RiscvISA::vreg_t old_vd;
        xc->getRegOperand(this, 1, &old_vd);
        tmp_d0 = old_vd;
    } else {
        tmp_d0.set(0xff);
    }
    

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    if (xc->readMemAccPredicate()) {
        memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());
    }

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    size_t ei;
    for (size_t i = 0; i < micro_vlmax; i++) {
        ei = i + micro_vlmax * microIdx;
        
                            if ((machInst.vm || elem_mask(v0, ei)) &&
                                i < this->microVl) {
                                Vd[i] = Mem.as<uint32_t>()[i];
                            }
                        ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// VlSegOp::vlseg2e32_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 2)) &&\n                                    i < this->microVl) {\n                                    Vd_uw[i] = Mem_vc.as<uint32_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


Fault
Vlseg2e32_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    uint32_t mem_size = width_EEW(machInst.width) / 8 * microVl;

    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint32_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);

    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = xc->readMem(EA, Mem.as<uint8_t>(), mem_size, memAccessFlags,
                              byte_enable);

    if (fault != NoFault)
        return fault;

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;

    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 2)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint32_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return fault;
}



Fault
Vlseg2e32_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;
    uint32_t mem_size = width_EEW(this->machInst.width) / 8 * this->microVl;

    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = initiateMemRead(xc, EA, mem_size, memAccessFlags,
                                  byte_enable);
    return fault;
}



Fault
Vlseg2e32_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint32_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    // tail/mask policy: both undisturbed if one is, 1s if none
    
    if (!machInst.vtype8.vta || (!machInst.vm && !machInst.vtype8.vma)) {
        RiscvISA::vreg_t old_vd;
        xc->getRegOperand(this, 1, &old_vd);
        tmp_d0 = old_vd;
    } else {
        tmp_d0.set(0xff);
    }
    

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;
    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 2)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint32_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// VlSegOp::vlseg3e32_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 3)) &&\n                                    i < this->microVl) {\n                                    Vd_uw[i] = Mem_vc.as<uint32_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


Fault
Vlseg3e32_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    uint32_t mem_size = width_EEW(machInst.width) / 8 * microVl;

    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint32_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);

    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = xc->readMem(EA, Mem.as<uint8_t>(), mem_size, memAccessFlags,
                              byte_enable);

    if (fault != NoFault)
        return fault;

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;

    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 3)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint32_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return fault;
}



Fault
Vlseg3e32_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;
    uint32_t mem_size = width_EEW(this->machInst.width) / 8 * this->microVl;

    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = initiateMemRead(xc, EA, mem_size, memAccessFlags,
                                  byte_enable);
    return fault;
}



Fault
Vlseg3e32_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint32_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    // tail/mask policy: both undisturbed if one is, 1s if none
    
    if (!machInst.vtype8.vta || (!machInst.vm && !machInst.vtype8.vma)) {
        RiscvISA::vreg_t old_vd;
        xc->getRegOperand(this, 1, &old_vd);
        tmp_d0 = old_vd;
    } else {
        tmp_d0.set(0xff);
    }
    

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;
    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 3)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint32_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// VlSegOp::vlseg4e32_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 4)) &&\n                                    i < this->microVl) {\n                                    Vd_uw[i] = Mem_vc.as<uint32_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


Fault
Vlseg4e32_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    uint32_t mem_size = width_EEW(machInst.width) / 8 * microVl;

    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint32_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);

    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = xc->readMem(EA, Mem.as<uint8_t>(), mem_size, memAccessFlags,
                              byte_enable);

    if (fault != NoFault)
        return fault;

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;

    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 4)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint32_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return fault;
}



Fault
Vlseg4e32_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;
    uint32_t mem_size = width_EEW(this->machInst.width) / 8 * this->microVl;

    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = initiateMemRead(xc, EA, mem_size, memAccessFlags,
                                  byte_enable);
    return fault;
}



Fault
Vlseg4e32_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint32_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    // tail/mask policy: both undisturbed if one is, 1s if none
    
    if (!machInst.vtype8.vta || (!machInst.vm && !machInst.vtype8.vma)) {
        RiscvISA::vreg_t old_vd;
        xc->getRegOperand(this, 1, &old_vd);
        tmp_d0 = old_vd;
    } else {
        tmp_d0.set(0xff);
    }
    

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;
    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 4)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint32_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// VlSegOp::vlseg5e32_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 5)) &&\n                                    i < this->microVl) {\n                                    Vd_uw[i] = Mem_vc.as<uint32_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


Fault
Vlseg5e32_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    uint32_t mem_size = width_EEW(machInst.width) / 8 * microVl;

    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint32_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);

    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = xc->readMem(EA, Mem.as<uint8_t>(), mem_size, memAccessFlags,
                              byte_enable);

    if (fault != NoFault)
        return fault;

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;

    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 5)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint32_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return fault;
}



Fault
Vlseg5e32_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;
    uint32_t mem_size = width_EEW(this->machInst.width) / 8 * this->microVl;

    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = initiateMemRead(xc, EA, mem_size, memAccessFlags,
                                  byte_enable);
    return fault;
}



Fault
Vlseg5e32_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint32_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    // tail/mask policy: both undisturbed if one is, 1s if none
    
    if (!machInst.vtype8.vta || (!machInst.vm && !machInst.vtype8.vma)) {
        RiscvISA::vreg_t old_vd;
        xc->getRegOperand(this, 1, &old_vd);
        tmp_d0 = old_vd;
    } else {
        tmp_d0.set(0xff);
    }
    

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;
    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 5)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint32_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// VlSegOp::vlseg6e32_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 6)) &&\n                                    i < this->microVl) {\n                                    Vd_uw[i] = Mem_vc.as<uint32_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


Fault
Vlseg6e32_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    uint32_t mem_size = width_EEW(machInst.width) / 8 * microVl;

    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint32_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);

    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = xc->readMem(EA, Mem.as<uint8_t>(), mem_size, memAccessFlags,
                              byte_enable);

    if (fault != NoFault)
        return fault;

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;

    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 6)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint32_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return fault;
}



Fault
Vlseg6e32_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;
    uint32_t mem_size = width_EEW(this->machInst.width) / 8 * this->microVl;

    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = initiateMemRead(xc, EA, mem_size, memAccessFlags,
                                  byte_enable);
    return fault;
}



Fault
Vlseg6e32_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint32_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    // tail/mask policy: both undisturbed if one is, 1s if none
    
    if (!machInst.vtype8.vta || (!machInst.vm && !machInst.vtype8.vma)) {
        RiscvISA::vreg_t old_vd;
        xc->getRegOperand(this, 1, &old_vd);
        tmp_d0 = old_vd;
    } else {
        tmp_d0.set(0xff);
    }
    

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;
    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 6)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint32_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// VlSegOp::vlseg7e32_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 7)) &&\n                                    i < this->microVl) {\n                                    Vd_uw[i] = Mem_vc.as<uint32_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


Fault
Vlseg7e32_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    uint32_t mem_size = width_EEW(machInst.width) / 8 * microVl;

    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint32_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);

    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = xc->readMem(EA, Mem.as<uint8_t>(), mem_size, memAccessFlags,
                              byte_enable);

    if (fault != NoFault)
        return fault;

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;

    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 7)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint32_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return fault;
}



Fault
Vlseg7e32_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;
    uint32_t mem_size = width_EEW(this->machInst.width) / 8 * this->microVl;

    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = initiateMemRead(xc, EA, mem_size, memAccessFlags,
                                  byte_enable);
    return fault;
}



Fault
Vlseg7e32_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint32_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    // tail/mask policy: both undisturbed if one is, 1s if none
    
    if (!machInst.vtype8.vta || (!machInst.vm && !machInst.vtype8.vma)) {
        RiscvISA::vreg_t old_vd;
        xc->getRegOperand(this, 1, &old_vd);
        tmp_d0 = old_vd;
    } else {
        tmp_d0.set(0xff);
    }
    

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;
    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 7)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint32_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// VlSegOp::vlseg8e32_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 8)) &&\n                                    i < this->microVl) {\n                                    Vd_uw[i] = Mem_vc.as<uint32_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


Fault
Vlseg8e32_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    uint32_t mem_size = width_EEW(machInst.width) / 8 * microVl;

    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint32_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);

    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = xc->readMem(EA, Mem.as<uint8_t>(), mem_size, memAccessFlags,
                              byte_enable);

    if (fault != NoFault)
        return fault;

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;

    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 8)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint32_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return fault;
}



Fault
Vlseg8e32_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;
    uint32_t mem_size = width_EEW(this->machInst.width) / 8 * this->microVl;

    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = initiateMemRead(xc, EA, mem_size, memAccessFlags,
                                  byte_enable);
    return fault;
}



Fault
Vlseg8e32_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint32_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    // tail/mask policy: both undisturbed if one is, 1s if none
    
    if (!machInst.vtype8.vta || (!machInst.vm && !machInst.vtype8.vma)) {
        RiscvISA::vreg_t old_vd;
        xc->getRegOperand(this, 1, &old_vd);
        tmp_d0 = old_vd;
    } else {
        tmp_d0.set(0xff);
    }
    

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;
    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 8)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint32_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// Unknown::unknown(([], {}))

// VlWholeOp::vl1re32_v(['\n                                Vd_uw[i] = Mem_vc.as<uint32_t>()[i];\n                            '],{'inst_flags': 'SimdWholeRegisterLoadOp'})


Fault
Vl1re32_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint32_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    Fault fault = readMemAtomicLE(xc, traceData, EA,
                            *(vreg_t::Container*)(&Mem), vlenb,
                            memAccessFlags);
    if (fault != NoFault)
        return fault;

    size_t elem_per_reg = vlen / width_EEW(machInst.width);
    for (size_t i = 0; i < elem_per_reg; i++) {
        
                                Vd[i] = Mem.as<uint32_t>()[i];
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}



Fault
Vl1re32_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    const std::vector<bool> byte_enable(vlenb, true);
    Fault fault = initiateMemRead(xc, EA, vlenb, memAccessFlags, byte_enable);
    return fault;
}



Fault
Vl1re32_vMicro::completeAcc(PacketPtr pkt, ExecContext* xc,
        trace::InstRecord* traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint32_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());

    size_t elem_per_reg = vlen / width_EEW(machInst.width);
    for (size_t i = 0; i < elem_per_reg; ++i) {
        
                                Vd[i] = Mem.as<uint32_t>()[i];
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// VlWholeOp::vl2re32_v(['\n                                Vd_uw[i] = Mem_vc.as<uint32_t>()[i];\n                            '],{'inst_flags': 'SimdWholeRegisterLoadOp'})


Fault
Vl2re32_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint32_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    Fault fault = readMemAtomicLE(xc, traceData, EA,
                            *(vreg_t::Container*)(&Mem), vlenb,
                            memAccessFlags);
    if (fault != NoFault)
        return fault;

    size_t elem_per_reg = vlen / width_EEW(machInst.width);
    for (size_t i = 0; i < elem_per_reg; i++) {
        
                                Vd[i] = Mem.as<uint32_t>()[i];
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}



Fault
Vl2re32_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    const std::vector<bool> byte_enable(vlenb, true);
    Fault fault = initiateMemRead(xc, EA, vlenb, memAccessFlags, byte_enable);
    return fault;
}



Fault
Vl2re32_vMicro::completeAcc(PacketPtr pkt, ExecContext* xc,
        trace::InstRecord* traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint32_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());

    size_t elem_per_reg = vlen / width_EEW(machInst.width);
    for (size_t i = 0; i < elem_per_reg; ++i) {
        
                                Vd[i] = Mem.as<uint32_t>()[i];
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// VlWholeOp::vl4re32_v(['\n                                Vd_uw[i] = Mem_vc.as<uint32_t>()[i];\n                            '],{'inst_flags': 'SimdWholeRegisterLoadOp'})


Fault
Vl4re32_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint32_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    Fault fault = readMemAtomicLE(xc, traceData, EA,
                            *(vreg_t::Container*)(&Mem), vlenb,
                            memAccessFlags);
    if (fault != NoFault)
        return fault;

    size_t elem_per_reg = vlen / width_EEW(machInst.width);
    for (size_t i = 0; i < elem_per_reg; i++) {
        
                                Vd[i] = Mem.as<uint32_t>()[i];
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}



Fault
Vl4re32_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    const std::vector<bool> byte_enable(vlenb, true);
    Fault fault = initiateMemRead(xc, EA, vlenb, memAccessFlags, byte_enable);
    return fault;
}



Fault
Vl4re32_vMicro::completeAcc(PacketPtr pkt, ExecContext* xc,
        trace::InstRecord* traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint32_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());

    size_t elem_per_reg = vlen / width_EEW(machInst.width);
    for (size_t i = 0; i < elem_per_reg; ++i) {
        
                                Vd[i] = Mem.as<uint32_t>()[i];
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// VlWholeOp::vl8re32_v(['\n                                Vd_uw[i] = Mem_vc.as<uint32_t>()[i];\n                            '],{'inst_flags': 'SimdWholeRegisterLoadOp'})


Fault
Vl8re32_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint32_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    Fault fault = readMemAtomicLE(xc, traceData, EA,
                            *(vreg_t::Container*)(&Mem), vlenb,
                            memAccessFlags);
    if (fault != NoFault)
        return fault;

    size_t elem_per_reg = vlen / width_EEW(machInst.width);
    for (size_t i = 0; i < elem_per_reg; i++) {
        
                                Vd[i] = Mem.as<uint32_t>()[i];
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}



Fault
Vl8re32_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    const std::vector<bool> byte_enable(vlenb, true);
    Fault fault = initiateMemRead(xc, EA, vlenb, memAccessFlags, byte_enable);
    return fault;
}



Fault
Vl8re32_vMicro::completeAcc(PacketPtr pkt, ExecContext* xc,
        trace::InstRecord* traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint32_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());

    size_t elem_per_reg = vlen / width_EEW(machInst.width);
    for (size_t i = 0; i < elem_per_reg; ++i) {
        
                                Vd[i] = Mem.as<uint32_t>()[i];
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// Unknown::unknown(([], {}))

// VleOp::vle32ff_v((['\n                        if ((machInst.vm || elem_mask(v0, ei)) &&\n                            i < this->microVl && i < this->faultIdx) {\n                            Vd_uw[i] = Mem_vc.as<uint32_t>()[i];\n                        }\n                    '], {'inst_flags': 'SimdUnitStrideFaultOnlyFirstLoadOp'}))


Fault
Vle32ff_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint32_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);

    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint32_t mem_size = width_EEW(machInst.width) / 8 * this->microVl;

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = xc->readMem(EA, Mem.as<uint8_t>(), mem_size, memAccessFlags,
                              byte_enable);

    
    Addr fault_addr;
    if (fault != NoFault && getFaultVAddr(fault, fault_addr)) {
        assert(fault_addr >= EA);
        faultIdx = (fault_addr - EA) / (width_EEW(machInst.width) / 8);
        if (microIdx != 0 || faultIdx != 0) {
            fault = NoFault;
            trimVl = true;
        }
    }
    ;

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    if (fault != NoFault)
        return fault;

    size_t ei;

    for (size_t i = 0; i < micro_vlmax; i++) {
        ei = i + micro_vlmax * microIdx;
        
                        if ((machInst.vm || elem_mask(v0, ei)) &&
                            i < this->microVl && i < this->faultIdx) {
                            Vd[i] = Mem.as<uint32_t>()[i];
                        }
                    ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return fault;
}



Fault
Vle32ff_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;

    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    uint32_t mem_size = width_EEW(this->machInst.width) / 8 * this->microVl;

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = initiateMemRead(xc, EA, mem_size, memAccessFlags,
                                  byte_enable);

    
    Addr fault_addr;
    if (fault != NoFault && getFaultVAddr(fault, fault_addr)) {
        assert(fault_addr >= EA);
        faultIdx = (fault_addr - EA) / (width_EEW(machInst.width) / 8);
        if (microIdx != 0 || faultIdx != 0) {
            fault = NoFault;
            trimVl = true;
        }
    }
    ;

    return fault;
}



Fault
Vle32ff_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint32_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    // tail/mask policy: both undisturbed if one is, 1s if none
    
    if (!machInst.vtype8.vta || (!machInst.vm && !machInst.vtype8.vma)) {
        RiscvISA::vreg_t old_vd;
        xc->getRegOperand(this, 1, &old_vd);
        tmp_d0 = old_vd;
    } else {
        tmp_d0.set(0xff);
    }
    

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    if (xc->readMemAccPredicate()) {
        memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());
    }

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    size_t ei;
    for (size_t i = 0; i < micro_vlmax; i++) {
        ei = i + micro_vlmax * microIdx;
        
                        if ((machInst.vm || elem_mask(v0, ei)) &&
                            i < this->microVl && i < this->faultIdx) {
                            Vd[i] = Mem.as<uint32_t>()[i];
                        }
                    ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// Unknown::unknown(([], {}))

// VlIndexOp::vluxei32_v((['\n                    Vd_vu[vdElemIdx] = Mem_vc.as<vu>()[0];\n                ', '\n                    EA = Rs1 + Vs2_uw[vs2ElemIdx];\n                '], {'inst_flags': 'SimdIndexedLoadOp'}))


template<typename ElemType>
Fault
Vluxei32_vMicro<ElemType>::execute(ExecContext *xc,
    trace::InstRecord *traceData)const
{
    using vu = std::make_unsigned_t<ElemType>;
    Fault fault = NoFault;
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    uint64_t Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<uint32_t>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
                    EA = Rs1 + Vs2[vs2ElemIdx];
                ;
    constexpr uint8_t elem_size = sizeof(Vd[0]);
    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint32_t mem_size = elem_size;
    const std::vector<bool> byte_enable(mem_size, true);
    size_t ei = this->vdRegIdx * vlenb / elem_size + this->vdElemIdx;
    if (machInst.vm || elem_mask(v0, ei)) {
        fault = xc->readMem(EA, Mem.as<uint8_t>(), mem_size,
                                memAccessFlags, byte_enable);
        if (fault != NoFault)
            return fault;
        
                    Vd[vdElemIdx] = Mem.as<vu>()[0];
                ; /* Vd[this->vdElemIdx] = Mem[0]; */
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return fault;
}



template<typename ElemType>
Fault
Vluxei32_vMicro<ElemType>::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    using vu = std::make_unsigned_t<ElemType>;
    Fault fault = NoFault;
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    uint64_t Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<uint32_t>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    constexpr uint8_t elem_size = sizeof(Vd[0]);
    
                    EA = Rs1 + Vs2[vs2ElemIdx];
                ; // ea_code depends on elem_size

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint32_t mem_size = elem_size;

    size_t ei = this->vdRegIdx * vlenb / elem_size + this->vdElemIdx;
    bool need_load = machInst.vm || elem_mask(v0, ei);
    const std::vector<bool> byte_enable(mem_size, need_load);
    fault = initiateMemRead(xc, EA, mem_size, memAccessFlags, byte_enable);
    return fault;
}



template<typename ElemType>
Fault
Vluxei32_vMicro<ElemType>::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    using vu = std::make_unsigned_t<ElemType>;
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    constexpr uint8_t elem_size = sizeof(Vd[0]);

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    size_t ei = this->vdRegIdx * vlenb / elem_size + this->vdElemIdx;
    if (machInst.vm || elem_mask(v0, ei)) {
        memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());
        
                    Vd[vdElemIdx] = Mem.as<vu>()[0];
                ; /* Vd[this->microIdx] = Mem[0]; */
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


    template class Vluxei32_vMicro<uint8_t>;
    template class Vluxei32_vMicro<uint16_t>;
    template class Vluxei32_vMicro<uint32_t>;
    template class Vluxei32_vMicro<uint64_t>;
    ;


// VlStrideOp::vlse32_v((['\n                    Vd_uw[microIdx] = Mem_vc.as<uint32_t>()[0];\n                '], {'inst_flags': 'SimdStridedLoadOp'}))


Fault
Vlse32_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Fault fault = NoFault;
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint32_t>();
Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    constexpr uint8_t elem_size = sizeof(Vd[0]);
    
        EA = Rs1 + Rs2 * (regIdx * vlenb / elem_size + microIdx);
    ; // ea_code depends on elem_size

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint32_t mem_size = elem_size;
    const std::vector<bool> byte_enable(mem_size, true);

    size_t ei = this->regIdx * vlenb / elem_size + this->microIdx;
    if (machInst.vm || elem_mask(v0, ei)) {
        fault = xc->readMem(EA, Mem.as<uint8_t>(), mem_size,
                                memAccessFlags, byte_enable);
        if (fault != NoFault)
            return fault;
        
                    Vd[microIdx] = Mem.as<uint32_t>()[0];
                ; /* Vd[this->microIdx] = Mem[0]; */
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return fault;
}



Fault
Vlse32_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    Fault fault = NoFault;
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint32_t>();
Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    constexpr uint8_t elem_size = sizeof(Vd[0]);
    
        EA = Rs1 + Rs2 * (regIdx * vlenb / elem_size + microIdx);
    ; // ea_code depends on elem_size

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint32_t mem_size = elem_size;
    size_t ei = this->regIdx * vlenb / elem_size + this->microIdx;
    bool need_load = machInst.vm || elem_mask(v0, ei);
    const std::vector<bool> byte_enable(mem_size, need_load);
    fault = initiateMemRead(xc, EA, mem_size, memAccessFlags, byte_enable);
    return fault;
}



Fault
Vlse32_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint32_t>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    size_t ei = this->regIdx * vlenb / sizeof(Vd[0]) + this->microIdx;
    if (machInst.vm || elem_mask(v0, ei)) {
        memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());
        
                    Vd[microIdx] = Mem.as<uint32_t>()[0];
                ; /* Vd[this->microIdx] = Mem[0]; */
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// VlIndexOp::vloxei32_v((['\n                    Vd_vu[vdElemIdx] = Mem_vc.as<vu>()[0];\n                ', '\n                    EA = Rs1 + Vs2_uw[vs2ElemIdx];\n                '], {'inst_flags': 'SimdIndexedLoadOp'}))


template<typename ElemType>
Fault
Vloxei32_vMicro<ElemType>::execute(ExecContext *xc,
    trace::InstRecord *traceData)const
{
    using vu = std::make_unsigned_t<ElemType>;
    Fault fault = NoFault;
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    uint64_t Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<uint32_t>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
                    EA = Rs1 + Vs2[vs2ElemIdx];
                ;
    constexpr uint8_t elem_size = sizeof(Vd[0]);
    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint32_t mem_size = elem_size;
    const std::vector<bool> byte_enable(mem_size, true);
    size_t ei = this->vdRegIdx * vlenb / elem_size + this->vdElemIdx;
    if (machInst.vm || elem_mask(v0, ei)) {
        fault = xc->readMem(EA, Mem.as<uint8_t>(), mem_size,
                                memAccessFlags, byte_enable);
        if (fault != NoFault)
            return fault;
        
                    Vd[vdElemIdx] = Mem.as<vu>()[0];
                ; /* Vd[this->vdElemIdx] = Mem[0]; */
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return fault;
}



template<typename ElemType>
Fault
Vloxei32_vMicro<ElemType>::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    using vu = std::make_unsigned_t<ElemType>;
    Fault fault = NoFault;
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    uint64_t Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<uint32_t>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    constexpr uint8_t elem_size = sizeof(Vd[0]);
    
                    EA = Rs1 + Vs2[vs2ElemIdx];
                ; // ea_code depends on elem_size

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint32_t mem_size = elem_size;

    size_t ei = this->vdRegIdx * vlenb / elem_size + this->vdElemIdx;
    bool need_load = machInst.vm || elem_mask(v0, ei);
    const std::vector<bool> byte_enable(mem_size, need_load);
    fault = initiateMemRead(xc, EA, mem_size, memAccessFlags, byte_enable);
    return fault;
}



template<typename ElemType>
Fault
Vloxei32_vMicro<ElemType>::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    using vu = std::make_unsigned_t<ElemType>;
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    constexpr uint8_t elem_size = sizeof(Vd[0]);

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    size_t ei = this->vdRegIdx * vlenb / elem_size + this->vdElemIdx;
    if (machInst.vm || elem_mask(v0, ei)) {
        memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());
        
                    Vd[vdElemIdx] = Mem.as<vu>()[0];
                ; /* Vd[this->microIdx] = Mem[0]; */
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


    template class Vloxei32_vMicro<uint8_t>;
    template class Vloxei32_vMicro<uint16_t>;
    template class Vloxei32_vMicro<uint32_t>;
    template class Vloxei32_vMicro<uint64_t>;
    ;


// Unknown::unknown(([], {}))

// VleOp::vle64_v((['\n                            if ((machInst.vm || elem_mask(v0, ei)) &&\n                                i < this->microVl) {\n                                Vd_ud[i] = Mem_vc.as<uint64_t>()[i];\n                            }\n                        '], {'inst_flags': 'SimdUnitStrideLoadOp'}))


Fault
Vle64_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint64_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);

    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint32_t mem_size = width_EEW(machInst.width) / 8 * this->microVl;

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = xc->readMem(EA, Mem.as<uint8_t>(), mem_size, memAccessFlags,
                              byte_enable);

    ;

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    if (fault != NoFault)
        return fault;

    size_t ei;

    for (size_t i = 0; i < micro_vlmax; i++) {
        ei = i + micro_vlmax * microIdx;
        
                            if ((machInst.vm || elem_mask(v0, ei)) &&
                                i < this->microVl) {
                                Vd[i] = Mem.as<uint64_t>()[i];
                            }
                        ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return fault;
}



Fault
Vle64_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;

    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    uint32_t mem_size = width_EEW(this->machInst.width) / 8 * this->microVl;

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = initiateMemRead(xc, EA, mem_size, memAccessFlags,
                                  byte_enable);

    ;

    return fault;
}



Fault
Vle64_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint64_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    // tail/mask policy: both undisturbed if one is, 1s if none
    
    if (!machInst.vtype8.vta || (!machInst.vm && !machInst.vtype8.vma)) {
        RiscvISA::vreg_t old_vd;
        xc->getRegOperand(this, 1, &old_vd);
        tmp_d0 = old_vd;
    } else {
        tmp_d0.set(0xff);
    }
    

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    if (xc->readMemAccPredicate()) {
        memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());
    }

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    size_t ei;
    for (size_t i = 0; i < micro_vlmax; i++) {
        ei = i + micro_vlmax * microIdx;
        
                            if ((machInst.vm || elem_mask(v0, ei)) &&
                                i < this->microVl) {
                                Vd[i] = Mem.as<uint64_t>()[i];
                            }
                        ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// VlSegOp::vlseg2e64_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 2)) &&\n                                    i < this->microVl) {\n                                    Vd_ud[i] = Mem_vc.as<uint64_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


Fault
Vlseg2e64_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    uint32_t mem_size = width_EEW(machInst.width) / 8 * microVl;

    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint64_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);

    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = xc->readMem(EA, Mem.as<uint8_t>(), mem_size, memAccessFlags,
                              byte_enable);

    if (fault != NoFault)
        return fault;

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;

    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 2)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint64_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return fault;
}



Fault
Vlseg2e64_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;
    uint32_t mem_size = width_EEW(this->machInst.width) / 8 * this->microVl;

    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = initiateMemRead(xc, EA, mem_size, memAccessFlags,
                                  byte_enable);
    return fault;
}



Fault
Vlseg2e64_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint64_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    // tail/mask policy: both undisturbed if one is, 1s if none
    
    if (!machInst.vtype8.vta || (!machInst.vm && !machInst.vtype8.vma)) {
        RiscvISA::vreg_t old_vd;
        xc->getRegOperand(this, 1, &old_vd);
        tmp_d0 = old_vd;
    } else {
        tmp_d0.set(0xff);
    }
    

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;
    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 2)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint64_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// VlSegOp::vlseg3e64_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 3)) &&\n                                    i < this->microVl) {\n                                    Vd_ud[i] = Mem_vc.as<uint64_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


Fault
Vlseg3e64_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    uint32_t mem_size = width_EEW(machInst.width) / 8 * microVl;

    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint64_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);

    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = xc->readMem(EA, Mem.as<uint8_t>(), mem_size, memAccessFlags,
                              byte_enable);

    if (fault != NoFault)
        return fault;

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;

    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 3)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint64_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return fault;
}



Fault
Vlseg3e64_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;
    uint32_t mem_size = width_EEW(this->machInst.width) / 8 * this->microVl;

    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = initiateMemRead(xc, EA, mem_size, memAccessFlags,
                                  byte_enable);
    return fault;
}



Fault
Vlseg3e64_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint64_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    // tail/mask policy: both undisturbed if one is, 1s if none
    
    if (!machInst.vtype8.vta || (!machInst.vm && !machInst.vtype8.vma)) {
        RiscvISA::vreg_t old_vd;
        xc->getRegOperand(this, 1, &old_vd);
        tmp_d0 = old_vd;
    } else {
        tmp_d0.set(0xff);
    }
    

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;
    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 3)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint64_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// VlSegOp::vlseg4e64_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 4)) &&\n                                    i < this->microVl) {\n                                    Vd_ud[i] = Mem_vc.as<uint64_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


Fault
Vlseg4e64_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    uint32_t mem_size = width_EEW(machInst.width) / 8 * microVl;

    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint64_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);

    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = xc->readMem(EA, Mem.as<uint8_t>(), mem_size, memAccessFlags,
                              byte_enable);

    if (fault != NoFault)
        return fault;

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;

    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 4)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint64_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return fault;
}



Fault
Vlseg4e64_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;
    uint32_t mem_size = width_EEW(this->machInst.width) / 8 * this->microVl;

    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = initiateMemRead(xc, EA, mem_size, memAccessFlags,
                                  byte_enable);
    return fault;
}



Fault
Vlseg4e64_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint64_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    // tail/mask policy: both undisturbed if one is, 1s if none
    
    if (!machInst.vtype8.vta || (!machInst.vm && !machInst.vtype8.vma)) {
        RiscvISA::vreg_t old_vd;
        xc->getRegOperand(this, 1, &old_vd);
        tmp_d0 = old_vd;
    } else {
        tmp_d0.set(0xff);
    }
    

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;
    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 4)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint64_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// VlSegOp::vlseg5e64_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 5)) &&\n                                    i < this->microVl) {\n                                    Vd_ud[i] = Mem_vc.as<uint64_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


Fault
Vlseg5e64_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    uint32_t mem_size = width_EEW(machInst.width) / 8 * microVl;

    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint64_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);

    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = xc->readMem(EA, Mem.as<uint8_t>(), mem_size, memAccessFlags,
                              byte_enable);

    if (fault != NoFault)
        return fault;

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;

    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 5)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint64_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return fault;
}



Fault
Vlseg5e64_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;
    uint32_t mem_size = width_EEW(this->machInst.width) / 8 * this->microVl;

    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = initiateMemRead(xc, EA, mem_size, memAccessFlags,
                                  byte_enable);
    return fault;
}



Fault
Vlseg5e64_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint64_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    // tail/mask policy: both undisturbed if one is, 1s if none
    
    if (!machInst.vtype8.vta || (!machInst.vm && !machInst.vtype8.vma)) {
        RiscvISA::vreg_t old_vd;
        xc->getRegOperand(this, 1, &old_vd);
        tmp_d0 = old_vd;
    } else {
        tmp_d0.set(0xff);
    }
    

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;
    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 5)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint64_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// VlSegOp::vlseg6e64_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 6)) &&\n                                    i < this->microVl) {\n                                    Vd_ud[i] = Mem_vc.as<uint64_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


Fault
Vlseg6e64_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    uint32_t mem_size = width_EEW(machInst.width) / 8 * microVl;

    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint64_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);

    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = xc->readMem(EA, Mem.as<uint8_t>(), mem_size, memAccessFlags,
                              byte_enable);

    if (fault != NoFault)
        return fault;

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;

    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 6)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint64_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return fault;
}



Fault
Vlseg6e64_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;
    uint32_t mem_size = width_EEW(this->machInst.width) / 8 * this->microVl;

    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = initiateMemRead(xc, EA, mem_size, memAccessFlags,
                                  byte_enable);
    return fault;
}



Fault
Vlseg6e64_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint64_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    // tail/mask policy: both undisturbed if one is, 1s if none
    
    if (!machInst.vtype8.vta || (!machInst.vm && !machInst.vtype8.vma)) {
        RiscvISA::vreg_t old_vd;
        xc->getRegOperand(this, 1, &old_vd);
        tmp_d0 = old_vd;
    } else {
        tmp_d0.set(0xff);
    }
    

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;
    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 6)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint64_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// VlSegOp::vlseg7e64_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 7)) &&\n                                    i < this->microVl) {\n                                    Vd_ud[i] = Mem_vc.as<uint64_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


Fault
Vlseg7e64_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    uint32_t mem_size = width_EEW(machInst.width) / 8 * microVl;

    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint64_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);

    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = xc->readMem(EA, Mem.as<uint8_t>(), mem_size, memAccessFlags,
                              byte_enable);

    if (fault != NoFault)
        return fault;

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;

    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 7)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint64_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return fault;
}



Fault
Vlseg7e64_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;
    uint32_t mem_size = width_EEW(this->machInst.width) / 8 * this->microVl;

    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = initiateMemRead(xc, EA, mem_size, memAccessFlags,
                                  byte_enable);
    return fault;
}



Fault
Vlseg7e64_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint64_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    // tail/mask policy: both undisturbed if one is, 1s if none
    
    if (!machInst.vtype8.vta || (!machInst.vm && !machInst.vtype8.vma)) {
        RiscvISA::vreg_t old_vd;
        xc->getRegOperand(this, 1, &old_vd);
        tmp_d0 = old_vd;
    } else {
        tmp_d0.set(0xff);
    }
    

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;
    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 7)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint64_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// VlSegOp::vlseg8e64_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 8)) &&\n                                    i < this->microVl) {\n                                    Vd_ud[i] = Mem_vc.as<uint64_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


Fault
Vlseg8e64_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    uint32_t mem_size = width_EEW(machInst.width) / 8 * microVl;

    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint64_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);

    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = xc->readMem(EA, Mem.as<uint8_t>(), mem_size, memAccessFlags,
                              byte_enable);

    if (fault != NoFault)
        return fault;

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;

    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 8)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint64_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return fault;
}



Fault
Vlseg8e64_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;
    uint32_t mem_size = width_EEW(this->machInst.width) / 8 * this->microVl;

    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);

    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vlseg inst");

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = initiateMemRead(xc, EA, mem_size, memAccessFlags,
                                  byte_enable);
    return fault;
}



Fault
Vlseg8e64_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint64_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    // tail/mask policy: both undisturbed if one is, 1s if none
    
    if (!machInst.vtype8.vta || (!machInst.vm && !machInst.vtype8.vma)) {
        RiscvISA::vreg_t old_vd;
        xc->getRegOperand(this, 1, &old_vd);
        tmp_d0 = old_vd;
    } else {
        tmp_d0.set(0xff);
    }
    

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());

    const size_t micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const size_t micro_elems = vlen / width_EEW(machInst.width);

    size_t ei;
    for (size_t i = 0; i < micro_elems; i++) {
        ei = i + micro_vlmax * microIdx;
        
                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 8)) &&
                                    i < this->microVl) {
                                    Vd[i] = Mem.as<uint64_t>()[i];
                                }
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// Unknown::unknown(([], {}))

// VlWholeOp::vl1re64_v(['\n                                Vd_ud[i] = Mem_vc.as<uint64_t>()[i];\n                            '],{'inst_flags': 'SimdWholeRegisterLoadOp'})


Fault
Vl1re64_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint64_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    Fault fault = readMemAtomicLE(xc, traceData, EA,
                            *(vreg_t::Container*)(&Mem), vlenb,
                            memAccessFlags);
    if (fault != NoFault)
        return fault;

    size_t elem_per_reg = vlen / width_EEW(machInst.width);
    for (size_t i = 0; i < elem_per_reg; i++) {
        
                                Vd[i] = Mem.as<uint64_t>()[i];
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}



Fault
Vl1re64_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    const std::vector<bool> byte_enable(vlenb, true);
    Fault fault = initiateMemRead(xc, EA, vlenb, memAccessFlags, byte_enable);
    return fault;
}



Fault
Vl1re64_vMicro::completeAcc(PacketPtr pkt, ExecContext* xc,
        trace::InstRecord* traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint64_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());

    size_t elem_per_reg = vlen / width_EEW(machInst.width);
    for (size_t i = 0; i < elem_per_reg; ++i) {
        
                                Vd[i] = Mem.as<uint64_t>()[i];
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// VlWholeOp::vl2re64_v(['\n                                Vd_ud[i] = Mem_vc.as<uint64_t>()[i];\n                            '],{'inst_flags': 'SimdWholeRegisterLoadOp'})


Fault
Vl2re64_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint64_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    Fault fault = readMemAtomicLE(xc, traceData, EA,
                            *(vreg_t::Container*)(&Mem), vlenb,
                            memAccessFlags);
    if (fault != NoFault)
        return fault;

    size_t elem_per_reg = vlen / width_EEW(machInst.width);
    for (size_t i = 0; i < elem_per_reg; i++) {
        
                                Vd[i] = Mem.as<uint64_t>()[i];
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}



Fault
Vl2re64_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    const std::vector<bool> byte_enable(vlenb, true);
    Fault fault = initiateMemRead(xc, EA, vlenb, memAccessFlags, byte_enable);
    return fault;
}



Fault
Vl2re64_vMicro::completeAcc(PacketPtr pkt, ExecContext* xc,
        trace::InstRecord* traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint64_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());

    size_t elem_per_reg = vlen / width_EEW(machInst.width);
    for (size_t i = 0; i < elem_per_reg; ++i) {
        
                                Vd[i] = Mem.as<uint64_t>()[i];
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// VlWholeOp::vl4re64_v(['\n                                Vd_ud[i] = Mem_vc.as<uint64_t>()[i];\n                            '],{'inst_flags': 'SimdWholeRegisterLoadOp'})


Fault
Vl4re64_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint64_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    Fault fault = readMemAtomicLE(xc, traceData, EA,
                            *(vreg_t::Container*)(&Mem), vlenb,
                            memAccessFlags);
    if (fault != NoFault)
        return fault;

    size_t elem_per_reg = vlen / width_EEW(machInst.width);
    for (size_t i = 0; i < elem_per_reg; i++) {
        
                                Vd[i] = Mem.as<uint64_t>()[i];
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}



Fault
Vl4re64_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    const std::vector<bool> byte_enable(vlenb, true);
    Fault fault = initiateMemRead(xc, EA, vlenb, memAccessFlags, byte_enable);
    return fault;
}



Fault
Vl4re64_vMicro::completeAcc(PacketPtr pkt, ExecContext* xc,
        trace::InstRecord* traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint64_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());

    size_t elem_per_reg = vlen / width_EEW(machInst.width);
    for (size_t i = 0; i < elem_per_reg; ++i) {
        
                                Vd[i] = Mem.as<uint64_t>()[i];
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// VlWholeOp::vl8re64_v(['\n                                Vd_ud[i] = Mem_vc.as<uint64_t>()[i];\n                            '],{'inst_flags': 'SimdWholeRegisterLoadOp'})


Fault
Vl8re64_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint64_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    Fault fault = readMemAtomicLE(xc, traceData, EA,
                            *(vreg_t::Container*)(&Mem), vlenb,
                            memAccessFlags);
    if (fault != NoFault)
        return fault;

    size_t elem_per_reg = vlen / width_EEW(machInst.width);
    for (size_t i = 0; i < elem_per_reg; i++) {
        
                                Vd[i] = Mem.as<uint64_t>()[i];
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}



Fault
Vl8re64_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    const std::vector<bool> byte_enable(vlenb, true);
    Fault fault = initiateMemRead(xc, EA, vlenb, memAccessFlags, byte_enable);
    return fault;
}



Fault
Vl8re64_vMicro::completeAcc(PacketPtr pkt, ExecContext* xc,
        trace::InstRecord* traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint64_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());

    size_t elem_per_reg = vlen / width_EEW(machInst.width);
    for (size_t i = 0; i < elem_per_reg; ++i) {
        
                                Vd[i] = Mem.as<uint64_t>()[i];
                            ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// Unknown::unknown(([], {}))

// VleOp::vle64ff_v((['\n                        if ((machInst.vm || elem_mask(v0, ei)) &&\n                            i < this->microVl && i < this->faultIdx) {\n                            Vd_ud[i] = Mem_vc.as<uint64_t>()[i];\n                        }\n                    '], {'inst_flags': 'SimdUnitStrideFaultOnlyFirstLoadOp'}))


Fault
Vle64ff_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    uint64_t Rs1 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint64_t>();
Rs1 = xc->getRegOperand(this, 0);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);

    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint32_t mem_size = width_EEW(machInst.width) / 8 * this->microVl;

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = xc->readMem(EA, Mem.as<uint8_t>(), mem_size, memAccessFlags,
                              byte_enable);

    
    Addr fault_addr;
    if (fault != NoFault && getFaultVAddr(fault, fault_addr)) {
        assert(fault_addr >= EA);
        faultIdx = (fault_addr - EA) / (width_EEW(machInst.width) / 8);
        if (microIdx != 0 || faultIdx != 0) {
            fault = NoFault;
            trimVl = true;
        }
    }
    ;

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    if (fault != NoFault)
        return fault;

    size_t ei;

    for (size_t i = 0; i < micro_vlmax; i++) {
        ei = i + micro_vlmax * microIdx;
        
                        if ((machInst.vm || elem_mask(v0, ei)) &&
                            i < this->microVl && i < this->faultIdx) {
                            Vd[i] = Mem.as<uint64_t>()[i];
                        }
                    ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return fault;
}



Fault
Vle64ff_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;

    uint64_t Rs1 = 0;
;
    Rs1 = xc->getRegOperand(this, 0);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    uint32_t mem_size = width_EEW(this->machInst.width) / 8 * this->microVl;

    const std::vector<bool> byte_enable(mem_size, true);
    Fault fault = initiateMemRead(xc, EA, mem_size, memAccessFlags,
                                  byte_enable);

    
    Addr fault_addr;
    if (fault != NoFault && getFaultVAddr(fault, fault_addr)) {
        assert(fault_addr >= EA);
        faultIdx = (fault_addr - EA) / (width_EEW(machInst.width) / 8);
        if (microIdx != 0 || faultIdx != 0) {
            fault = NoFault;
            trimVl = true;
        }
    }
    ;

    return fault;
}



Fault
Vle64ff_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint64_t>();
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    // tail/mask policy: both undisturbed if one is, 1s if none
    
    if (!machInst.vtype8.vta || (!machInst.vm && !machInst.vtype8.vma)) {
        RiscvISA::vreg_t old_vd;
        xc->getRegOperand(this, 1, &old_vd);
        tmp_d0 = old_vd;
    } else {
        tmp_d0.set(0xff);
    }
    

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    if (xc->readMemAccPredicate()) {
        memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());
    }

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    size_t ei;
    for (size_t i = 0; i < micro_vlmax; i++) {
        ei = i + micro_vlmax * microIdx;
        
                        if ((machInst.vm || elem_mask(v0, ei)) &&
                            i < this->microVl && i < this->faultIdx) {
                            Vd[i] = Mem.as<uint64_t>()[i];
                        }
                    ;
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// Unknown::unknown(([], {}))

// VlIndexOp::vluxei64_v((['\n                    Vd_vu[vdElemIdx] = Mem_vc.as<vu>()[0];\n                ', '\n                    EA = Rs1 + Vs2_ud[vs2ElemIdx];\n                '], {'inst_flags': 'SimdIndexedLoadOp'}))


template<typename ElemType>
Fault
Vluxei64_vMicro<ElemType>::execute(ExecContext *xc,
    trace::InstRecord *traceData)const
{
    using vu = std::make_unsigned_t<ElemType>;
    Fault fault = NoFault;
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    uint64_t Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<uint64_t>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
                    EA = Rs1 + Vs2[vs2ElemIdx];
                ;
    constexpr uint8_t elem_size = sizeof(Vd[0]);
    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint32_t mem_size = elem_size;
    const std::vector<bool> byte_enable(mem_size, true);
    size_t ei = this->vdRegIdx * vlenb / elem_size + this->vdElemIdx;
    if (machInst.vm || elem_mask(v0, ei)) {
        fault = xc->readMem(EA, Mem.as<uint8_t>(), mem_size,
                                memAccessFlags, byte_enable);
        if (fault != NoFault)
            return fault;
        
                    Vd[vdElemIdx] = Mem.as<vu>()[0];
                ; /* Vd[this->vdElemIdx] = Mem[0]; */
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return fault;
}



template<typename ElemType>
Fault
Vluxei64_vMicro<ElemType>::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    using vu = std::make_unsigned_t<ElemType>;
    Fault fault = NoFault;
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    uint64_t Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<uint64_t>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    constexpr uint8_t elem_size = sizeof(Vd[0]);
    
                    EA = Rs1 + Vs2[vs2ElemIdx];
                ; // ea_code depends on elem_size

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint32_t mem_size = elem_size;

    size_t ei = this->vdRegIdx * vlenb / elem_size + this->vdElemIdx;
    bool need_load = machInst.vm || elem_mask(v0, ei);
    const std::vector<bool> byte_enable(mem_size, need_load);
    fault = initiateMemRead(xc, EA, mem_size, memAccessFlags, byte_enable);
    return fault;
}



template<typename ElemType>
Fault
Vluxei64_vMicro<ElemType>::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    using vu = std::make_unsigned_t<ElemType>;
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    constexpr uint8_t elem_size = sizeof(Vd[0]);

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    size_t ei = this->vdRegIdx * vlenb / elem_size + this->vdElemIdx;
    if (machInst.vm || elem_mask(v0, ei)) {
        memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());
        
                    Vd[vdElemIdx] = Mem.as<vu>()[0];
                ; /* Vd[this->microIdx] = Mem[0]; */
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


    template class Vluxei64_vMicro<uint8_t>;
    template class Vluxei64_vMicro<uint16_t>;
    template class Vluxei64_vMicro<uint32_t>;
    template class Vluxei64_vMicro<uint64_t>;
    ;


// VlStrideOp::vlse64_v((['\n                    Vd_ud[microIdx] = Mem_vc.as<uint64_t>()[0];\n                '], {'inst_flags': 'SimdStridedLoadOp'}))


Fault
Vlse64_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Fault fault = NoFault;
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint64_t>();
Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    constexpr uint8_t elem_size = sizeof(Vd[0]);
    
        EA = Rs1 + Rs2 * (regIdx * vlenb / elem_size + microIdx);
    ; // ea_code depends on elem_size

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint32_t mem_size = elem_size;
    const std::vector<bool> byte_enable(mem_size, true);

    size_t ei = this->regIdx * vlenb / elem_size + this->microIdx;
    if (machInst.vm || elem_mask(v0, ei)) {
        fault = xc->readMem(EA, Mem.as<uint8_t>(), mem_size,
                                memAccessFlags, byte_enable);
        if (fault != NoFault)
            return fault;
        
                    Vd[microIdx] = Mem.as<uint64_t>()[0];
                ; /* Vd[this->microIdx] = Mem[0]; */
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return fault;
}



Fault
Vlse64_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    Fault fault = NoFault;
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint64_t>();
Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    constexpr uint8_t elem_size = sizeof(Vd[0]);
    
        EA = Rs1 + Rs2 * (regIdx * vlenb / elem_size + microIdx);
    ; // ea_code depends on elem_size

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint32_t mem_size = elem_size;
    size_t ei = this->regIdx * vlenb / elem_size + this->microIdx;
    bool need_load = machInst.vm || elem_mask(v0, ei);
    const std::vector<bool> byte_enable(mem_size, need_load);
    fault = initiateMemRead(xc, EA, mem_size, memAccessFlags, byte_enable);
    return fault;
}



Fault
Vlse64_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint64_t>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    size_t ei = this->regIdx * vlenb / sizeof(Vd[0]) + this->microIdx;
    if (machInst.vm || elem_mask(v0, ei)) {
        memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());
        
                    Vd[microIdx] = Mem.as<uint64_t>()[0];
                ; /* Vd[this->microIdx] = Mem[0]; */
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// VlIndexOp::vloxei64_v((['\n                    Vd_vu[vdElemIdx] = Mem_vc.as<vu>()[0];\n                ', '\n                    EA = Rs1 + Vs2_ud[vs2ElemIdx];\n                '], {'inst_flags': 'SimdIndexedLoadOp'}))


template<typename ElemType>
Fault
Vloxei64_vMicro<ElemType>::execute(ExecContext *xc,
    trace::InstRecord *traceData)const
{
    using vu = std::make_unsigned_t<ElemType>;
    Fault fault = NoFault;
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    uint64_t Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<uint64_t>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
                    EA = Rs1 + Vs2[vs2ElemIdx];
                ;
    constexpr uint8_t elem_size = sizeof(Vd[0]);
    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint32_t mem_size = elem_size;
    const std::vector<bool> byte_enable(mem_size, true);
    size_t ei = this->vdRegIdx * vlenb / elem_size + this->vdElemIdx;
    if (machInst.vm || elem_mask(v0, ei)) {
        fault = xc->readMem(EA, Mem.as<uint8_t>(), mem_size,
                                memAccessFlags, byte_enable);
        if (fault != NoFault)
            return fault;
        
                    Vd[vdElemIdx] = Mem.as<vu>()[0];
                ; /* Vd[this->vdElemIdx] = Mem[0]; */
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return fault;
}



template<typename ElemType>
Fault
Vloxei64_vMicro<ElemType>::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    using vu = std::make_unsigned_t<ElemType>;
    Fault fault = NoFault;
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    uint64_t Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<uint64_t>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    constexpr uint8_t elem_size = sizeof(Vd[0]);
    
                    EA = Rs1 + Vs2[vs2ElemIdx];
                ; // ea_code depends on elem_size

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint32_t mem_size = elem_size;

    size_t ei = this->vdRegIdx * vlenb / elem_size + this->vdElemIdx;
    bool need_load = machInst.vm || elem_mask(v0, ei);
    const std::vector<bool> byte_enable(mem_size, need_load);
    fault = initiateMemRead(xc, EA, mem_size, memAccessFlags, byte_enable);
    return fault;
}



template<typename ElemType>
Fault
Vloxei64_vMicro<ElemType>::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    using vu = std::make_unsigned_t<ElemType>;
    RiscvISA::VecRegContainer Mem = {};
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    constexpr uint8_t elem_size = sizeof(Vd[0]);

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    size_t ei = this->vdRegIdx * vlenb / elem_size + this->vdElemIdx;
    if (machInst.vm || elem_mask(v0, ei)) {
        memcpy(Mem.as<uint8_t>(), pkt->getPtr<uint8_t>(), pkt->getSize());
        
                    Vd[vdElemIdx] = Mem.as<vu>()[0];
                ; /* Vd[this->microIdx] = Mem[0]; */
    }

    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


    template class Vloxei64_vMicro<uint8_t>;
    template class Vloxei64_vMicro<uint16_t>;
    template class Vloxei64_vMicro<uint32_t>;
    template class Vloxei64_vMicro<uint64_t>;
    ;


// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// FenceOp::fence(['\n                ', 'uint64_t', 'IsReadBarrier', 'IsWriteBarrier', 'No_OpClass'],{})

    Fault
    Fence::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        ;
        ;
        
                ;
        ;
        return NoFault;
    }

    std::string
    Fence::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::stringstream ss;
        ss << mnemonic;
        if (!FUNCT3) {
            ss << ' ';
            if (PRED & 0x8)
                ss << 'i';
            if (PRED & 0x4)
                ss << 'o';
            if (PRED & 0x2)
                ss << 'r';
            if (PRED & 0x1)
                ss << 'w';
            ss << ", ";
            if (SUCC & 0x8)
                ss << 'i';
            if (SUCC & 0x4)
                ss << 'o';
            if (SUCC & 0x2)
                ss << 'r';
            if (SUCC & 0x1)
                ss << 'w';
        }
        return ss.str();
    }

// FenceOp::fence_i(['\n                ', 'uint64_t', 'IsNonSpeculative', 'IsSerializeAfter', 'IsSquashAfter', 'No_OpClass'],{})

    Fault
    Fence_i::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        ;
        ;
        
                ;
        ;
        return NoFault;
    }

    std::string
    Fence_i::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::stringstream ss;
        ss << mnemonic;
        if (!FUNCT3) {
            ss << ' ';
            if (PRED & 0x8)
                ss << 'i';
            if (PRED & 0x4)
                ss << 'o';
            if (PRED & 0x2)
                ss << 'r';
            if (PRED & 0x1)
                ss << 'w';
            ss << ", ";
            if (SUCC & 0x8)
                ss << 'i';
            if (SUCC & 0x4)
                ss << 'o';
            if (SUCC & 0x2)
                ss << 'r';
            if (SUCC & 0x1)
                ss << 'w';
        }
        return ss.str();
    }

// CBMOp::cbo_inval(['\n                        SENVCFG senvcfg = xc->readMiscReg(MISCREG_SENVCFG);\n                        auto pm = (PrivilegeMode)xc->readMiscReg(\n                                MISCREG_PRV);\n\n                        if (pm == PRV_U) {\n                            if (senvcfg.cbie == 0) {\n                                return std::make_shared<IllegalInstFault>(\n                                        "Can\'t execute cbo.clean in current "\n                                        "privilege mode!", machInst);\n                            }\n                            else if (senvcfg.cbie == 1){ //flush\n                                Mem = 0;\n                            }\n                            else if (senvcfg.cbie == 3) { // invalidate\n                                Mem = 0;\n                            } else { //sebvcfg.cbie == 2, reserved\n                                return std::make_shared<IllegalInstFault>(\n                                        "Invalid value for senvcfg.cbie!",\n                                        machInst);\n                            }\n                        } else if (pm == PRV_M){ // all invalidate\n                            Mem = 0;\n                        } else if (pm == PRV_S) {\n                            // whether it\'s a flush or invalidate depends on\n                            // menvcfg (01 and 11 respectively)\n                            Mem = 0;\n                        }\n                    '],{'mem_flags': ['INVALIDATE', 'DST_POC']})

    Fault
    Cbo_inval::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        EA = rvSext(Rs1);;

        Addr cacheBlockSize = xc->tcBase()->getCpuPtr()->cacheLineSize();
        uint64_t numOffsetBits = floorLog2(cacheBlockSize);
        EA = (EA >> numOffsetBits) << numOffsetBits;

        {
            Fault fault =
                writeMemAtomic(xc, nullptr, EA, cacheBlockSize, memAccessFlags,
                    nullptr, std::vector<bool>(cacheBlockSize, true));
            if (fault != NoFault)
                return fault;
        }

        return NoFault;
    }

    Fault
    Cbo_inval::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        EA = rvSext(Rs1);;

        Addr cacheBlockSize = xc->tcBase()->getCpuPtr()->cacheLineSize();
        uint64_t numOffsetBits = floorLog2(cacheBlockSize);
        EA = (EA >> numOffsetBits) << numOffsetBits;

        {
            Fault fault =
                writeMemTiming(xc, nullptr, EA, cacheBlockSize, memAccessFlags,
                    nullptr, std::vector<bool>(cacheBlockSize, true));
            if (fault != NoFault)
                return fault;
        }

        return NoFault;
    }

    Fault
    Cbo_inval::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        return NoFault;
    }

// CBMOp::cbo_clean(['\n                        SENVCFG senvcfg = xc->readMiscReg(MISCREG_SENVCFG);\n                        auto pm = (PrivilegeMode)xc->readMiscReg(\n                                MISCREG_PRV);\n\n                        if (pm == PRV_U && !senvcfg.cbcfe){\n                            return std::make_shared<IllegalInstFault>(\n                                        "Can\'t execute cbo.clean in current "\n                                        "privilege mode!", machInst);\n                        // the specification has more conditions/privilege\n                        // modes to check, but menvcfg and henvcfg are not\n                        // implemented\n                        } else {\n                            Mem = 0;\n                        }\n                    '],{'mem_flags': ['CLEAN', 'DST_POC']})

    Fault
    Cbo_clean::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        EA = rvSext(Rs1);;

        Addr cacheBlockSize = xc->tcBase()->getCpuPtr()->cacheLineSize();
        uint64_t numOffsetBits = floorLog2(cacheBlockSize);
        EA = (EA >> numOffsetBits) << numOffsetBits;

        {
            Fault fault =
                writeMemAtomic(xc, nullptr, EA, cacheBlockSize, memAccessFlags,
                    nullptr, std::vector<bool>(cacheBlockSize, true));
            if (fault != NoFault)
                return fault;
        }

        return NoFault;
    }

    Fault
    Cbo_clean::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        EA = rvSext(Rs1);;

        Addr cacheBlockSize = xc->tcBase()->getCpuPtr()->cacheLineSize();
        uint64_t numOffsetBits = floorLog2(cacheBlockSize);
        EA = (EA >> numOffsetBits) << numOffsetBits;

        {
            Fault fault =
                writeMemTiming(xc, nullptr, EA, cacheBlockSize, memAccessFlags,
                    nullptr, std::vector<bool>(cacheBlockSize, true));
            if (fault != NoFault)
                return fault;
        }

        return NoFault;
    }

    Fault
    Cbo_clean::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        return NoFault;
    }

// CBMOp::cbo_flush(['\n                        SENVCFG senvcfg = xc->readMiscReg(MISCREG_SENVCFG);\n                        auto pm = (PrivilegeMode)xc->readMiscReg(\n                                MISCREG_PRV);\n\n                        if (pm == PRV_U && !senvcfg.cbcfe){\n                            return std::make_shared<IllegalInstFault>(\n                                        "Can\'t execute cbo.flush in current "\n                                        "privilege mode!", machInst);\n                        // the specification has more conditions/privilege\n                        // modes to check, but menvcfg and henvcfg are not\n                        // implemented\n                        } else {\n                            Mem = 0;\n                        }\n                    '],{'mem_flags': ['CLEAN', 'INVALIDATE', 'DST_POC']})

    Fault
    Cbo_flush::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        EA = rvSext(Rs1);;

        Addr cacheBlockSize = xc->tcBase()->getCpuPtr()->cacheLineSize();
        uint64_t numOffsetBits = floorLog2(cacheBlockSize);
        EA = (EA >> numOffsetBits) << numOffsetBits;

        {
            Fault fault =
                writeMemAtomic(xc, nullptr, EA, cacheBlockSize, memAccessFlags,
                    nullptr, std::vector<bool>(cacheBlockSize, true));
            if (fault != NoFault)
                return fault;
        }

        return NoFault;
    }

    Fault
    Cbo_flush::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        EA = rvSext(Rs1);;

        Addr cacheBlockSize = xc->tcBase()->getCpuPtr()->cacheLineSize();
        uint64_t numOffsetBits = floorLog2(cacheBlockSize);
        EA = (EA >> numOffsetBits) << numOffsetBits;

        {
            Fault fault =
                writeMemTiming(xc, nullptr, EA, cacheBlockSize, memAccessFlags,
                    nullptr, std::vector<bool>(cacheBlockSize, true));
            if (fault != NoFault)
                return fault;
        }

        return NoFault;
    }

    Fault
    Cbo_flush::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        return NoFault;
    }

// CBMOp::cbo_zero(['\n                        SENVCFG senvcfg = xc->readMiscReg(MISCREG_SENVCFG);\n                        auto pm = (PrivilegeMode)xc->readMiscReg(\n                                MISCREG_PRV);\n\n                        if (pm == PRV_U && !senvcfg.cbze){\n                            return std::make_shared<IllegalInstFault>(\n                                        "Can\'t execute cbo.zero in current "\n                                        "privilege mode!", machInst);\n                        // the specification has more conditions/privilege\n                        // modes to check, but menvcfg and henvcfg are not\n                        // implemented\n                        } else {\n                            Mem = 0;\n                        }\n                    '],{'mem_flags': ['CACHE_BLOCK_ZERO']})

    Fault
    Cbo_zero::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        EA = rvSext(Rs1);;

        Addr cacheBlockSize = xc->tcBase()->getCpuPtr()->cacheLineSize();
        uint64_t numOffsetBits = floorLog2(cacheBlockSize);
        EA = (EA >> numOffsetBits) << numOffsetBits;

        {
            Fault fault =
                writeMemAtomic(xc, nullptr, EA, cacheBlockSize, memAccessFlags,
                    nullptr, std::vector<bool>(cacheBlockSize, true));
            if (fault != NoFault)
                return fault;
        }

        return NoFault;
    }

    Fault
    Cbo_zero::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        EA = rvSext(Rs1);;

        Addr cacheBlockSize = xc->tcBase()->getCpuPtr()->cacheLineSize();
        uint64_t numOffsetBits = floorLog2(cacheBlockSize);
        EA = (EA >> numOffsetBits) << numOffsetBits;

        {
            Fault fault =
                writeMemTiming(xc, nullptr, EA, cacheBlockSize, memAccessFlags,
                    nullptr, std::vector<bool>(cacheBlockSize, true));
            if (fault != NoFault)
                return fault;
        }

        return NoFault;
    }

    Fault
    Cbo_zero::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        return NoFault;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// IOp::slli(['\n                        if (rvSelect((bool)SHAMT6BIT5, false)) {\n                            return std::make_shared<IllegalInstFault>(\n                                    "shmat[5] != 0", machInst);\n                        }\n                        Rd = rvSext(Rs1 << imm);\n                    '],{'imm_type': 'uint64_t', 'imm_code': ' imm = SHAMT6; '})

    Fault
    Slli::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        
                        if (rvSelect((bool)SHAMT6BIT5, false)) {
                            return std::make_shared<IllegalInstFault>(
                                    "shmat[5] != 0", machInst);
                        }
                        Rd = rvSext(Rs1 << imm);
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    Slli::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// IOp::zip(['\n                            Rd_sw = _rvk_emu_zip_32(Rs1_sw);\n                        '],{'imm_code': ' imm = SHAMT5; '})

    Fault
    Zip::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        int32_t Rd = 0;
int32_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        
                            Rd = _rvk_emu_zip_32(Rs1);
                        ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    Zip::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// Unknown::unknown(([], {}))

// IOp::sha256sum0(['\n                            Rd_sw = _rvk_emu_sha256sum0(Rs1_sw);\n                        '],{})

    Fault
    Sha256sum0::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        int32_t Rd = 0;
int32_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        
                            Rd = _rvk_emu_sha256sum0(Rs1);
                        ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    Sha256sum0::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// IOp::sha256sum1(['\n                            Rd_sw = _rvk_emu_sha256sum1(Rs1_sw);\n                        '],{})

    Fault
    Sha256sum1::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        int32_t Rd = 0;
int32_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        
                            Rd = _rvk_emu_sha256sum1(Rs1);
                        ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    Sha256sum1::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// IOp::sha256sig0(['\n                            Rd_sw = _rvk_emu_sha256sig0(Rs1_sw);\n                        '],{})

    Fault
    Sha256sig0::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        int32_t Rd = 0;
int32_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        
                            Rd = _rvk_emu_sha256sig0(Rs1);
                        ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    Sha256sig0::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// IOp::sha256sig1(['\n                            Rd_sw = _rvk_emu_sha256sig1(Rs1_sw);\n                        '],{})

    Fault
    Sha256sig1::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        int32_t Rd = 0;
int32_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        
                            Rd = _rvk_emu_sha256sig1(Rs1);
                        ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    Sha256sig1::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// IOp::sha512sum0(['\n                                Rd_sd = _rvk_emu_sha512sum0(Rs1_sd);\n                            '],{})

    Fault
    Sha512sum0::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int64_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        
                                Rd = _rvk_emu_sha512sum0(Rs1);
                            ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    Sha512sum0::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// Unknown::unknown(([], {}))

// IOp::sha512sum1(['\n                                Rd_sd = _rvk_emu_sha512sum1(Rs1_sd);\n                            '],{})

    Fault
    Sha512sum1::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int64_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        
                                Rd = _rvk_emu_sha512sum1(Rs1);
                            ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    Sha512sum1::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// Unknown::unknown(([], {}))

// IOp::sha512sig0(['\n                                Rd_sd = _rvk_emu_sha512sig0(Rs1_sd);\n                            '],{})

    Fault
    Sha512sig0::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int64_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        
                                Rd = _rvk_emu_sha512sig0(Rs1);
                            ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    Sha512sig0::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// Unknown::unknown(([], {}))

// IOp::sha512sig1(['\n                                Rd_sd = _rvk_emu_sha512sig1(Rs1_sd);\n                            '],{})

    Fault
    Sha512sig1::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int64_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        
                                Rd = _rvk_emu_sha512sig1(Rs1);
                            ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    Sha512sig1::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// Unknown::unknown(([], {}))

// IOp::sm3p0(['\n                            Rd_sw = _rvk_emu_sm3p0(Rs1_sw);\n                        '],{})

    Fault
    Sm3p0::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        int32_t Rd = 0;
int32_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        
                            Rd = _rvk_emu_sm3p0(Rs1);
                        ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    Sm3p0::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// IOp::sm3p1(['\n                            Rd_sw = _rvk_emu_sm3p1(Rs1_sw);\n                        '],{})

    Fault
    Sm3p1::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        int32_t Rd = 0;
int32_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        
                            Rd = _rvk_emu_sm3p1(Rs1);
                        ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    Sm3p1::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// Unknown::unknown(([], {}))

// IOp::bseti(['\n                        if (rvSelect((bool)SHAMT6BIT5, false)) {\n                            return std::make_shared<IllegalInstFault>(\n                                    "shmat[5] != 0", machInst);\n                        }\n                        uint64_t index = imm & rvSelect(32 - 1, 64 - 1);\n                        Rd = rvSext(Rs1 | (UINT64_C(1) << index));\n                    '],{'imm_type': 'uint64_t', 'imm_code': ' imm = SHAMT6; '})

    Fault
    Bseti::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        
                        if (rvSelect((bool)SHAMT6BIT5, false)) {
                            return std::make_shared<IllegalInstFault>(
                                    "shmat[5] != 0", machInst);
                        }
                        uint64_t index = imm & rvSelect(32 - 1, 64 - 1);
                        Rd = rvSext(Rs1 | (UINT64_C(1) << index));
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    Bseti::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// IOp::aes64im(['\n                                Rd_sd = _rvk_emu_aes64im(Rs1_sd);\n                            '],{})

    Fault
    Aes64im::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int64_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        
                                Rd = _rvk_emu_aes64im(Rs1);
                            ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    Aes64im::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// Unknown::unknown(([], {}))

// IOp::aes64ks1i(['\n                                Rd_sd = _rvk_emu_aes64ks1i(Rs1_sd, imm);\n                            '],{'imm_type': 'int32_t', 'imm_code': ' imm = RNUM; '})

    Fault
    Aes64ks1i::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int64_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        
                                Rd = _rvk_emu_aes64ks1i(Rs1, imm);
                            ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    Aes64ks1i::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// IOp::bclri(['\n                        if (rvSelect((bool)SHAMT6BIT5, false)) {\n                            return std::make_shared<IllegalInstFault>(\n                                    "shmat[5] != 0", machInst);\n                        }\n                        uint64_t index = imm & rvSelect(32 - 1, 64 - 1);\n                        Rd = rvSext(Rs1 & (~(UINT64_C(1) << index)));\n                    '],{'imm_type': 'uint64_t', 'imm_code': ' imm = SHAMT6; '})

    Fault
    Bclri::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        
                        if (rvSelect((bool)SHAMT6BIT5, false)) {
                            return std::make_shared<IllegalInstFault>(
                                    "shmat[5] != 0", machInst);
                        }
                        uint64_t index = imm & rvSelect(32 - 1, 64 - 1);
                        Rd = rvSext(Rs1 & (~(UINT64_C(1) << index)));
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    Bclri::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// IOp::binvi(['\n                        if (rvSelect((bool)SHAMT6BIT5, false)) {\n                            return std::make_shared<IllegalInstFault>(\n                                    "shmat[5] != 0", machInst);\n                        }\n                        uint64_t index = imm & rvSelect(32 - 1, 64 - 1);\n                        Rd = rvSext(Rs1 ^ (UINT64_C(1) << index));\n                    '],{'imm_type': 'uint64_t', 'imm_code': ' imm = SHAMT6; '})

    Fault
    Binvi::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        
                        if (rvSelect((bool)SHAMT6BIT5, false)) {
                            return std::make_shared<IllegalInstFault>(
                                    "shmat[5] != 0", machInst);
                        }
                        uint64_t index = imm & rvSelect(32 - 1, 64 - 1);
                        Rd = rvSext(Rs1 ^ (UINT64_C(1) << index));
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    Binvi::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// ROp::clz(['\n                            Rd = (machInst.rv_type == RV32) ? clz32(Rs1) : clz64(Rs1);\n                        '],{})

    Fault
    Clz::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        
                            Rd = (machInst.rv_type == RV32) ? clz32(Rs1) : clz64(Rs1);
                        ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::ctz(['\n                            Rd = (machInst.rv_type == RV32) ? ctz32(Rs1) : ctz64(Rs1);\n                        '],{})

    Fault
    Ctz::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        
                            Rd = (machInst.rv_type == RV32) ? ctz32(Rs1) : ctz64(Rs1);
                        ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::cpop(['\n                            Rd = (machInst.rv_type == RV32) ? popCount(Rs1<31:0>) : popCount(Rs1);\n                        '],{})

    Fault
    Cpop::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        
                            Rd = (machInst.rv_type == RV32) ? popCount(bits(Rs1, 31, 0)) : popCount(Rs1);
                        ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::sext_b(['\n                            Rd = sext<8>(Rs1_ub);\n                        '],{})

    Fault
    Sext_b::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint8_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        
                            Rd = sext<8>(Rs1);
                        ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::sext_h(['\n                            Rd = sext<16>(Rs1_uh);\n                        '],{})

    Fault
    Sext_h::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint16_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        
                            Rd = sext<16>(Rs1);
                        ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// IOp::addi(['\n                    Rd_sd = rvSext(Rs1_sd + imm);\n                '],{})

    Fault
    Addi::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int64_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        
                    Rd = rvSext(Rs1 + imm);
                ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    Addi::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// IOp::slti(['\n                    Rd = (rvSext(Rs1_sd) < imm) ? 1 : 0;\n                '],{})

    Fault
    Slti::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
int64_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        
                    Rd = (rvSext(Rs1) < imm) ? 1 : 0;
                ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    Slti::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// IOp::sltiu(['\n                    Rd = (rvZext(Rs1) < imm) ? 1 : 0;\n                ', 'uint64_t'],{'imm_code': ' imm = rvZext(sext<12>(IMM12)); '})

    Fault
    Sltiu::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        
                    Rd = (rvZext(Rs1) < imm) ? 1 : 0;
                ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    Sltiu::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// IOp::xori(['\n                    Rd = rvSext(Rs1 ^ imm);\n                ', 'uint64_t'],{})

    Fault
    Xori::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        
                    Rd = rvSext(Rs1 ^ imm);
                ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    Xori::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// IOp::srli(['\n                        if (rvSelect((bool)SHAMT6BIT5, false)) {\n                            return std::make_shared<IllegalInstFault>(\n                                    "shmat[5] != 0", machInst);\n                        }\n                        Rd = rvSext(rvZext(Rs1) >> imm);\n                    '],{'imm_type': 'uint64_t', 'imm_code': ' imm = SHAMT6; '})

    Fault
    Srli::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        
                        if (rvSelect((bool)SHAMT6BIT5, false)) {
                            return std::make_shared<IllegalInstFault>(
                                    "shmat[5] != 0", machInst);
                        }
                        Rd = rvSext(rvZext(Rs1) >> imm);
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    Srli::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// IOp::unzip(['\n                            Rd_sw = _rvk_emu_unzip_32(Rs1_sw);\n                        '],{'imm_code': ' imm = SHAMT5; '})

    Fault
    Unzip::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        int32_t Rd = 0;
int32_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        
                            Rd = _rvk_emu_unzip_32(Rs1);
                        ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    Unzip::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// Unknown::unknown(([], {}))

// IOp::orc_b(['\n                        uint64_t result = 0;\n                        result |= (Rs1<7:0> ? UINT64_C(0xff) : 0x0);\n                        result |= (Rs1<15:8> ? UINT64_C(0xff) : 0x0) << 8;\n                        result |= (Rs1<23:16> ? UINT64_C(0xff) : 0x0) << 16;\n                        result |= (Rs1<31:24> ? UINT64_C(0xff) : 0x0) << 24;\n                        result |= (Rs1<39:32> ? UINT64_C(0xff) : 0x0) << 32;\n                        result |= (Rs1<47:40> ? UINT64_C(0xff) : 0x0) << 40;\n                        result |= (Rs1<55:48> ? UINT64_C(0xff) : 0x0) << 48;\n                        result |= (Rs1<63:56> ? UINT64_C(0xff) : 0x0) << 56;\n                        Rd = rvSext(result);\n                    '],{'imm_type': 'uint64_t', 'imm_code': ' imm = SHAMT6; '})

    Fault
    Orc_b::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        
                        uint64_t result = 0;
                        result |= (bits(Rs1, 7, 0) ? UINT64_C(0xff) : 0x0);
                        result |= (bits(Rs1, 15, 8) ? UINT64_C(0xff) : 0x0) << 8;
                        result |= (bits(Rs1, 23, 16) ? UINT64_C(0xff) : 0x0) << 16;
                        result |= (bits(Rs1, 31, 24) ? UINT64_C(0xff) : 0x0) << 24;
                        result |= (bits(Rs1, 39, 32) ? UINT64_C(0xff) : 0x0) << 32;
                        result |= (bits(Rs1, 47, 40) ? UINT64_C(0xff) : 0x0) << 40;
                        result |= (bits(Rs1, 55, 48) ? UINT64_C(0xff) : 0x0) << 48;
                        result |= (bits(Rs1, 63, 56) ? UINT64_C(0xff) : 0x0) << 56;
                        Rd = rvSext(result);
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    Orc_b::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// IOp::srai(['\n                        if (rvSelect((bool)SHAMT6BIT5, false)) {\n                            return std::make_shared<IllegalInstFault>(\n                                    "shmat[5] != 0", machInst);\n                        }\n                        Rd_sd = rvSext(Rs1_sd) >> imm;\n                    '],{'imm_type': 'uint64_t', 'imm_code': ' imm = SHAMT6; '})

    Fault
    Srai::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int64_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        
                        if (rvSelect((bool)SHAMT6BIT5, false)) {
                            return std::make_shared<IllegalInstFault>(
                                    "shmat[5] != 0", machInst);
                        }
                        Rd = rvSext(Rs1) >> imm;
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    Srai::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// IOp::bexti(['\n                        if (rvSelect((bool)SHAMT6BIT5, false)) {\n                            return std::make_shared<IllegalInstFault>(\n                                    "shmat[5] != 0", machInst);\n                        }\n                        uint64_t index = imm & rvSelect(32 - 1, 64 - 1);\n                        Rd = (Rs1 >> index) & 0x1;\n                    '],{'imm_type': 'uint64_t', 'imm_code': ' imm = SHAMT6; '})

    Fault
    Bexti::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        
                        if (rvSelect((bool)SHAMT6BIT5, false)) {
                            return std::make_shared<IllegalInstFault>(
                                    "shmat[5] != 0", machInst);
                        }
                        uint64_t index = imm & rvSelect(32 - 1, 64 - 1);
                        Rd = (Rs1 >> index) & 0x1;
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    Bexti::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// IOp::rori(['\n                        if (rvSelect((bool)SHAMT6BIT5, false)) {\n                            return std::make_shared<IllegalInstFault>(\n                                    "shmat[5] != 0", machInst);\n                        }\n                        uint64_t xlen = rvSelect(32, 64);\n                        Rd = rvSext((rvZext(Rs1) >> imm)\n                            | (Rs1 << ((xlen - imm) & (xlen - 1))));\n                    '],{'imm_type': 'uint64_t', 'imm_code': ' imm = SHAMT6; '})

    Fault
    Rori::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        
                        if (rvSelect((bool)SHAMT6BIT5, false)) {
                            return std::make_shared<IllegalInstFault>(
                                    "shmat[5] != 0", machInst);
                        }
                        uint64_t xlen = rvSelect(32, 64);
                        Rd = rvSext((rvZext(Rs1) >> imm)
                            | (Rs1 << ((xlen - imm) & (xlen - 1))));
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    Rori::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// ROp::rev8((['\n                            if (rvSelect((bool)SHAMT6BIT5, false)) {\n                                return std::make_shared<IllegalInstFault>(\n                                        "shmat[5] != 0", machInst);\n                            }\n                            if (machInst.rv_type == RV32) {\n                                Rd_sd = _rvk_emu_grev_32(Rs1_sd, 0x18);\n                            } else {\n                                Rd_sd = _rvk_emu_grev_64(Rs1_sd, 0x38);\n                            }\n                        '], {}))

    Fault
    Rev8::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int64_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        
                            if (rvSelect((bool)SHAMT6BIT5, false)) {
                                return std::make_shared<IllegalInstFault>(
                                        "shmat[5] != 0", machInst);
                            }
                            if (machInst.rv_type == RV32) {
                                Rd = _rvk_emu_grev_32(Rs1, 0x18);
                            } else {
                                Rd = _rvk_emu_grev_64(Rs1, 0x38);
                            }
                        ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::brev8((['\n                            if (machInst.rv_type == RV32) {\n                                Rd_sd = _rvk_emu_brev8_32(Rs1_sd);\n                            } else {\n                                Rd_sd = _rvk_emu_brev8_64(Rs1_sd);\n                            }\n                        '], {}))

    Fault
    Brev8::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int64_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        
                            if (machInst.rv_type == RV32) {
                                Rd = _rvk_emu_brev8_32(Rs1);
                            } else {
                                Rd = _rvk_emu_brev8_64(Rs1);
                            }
                        ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Load::prefetch_i((['\n                                uint64_t temp = Mem_ub; temp = temp;\n                            '], {'offset_code': '\n                                offset = IMM7 << 5;\n                            ', 'mem_flags': ['PREFETCH'], 'inst_flags': 'IsInstPrefetch'}))

    Fault
    Prefetch_i::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
uint8_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
;
        EA = rvSext(Rs1 + offset);;

        {
            Fault fault =
                readMemAtomicLE(xc, traceData, EA, Mem, memAccessFlags);
            if (fault != NoFault)
                return fault;
        }

        
                                uint64_t temp = Mem; temp = temp;
                            ;

        ;

        return NoFault;
    }

    Fault
    Prefetch_i::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
uint8_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
;
        EA = rvSext(Rs1 + offset);;

        return initiateMemRead(xc, traceData, EA, Mem, memAccessFlags);
    }

    Fault
    Prefetch_i::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        return NoFault;
    }

// Load::prefetch_r((['\n                                uint64_t temp = Mem_ub; temp = temp;\n                            '], {'offset_code': '\n                                offset = IMM7 << 5;\n                            ', 'mem_flags': ['PREFETCH'], 'inst_flags': 'IsDataPrefetch'}))

    Fault
    Prefetch_r::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
uint8_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
;
        EA = rvSext(Rs1 + offset);;

        {
            Fault fault =
                readMemAtomicLE(xc, traceData, EA, Mem, memAccessFlags);
            if (fault != NoFault)
                return fault;
        }

        
                                uint64_t temp = Mem; temp = temp;
                            ;

        ;

        return NoFault;
    }

    Fault
    Prefetch_r::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
uint8_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
;
        EA = rvSext(Rs1 + offset);;

        return initiateMemRead(xc, traceData, EA, Mem, memAccessFlags);
    }

    Fault
    Prefetch_r::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        return NoFault;
    }

// Load::prefetch_w((['\n                                uint64_t temp = Mem_ub; temp = temp;\n                            '], {'offset_code': '\n                                offset = IMM7 << 5;\n                            ', 'mem_flags': ['PF_EXCLUSIVE'], 'inst_flags': 'IsDataPrefetch'}))

    Fault
    Prefetch_w::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
uint8_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
;
        EA = rvSext(Rs1 + offset);;

        {
            Fault fault =
                readMemAtomicLE(xc, traceData, EA, Mem, memAccessFlags);
            if (fault != NoFault)
                return fault;
        }

        
                                uint64_t temp = Mem; temp = temp;
                            ;

        ;

        return NoFault;
    }

    Fault
    Prefetch_w::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
uint8_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
;
        EA = rvSext(Rs1 + offset);;

        return initiateMemRead(xc, traceData, EA, Mem, memAccessFlags);
    }

    Fault
    Prefetch_w::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        return NoFault;
    }

// IOp::ori_hint(['\n                            Rd = rvSext(Rs1 | imm);\n                        ', 'uint64_t'],{})

    Fault
    Ori_hint::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        
                            Rd = rvSext(Rs1 | imm);
                        ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    Ori_hint::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// IOp::ori(['\n                        Rd = rvSext(Rs1 | imm);\n                    ', 'uint64_t'],{})

    Fault
    Ori::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        
                        Rd = rvSext(Rs1 | imm);
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    Ori::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// IOp::andi(['\n                    Rd = rvSext(Rs1 & imm);\n                ', 'uint64_t'],{})

    Fault
    Andi::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        
                    Rd = rvSext(Rs1 & imm);
                ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    Andi::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// Unknown::unknown(([], {}))

// UOp::auipc((['\n            Rd = rvSext(PC + (sext<20>(imm) << 12));\n        '], {}))

    Fault
    Auipc::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t PC = 0;
RiscvISAInst::PCState __parserAutoPCState;
;
        set(__parserAutoPCState, xc->pcState());
PC = __parserAutoPCState.pc();
;
        
            Rd = rvSext(PC + (sext<20>(imm) << 12));
        ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    Auipc::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// IOp::addiw(['\n                        Rd_sw = (int32_t)(Rs1_sw + imm);\n                    ', 'int32_t'],{})

    Fault
    Addiw::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        int32_t Rd = 0;
int32_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        
                        Rd = (int32_t)(Rs1 + imm);
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    Addiw::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// IOp::slliw(['\n                            Rd_sd = Rs1_sw << imm;\n                        '],{'imm_type': 'uint64_t', 'imm_code': ' imm = SHAMT5; '})

    Fault
    Slliw::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int32_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        
                            Rd = Rs1 << imm;
                        ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    Slliw::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// IOp::slli_uw(['\n                            Rd = ((uint64_t)(Rs1_uw)) << imm;\n                        '],{'imm_type': 'uint64_t', 'imm_code': ' imm = SHAMT6; '})

    Fault
    Slli_uw::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint32_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        
                            Rd = ((uint64_t)(Rs1)) << imm;
                        ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    Slli_uw::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// IOp::clzw(['\n                                Rd = clz32(Rs1);\n                            '],{})

    Fault
    Clzw::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        
                                Rd = clz32(Rs1);
                            ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    Clzw::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// IOp::ctzw(['\n                                Rd = ctz32(Rs1);\n                            '],{})

    Fault
    Ctzw::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        
                                Rd = ctz32(Rs1);
                            ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    Ctzw::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// IOp::cpopw(['\n                                Rd = popCount(Rs1<31:0>);\n                            '],{})

    Fault
    Cpopw::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        
                                Rd = popCount(bits(Rs1, 31, 0));
                            ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    Cpopw::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// IOp::srliw(['\n                            Rd_sd = (int32_t)(Rs1_uw >> imm);\n                        '],{'imm_type': 'uint64_t', 'imm_code': ' imm = SHAMT5; '})

    Fault
    Srliw::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
uint32_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        
                            Rd = (int32_t)(Rs1 >> imm);
                        ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    Srliw::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// IOp::sraiw(['\n                            Rd_sd = Rs1_sw >> imm;\n                        '],{'imm_type': 'uint64_t', 'imm_code': ' imm = SHAMT5; '})

    Fault
    Sraiw::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int32_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        
                            Rd = Rs1 >> imm;
                        ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    Sraiw::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// IOp::roriw(['\n                            Rd = (int32_t) ((Rs1_uw >> imm) | (Rs1_uw << ((32 - imm) & (32 - 1))));\n                        '],{'imm_type': 'uint64_t', 'imm_code': ' imm = SHAMT5; '})

    Fault
    Roriw::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint32_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;
        
                            Rd = (int32_t) ((Rs1 >> imm) | (Rs1 << ((32 - imm) & (32 - 1))));
                        ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    Roriw::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0),srcRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Store::sb(['\n                    Mem_ub = Rs2_ub;\n                '],{})

    Fault
    Sb::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
uint8_t Rs2 = 0;
uint8_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1 + offset);;

        
                    Mem = Rs2;
                ;

        {
            Fault fault =
                writeMemAtomicLE(xc, traceData, Mem, EA, memAccessFlags,
                        nullptr);
            if (fault != NoFault)
                return fault;
        }

        ;
        ;

        return NoFault;
    }

    Fault
    Sb::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
uint8_t Rs2 = 0;
uint8_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1 + offset);;

        
                    Mem = Rs2;
                ;

        {
            Fault fault = writeMemTimingLE(xc, traceData, Mem, EA,
                memAccessFlags, nullptr);
            if (fault != NoFault)
                return fault;
        }

        ;

        return NoFault;
    }

    Fault
    Sb::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        return NoFault;
    }

// Store::sh(['\n                    Mem_uh = Rs2_uh;\n                '],{})

    Fault
    Sh::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
uint16_t Rs2 = 0;
uint16_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1 + offset);;

        
                    Mem = Rs2;
                ;

        {
            Fault fault =
                writeMemAtomicLE(xc, traceData, Mem, EA, memAccessFlags,
                        nullptr);
            if (fault != NoFault)
                return fault;
        }

        ;
        ;

        return NoFault;
    }

    Fault
    Sh::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
uint16_t Rs2 = 0;
uint16_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1 + offset);;

        
                    Mem = Rs2;
                ;

        {
            Fault fault = writeMemTimingLE(xc, traceData, Mem, EA,
                memAccessFlags, nullptr);
            if (fault != NoFault)
                return fault;
        }

        ;

        return NoFault;
    }

    Fault
    Sh::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        return NoFault;
    }

// Store::sw(['\n                    Mem_uw = Rs2_uw;\n                '],{})

    Fault
    Sw::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
uint32_t Rs2 = 0;
uint32_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1 + offset);;

        
                    Mem = Rs2;
                ;

        {
            Fault fault =
                writeMemAtomicLE(xc, traceData, Mem, EA, memAccessFlags,
                        nullptr);
            if (fault != NoFault)
                return fault;
        }

        ;
        ;

        return NoFault;
    }

    Fault
    Sw::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
uint32_t Rs2 = 0;
uint32_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1 + offset);;

        
                    Mem = Rs2;
                ;

        {
            Fault fault = writeMemTimingLE(xc, traceData, Mem, EA,
                memAccessFlags, nullptr);
            if (fault != NoFault)
                return fault;
        }

        ;

        return NoFault;
    }

    Fault
    Sw::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        return NoFault;
    }

// Store::sd(['\n                        Mem_ud = Rs2_ud;\n                    '],{})

    Fault
    Sd::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
uint64_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1 + offset);;

        
                        Mem = Rs2;
                    ;

        {
            Fault fault =
                writeMemAtomicLE(xc, traceData, Mem, EA, memAccessFlags,
                        nullptr);
            if (fault != NoFault)
                return fault;
        }

        ;
        ;

        return NoFault;
    }

    Fault
    Sd::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
uint64_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1 + offset);;

        
                        Mem = Rs2;
                    ;

        {
            Fault fault = writeMemTimingLE(xc, traceData, Mem, EA,
                memAccessFlags, nullptr);
            if (fault != NoFault)
                return fault;
        }

        ;

        return NoFault;
    }

    Fault
    Sd::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        return NoFault;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Store::fsh(['\n                    STATUS status = xc->readMiscReg(MISCREG_STATUS);\n                    if (status.fs == FPUStatus::OFF)\n                        return std::make_shared<IllegalInstFault>(\n                                "FPU is off", machInst);\n\n                    Mem_uh = unboxF16(boxF16(Fs2_bits));\n                '],{'inst_flags': 'FloatMemWriteOp'})

    Fault
    Fsh::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
uint64_t Fs2_bits = 0;
uint16_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1 + offset);;

        
                    STATUS status = xc->readMiscReg(MISCREG_STATUS);
                    if (status.fs == FPUStatus::OFF)
                        return std::make_shared<IllegalInstFault>(
                                "FPU is off", machInst);

                    Mem = unboxF16(boxF16(Fs2_bits));
                ;

        {
            Fault fault =
                writeMemAtomicLE(xc, traceData, Mem, EA, memAccessFlags,
                        nullptr);
            if (fault != NoFault)
                return fault;
        }

        ;
        ;

        return NoFault;
    }

    Fault
    Fsh::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
uint64_t Fs2_bits = 0;
uint16_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1 + offset);;

        
                    STATUS status = xc->readMiscReg(MISCREG_STATUS);
                    if (status.fs == FPUStatus::OFF)
                        return std::make_shared<IllegalInstFault>(
                                "FPU is off", machInst);

                    Mem = unboxF16(boxF16(Fs2_bits));
                ;

        {
            Fault fault = writeMemTimingLE(xc, traceData, Mem, EA,
                memAccessFlags, nullptr);
            if (fault != NoFault)
                return fault;
        }

        ;

        return NoFault;
    }

    Fault
    Fsh::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        return NoFault;
    }

// Store::fsw(['\n                    STATUS status = xc->readMiscReg(MISCREG_STATUS);\n                    if (status.fs == FPUStatus::OFF)\n                        return std::make_shared<IllegalInstFault>(\n                                "FPU is off", machInst);\n\n                    Mem_uw = unboxF32(boxF32(Fs2_bits));\n                '],{'inst_flags': 'FloatMemWriteOp'})

    Fault
    Fsw::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
uint64_t Fs2_bits = 0;
uint32_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1 + offset);;

        
                    STATUS status = xc->readMiscReg(MISCREG_STATUS);
                    if (status.fs == FPUStatus::OFF)
                        return std::make_shared<IllegalInstFault>(
                                "FPU is off", machInst);

                    Mem = unboxF32(boxF32(Fs2_bits));
                ;

        {
            Fault fault =
                writeMemAtomicLE(xc, traceData, Mem, EA, memAccessFlags,
                        nullptr);
            if (fault != NoFault)
                return fault;
        }

        ;
        ;

        return NoFault;
    }

    Fault
    Fsw::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
uint64_t Fs2_bits = 0;
uint32_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1 + offset);;

        
                    STATUS status = xc->readMiscReg(MISCREG_STATUS);
                    if (status.fs == FPUStatus::OFF)
                        return std::make_shared<IllegalInstFault>(
                                "FPU is off", machInst);

                    Mem = unboxF32(boxF32(Fs2_bits));
                ;

        {
            Fault fault = writeMemTimingLE(xc, traceData, Mem, EA,
                memAccessFlags, nullptr);
            if (fault != NoFault)
                return fault;
        }

        ;

        return NoFault;
    }

    Fault
    Fsw::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        return NoFault;
    }

// Store::fsd(['\n                    STATUS status = xc->readMiscReg(MISCREG_STATUS);\n                    if (status.fs == FPUStatus::OFF)\n                        return std::make_shared<IllegalInstFault>(\n                                "FPU is off", machInst);\n\n                    Mem_ud = Fs2_bits;\n                '],{'inst_flags': 'FloatMemWriteOp'})

    Fault
    Fsd::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
uint64_t Fs2_bits = 0;
uint64_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1 + offset);;

        
                    STATUS status = xc->readMiscReg(MISCREG_STATUS);
                    if (status.fs == FPUStatus::OFF)
                        return std::make_shared<IllegalInstFault>(
                                "FPU is off", machInst);

                    Mem = Fs2_bits;
                ;

        {
            Fault fault =
                writeMemAtomicLE(xc, traceData, Mem, EA, memAccessFlags,
                        nullptr);
            if (fault != NoFault)
                return fault;
        }

        ;
        ;

        return NoFault;
    }

    Fault
    Fsd::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
uint64_t Fs2_bits = 0;
uint64_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1 + offset);;

        
                    STATUS status = xc->readMiscReg(MISCREG_STATUS);
                    if (status.fs == FPUStatus::OFF)
                        return std::make_shared<IllegalInstFault>(
                                "FPU is off", machInst);

                    Mem = Fs2_bits;
                ;

        {
            Fault fault = writeMemTimingLE(xc, traceData, Mem, EA,
                memAccessFlags, nullptr);
            if (fault != NoFault)
                return fault;
        }

        ;

        return NoFault;
    }

    Fault
    Fsd::completeAcc(PacketPtr pkt, ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        return NoFault;
    }

// VseOp::vse8_v((['\n                            Mem_vc.as<uint8_t>()[i] = Vs3_ub[i];\n                        '], {'inst_flags': 'SimdUnitStrideStoreOp'}))


Fault
Vse8_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint8_t>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);
    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;
    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask(v0, ei)) {
            
                            Mem.as<uint8_t>()[i] = Vs3[i];
                        ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vse8_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    Addr EA;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint8_t>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);
    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;
    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask(v0, ei)) {
            
                            Mem.as<uint8_t>()[i] = Vs3[i];
                        ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vse8_vMicro::completeAcc(PacketPtr pkt, ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    return NoFault;
}


// VsSegOp::vsseg2e8_v(['\n                                Mem_vc.as<uint8_t>()[i] = Vs3_ub[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


Fault
Vsseg2e8_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint8_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vsseg inst");

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint8_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg2e8_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint8_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
        panic_if(((1 << vlmul) * this->numFields) > 8,
            "LMUL value is illegal for vsseg inst");


    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint8_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg2e8_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    return NoFault;
}


// VsSegOp::vsseg3e8_v(['\n                                Mem_vc.as<uint8_t>()[i] = Vs3_ub[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


Fault
Vsseg3e8_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint8_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vsseg inst");

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint8_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg3e8_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint8_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
        panic_if(((1 << vlmul) * this->numFields) > 8,
            "LMUL value is illegal for vsseg inst");


    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint8_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg3e8_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    return NoFault;
}


// VsSegOp::vsseg4e8_v(['\n                                Mem_vc.as<uint8_t>()[i] = Vs3_ub[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


Fault
Vsseg4e8_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint8_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vsseg inst");

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint8_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg4e8_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint8_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
        panic_if(((1 << vlmul) * this->numFields) > 8,
            "LMUL value is illegal for vsseg inst");


    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint8_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg4e8_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    return NoFault;
}


// VsSegOp::vsseg5e8_v(['\n                                Mem_vc.as<uint8_t>()[i] = Vs3_ub[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


Fault
Vsseg5e8_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint8_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vsseg inst");

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint8_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg5e8_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint8_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
        panic_if(((1 << vlmul) * this->numFields) > 8,
            "LMUL value is illegal for vsseg inst");


    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint8_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg5e8_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    return NoFault;
}


// VsSegOp::vsseg6e8_v(['\n                                Mem_vc.as<uint8_t>()[i] = Vs3_ub[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


Fault
Vsseg6e8_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint8_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vsseg inst");

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint8_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg6e8_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint8_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
        panic_if(((1 << vlmul) * this->numFields) > 8,
            "LMUL value is illegal for vsseg inst");


    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint8_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg6e8_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    return NoFault;
}


// VsSegOp::vsseg7e8_v(['\n                                Mem_vc.as<uint8_t>()[i] = Vs3_ub[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


Fault
Vsseg7e8_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint8_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vsseg inst");

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint8_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg7e8_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint8_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
        panic_if(((1 << vlmul) * this->numFields) > 8,
            "LMUL value is illegal for vsseg inst");


    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint8_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg7e8_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    return NoFault;
}


// VsSegOp::vsseg8e8_v(['\n                                Mem_vc.as<uint8_t>()[i] = Vs3_ub[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


Fault
Vsseg8e8_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint8_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vsseg inst");

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint8_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg8e8_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint8_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
        panic_if(((1 << vlmul) * this->numFields) > 8,
            "LMUL value is illegal for vsseg inst");


    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint8_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg8e8_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    return NoFault;
}


// Unknown::unknown(([], {}))

// VsWholeOp::vs1r_v(['\n                                Mem_vc.as<uint8_t>()[i] = Vs3_ub[i];\n                            '],{'inst_flags': 'SimdWholeRegisterStoreOp'})


Fault
Vs1r_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint8_t>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;


    for (size_t i = 0; i < vlenb; i++) {
        
                                Mem.as<uint8_t>()[i] = Vs3[i];
                            ;
    }

    Fault fault = writeMemAtomicLE(xc, traceData, *(vreg_t::Container*)(&Mem),
                                   vlenb, EA, memAccessFlags, nullptr);
    return fault;
}



Fault
Vs1r_vMicro::initiateAcc(ExecContext* xc,
        trace::InstRecord* traceData) const
{
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint8_t>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;


    for (size_t i = 0; i < vlenb; i++) {
        
                                Mem.as<uint8_t>()[i] = Vs3[i];
                            ;
    }

    Fault fault = writeMemTimingLE(xc, traceData, *(vreg_t::Container*)(&Mem),
                                   EA, vlenb, memAccessFlags, nullptr);
    return fault;
}



Fault
Vs1r_vMicro::completeAcc(PacketPtr pkt, ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    return NoFault;
}


// VsWholeOp::vs2r_v(['\n                                Mem_vc.as<uint8_t>()[i] = Vs3_ub[i];\n                            '],{'inst_flags': 'SimdWholeRegisterStoreOp'})


Fault
Vs2r_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint8_t>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;


    for (size_t i = 0; i < vlenb; i++) {
        
                                Mem.as<uint8_t>()[i] = Vs3[i];
                            ;
    }

    Fault fault = writeMemAtomicLE(xc, traceData, *(vreg_t::Container*)(&Mem),
                                   vlenb, EA, memAccessFlags, nullptr);
    return fault;
}



Fault
Vs2r_vMicro::initiateAcc(ExecContext* xc,
        trace::InstRecord* traceData) const
{
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint8_t>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;


    for (size_t i = 0; i < vlenb; i++) {
        
                                Mem.as<uint8_t>()[i] = Vs3[i];
                            ;
    }

    Fault fault = writeMemTimingLE(xc, traceData, *(vreg_t::Container*)(&Mem),
                                   EA, vlenb, memAccessFlags, nullptr);
    return fault;
}



Fault
Vs2r_vMicro::completeAcc(PacketPtr pkt, ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    return NoFault;
}


// VsWholeOp::vs4r_v(['\n                                Mem_vc.as<uint8_t>()[i] = Vs3_ub[i];\n                            '],{'inst_flags': 'SimdWholeRegisterStoreOp'})


Fault
Vs4r_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint8_t>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;


    for (size_t i = 0; i < vlenb; i++) {
        
                                Mem.as<uint8_t>()[i] = Vs3[i];
                            ;
    }

    Fault fault = writeMemAtomicLE(xc, traceData, *(vreg_t::Container*)(&Mem),
                                   vlenb, EA, memAccessFlags, nullptr);
    return fault;
}



Fault
Vs4r_vMicro::initiateAcc(ExecContext* xc,
        trace::InstRecord* traceData) const
{
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint8_t>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;


    for (size_t i = 0; i < vlenb; i++) {
        
                                Mem.as<uint8_t>()[i] = Vs3[i];
                            ;
    }

    Fault fault = writeMemTimingLE(xc, traceData, *(vreg_t::Container*)(&Mem),
                                   EA, vlenb, memAccessFlags, nullptr);
    return fault;
}



Fault
Vs4r_vMicro::completeAcc(PacketPtr pkt, ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    return NoFault;
}


// VsWholeOp::vs8r_v(['\n                                Mem_vc.as<uint8_t>()[i] = Vs3_ub[i];\n                            '],{'inst_flags': 'SimdWholeRegisterStoreOp'})


Fault
Vs8r_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint8_t>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;


    for (size_t i = 0; i < vlenb; i++) {
        
                                Mem.as<uint8_t>()[i] = Vs3[i];
                            ;
    }

    Fault fault = writeMemAtomicLE(xc, traceData, *(vreg_t::Container*)(&Mem),
                                   vlenb, EA, memAccessFlags, nullptr);
    return fault;
}



Fault
Vs8r_vMicro::initiateAcc(ExecContext* xc,
        trace::InstRecord* traceData) const
{
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint8_t>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;


    for (size_t i = 0; i < vlenb; i++) {
        
                                Mem.as<uint8_t>()[i] = Vs3[i];
                            ;
    }

    Fault fault = writeMemTimingLE(xc, traceData, *(vreg_t::Container*)(&Mem),
                                   EA, vlenb, memAccessFlags, nullptr);
    return fault;
}



Fault
Vs8r_vMicro::completeAcc(PacketPtr pkt, ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    return NoFault;
}


// Unknown::unknown(([], {}))

// VsmOp::vsm_v((['\n                        Mem_vc.as<uint8_t>()[i] = Vs3_ub[i];\n                    '], {'inst_flags': 'SimdUnitStrideMaskStoreOp'}))

// Unknown::unknown(([], {}))

// VsIndexOp::vsuxei8_v((['\n                    Mem_vc.as<vu>()[0] = Vs3_vu[vs3ElemIdx];\n                ', '\n                    EA = Rs1 + Vs2_ub[vs2ElemIdx];\n                '], {'inst_flags': 'SimdIndexedStoreOp'}))


template<typename ElemType>
Fault
Vsuxei8_vMicro<ElemType>::execute(ExecContext *xc,
    trace::InstRecord *traceData)const
{
    using vu = std::make_unsigned_t<ElemType>;
    Fault fault = NoFault;
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    uint64_t Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<uint8_t>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
                    EA = Rs1 + Vs2[vs2ElemIdx];
                ;
    constexpr uint8_t elem_size = sizeof(Vs3[0]);
    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint32_t mem_size = elem_size;
    const std::vector<bool> byte_enable(mem_size, true);

    size_t ei = this->vs3RegIdx * vlenb / elem_size + this->vs3ElemIdx;
    if (machInst.vm || elem_mask(v0, ei)) {
        
                    Mem.as<vu>()[0] = Vs3[vs3ElemIdx];
                ; /* Mem[0] = Vs3[this->vs3ElemIdx] */
        fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA,
                             memAccessFlags, nullptr, byte_enable);
    }
    return fault;
}



template<typename ElemType>
Fault
Vsuxei8_vMicro<ElemType>::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    using vu = std::make_unsigned_t<ElemType>;
    Fault fault = NoFault;
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    uint64_t Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<uint8_t>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
                    EA = Rs1 + Vs2[vs2ElemIdx];
                ;
    constexpr uint8_t elem_size = sizeof(Vs3[0]);
    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    constexpr uint8_t mem_size = elem_size;
    const std::vector<bool> byte_enable(mem_size, true);

    size_t ei = this->vs3RegIdx * vlenb / elem_size + this->vs3ElemIdx;
    if (machInst.vm || elem_mask(v0, ei)) {
        
                    Mem.as<vu>()[0] = Vs3[vs3ElemIdx];
                ; /* Mem[0] = Vs3[this->vs3ElemIdx] */
        fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA,
                             memAccessFlags, nullptr, byte_enable);
    }
    return fault;
}



template<typename ElemType>
Fault
Vsuxei8_vMicro<ElemType>::completeAcc(PacketPtr pkt, ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    return NoFault;
}


    template class Vsuxei8_vMicro<uint8_t>;
    template class Vsuxei8_vMicro<uint16_t>;
    template class Vsuxei8_vMicro<uint32_t>;
    template class Vsuxei8_vMicro<uint64_t>;
    ;


// VsStrideOp::vsse8_v((['\n                    Mem_vc.as<uint8_t>()[0] = Vs3_ub[microIdx];\n                '], {'inst_flags': 'SimdStridedStoreOp'}))


Fault
Vsse8_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Fault fault = NoFault;
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<uint8_t>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    constexpr uint8_t elem_size = sizeof(Vs3[0]);
    
        EA = Rs1 + Rs2 * (regIdx * vlenb / elem_size + microIdx);
    ;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint32_t mem_size = elem_size;
    const std::vector<bool> byte_enable(mem_size, true);

    size_t ei = this->regIdx * vlenb / elem_size + this->microIdx;
    if (machInst.vm || elem_mask(v0, ei)) {
        
                    Mem.as<uint8_t>()[0] = Vs3[microIdx];
                ;
        fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA,
                             memAccessFlags, nullptr, byte_enable);
    }
    return fault;
}



Fault
Vsse8_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    Fault fault = NoFault;
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<uint8_t>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    constexpr uint8_t elem_size = sizeof(Vs3[0]);
    
        EA = Rs1 + Rs2 * (regIdx * vlenb / elem_size + microIdx);
    ;

    uint32_t mem_size = elem_size;

    size_t ei = this->regIdx * vlenb / elem_size + this->microIdx;
    bool need_store = machInst.vm || elem_mask(v0, ei);
    if (need_store) {
        const std::vector<bool> byte_enable(mem_size, need_store);
        
                    Mem.as<uint8_t>()[0] = Vs3[microIdx];
                ;
        fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA,
                            memAccessFlags, nullptr, byte_enable);
    }
    return fault;
}



Fault
Vsse8_vMicro::completeAcc(PacketPtr pkt, ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    return NoFault;
}


// VsIndexOp::vsoxei8_v((['\n                    Mem_vc.as<vu>()[0] = Vs3_vu[vs3ElemIdx];\n                ', '\n                    EA = Rs1 + Vs2_ub[vs2ElemIdx];\n                '], {'inst_flags': 'SimdIndexedStoreOp'}))


template<typename ElemType>
Fault
Vsoxei8_vMicro<ElemType>::execute(ExecContext *xc,
    trace::InstRecord *traceData)const
{
    using vu = std::make_unsigned_t<ElemType>;
    Fault fault = NoFault;
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    uint64_t Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<uint8_t>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
                    EA = Rs1 + Vs2[vs2ElemIdx];
                ;
    constexpr uint8_t elem_size = sizeof(Vs3[0]);
    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint32_t mem_size = elem_size;
    const std::vector<bool> byte_enable(mem_size, true);

    size_t ei = this->vs3RegIdx * vlenb / elem_size + this->vs3ElemIdx;
    if (machInst.vm || elem_mask(v0, ei)) {
        
                    Mem.as<vu>()[0] = Vs3[vs3ElemIdx];
                ; /* Mem[0] = Vs3[this->vs3ElemIdx] */
        fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA,
                             memAccessFlags, nullptr, byte_enable);
    }
    return fault;
}



template<typename ElemType>
Fault
Vsoxei8_vMicro<ElemType>::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    using vu = std::make_unsigned_t<ElemType>;
    Fault fault = NoFault;
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    uint64_t Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<uint8_t>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
                    EA = Rs1 + Vs2[vs2ElemIdx];
                ;
    constexpr uint8_t elem_size = sizeof(Vs3[0]);
    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    constexpr uint8_t mem_size = elem_size;
    const std::vector<bool> byte_enable(mem_size, true);

    size_t ei = this->vs3RegIdx * vlenb / elem_size + this->vs3ElemIdx;
    if (machInst.vm || elem_mask(v0, ei)) {
        
                    Mem.as<vu>()[0] = Vs3[vs3ElemIdx];
                ; /* Mem[0] = Vs3[this->vs3ElemIdx] */
        fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA,
                             memAccessFlags, nullptr, byte_enable);
    }
    return fault;
}



template<typename ElemType>
Fault
Vsoxei8_vMicro<ElemType>::completeAcc(PacketPtr pkt, ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    return NoFault;
}


    template class Vsoxei8_vMicro<uint8_t>;
    template class Vsoxei8_vMicro<uint16_t>;
    template class Vsoxei8_vMicro<uint32_t>;
    template class Vsoxei8_vMicro<uint64_t>;
    ;


// Unknown::unknown(([], {}))

// VseOp::vse16_v((['\n                            Mem_vc.as<uint16_t>()[i] = Vs3_uh[i];\n                        '], {'inst_flags': 'SimdUnitStrideStoreOp'}))


Fault
Vse16_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint16_t>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);
    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;
    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask(v0, ei)) {
            
                            Mem.as<uint16_t>()[i] = Vs3[i];
                        ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vse16_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    Addr EA;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint16_t>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);
    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;
    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask(v0, ei)) {
            
                            Mem.as<uint16_t>()[i] = Vs3[i];
                        ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vse16_vMicro::completeAcc(PacketPtr pkt, ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    return NoFault;
}


// VsSegOp::vsseg2e16_v(['\n                                Mem_vc.as<uint16_t>()[i] = Vs3_uh[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


Fault
Vsseg2e16_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint16_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vsseg inst");

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint16_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg2e16_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint16_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
        panic_if(((1 << vlmul) * this->numFields) > 8,
            "LMUL value is illegal for vsseg inst");


    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint16_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg2e16_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    return NoFault;
}


// VsSegOp::vsseg3e16_v(['\n                                Mem_vc.as<uint16_t>()[i] = Vs3_uh[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


Fault
Vsseg3e16_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint16_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vsseg inst");

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint16_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg3e16_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint16_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
        panic_if(((1 << vlmul) * this->numFields) > 8,
            "LMUL value is illegal for vsseg inst");


    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint16_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg3e16_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    return NoFault;
}


// VsSegOp::vsseg4e16_v(['\n                                Mem_vc.as<uint16_t>()[i] = Vs3_uh[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


Fault
Vsseg4e16_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint16_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vsseg inst");

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint16_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg4e16_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint16_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
        panic_if(((1 << vlmul) * this->numFields) > 8,
            "LMUL value is illegal for vsseg inst");


    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint16_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg4e16_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    return NoFault;
}


// VsSegOp::vsseg5e16_v(['\n                                Mem_vc.as<uint16_t>()[i] = Vs3_uh[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


Fault
Vsseg5e16_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint16_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vsseg inst");

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint16_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg5e16_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint16_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
        panic_if(((1 << vlmul) * this->numFields) > 8,
            "LMUL value is illegal for vsseg inst");


    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint16_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg5e16_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    return NoFault;
}


// VsSegOp::vsseg6e16_v(['\n                                Mem_vc.as<uint16_t>()[i] = Vs3_uh[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


Fault
Vsseg6e16_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint16_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vsseg inst");

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint16_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg6e16_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint16_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
        panic_if(((1 << vlmul) * this->numFields) > 8,
            "LMUL value is illegal for vsseg inst");


    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint16_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg6e16_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    return NoFault;
}


// VsSegOp::vsseg7e16_v(['\n                                Mem_vc.as<uint16_t>()[i] = Vs3_uh[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


Fault
Vsseg7e16_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint16_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vsseg inst");

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint16_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg7e16_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint16_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
        panic_if(((1 << vlmul) * this->numFields) > 8,
            "LMUL value is illegal for vsseg inst");


    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint16_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg7e16_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    return NoFault;
}


// VsSegOp::vsseg8e16_v(['\n                                Mem_vc.as<uint16_t>()[i] = Vs3_uh[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


Fault
Vsseg8e16_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint16_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vsseg inst");

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint16_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg8e16_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint16_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
        panic_if(((1 << vlmul) * this->numFields) > 8,
            "LMUL value is illegal for vsseg inst");


    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint16_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg8e16_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    return NoFault;
}


// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// VsIndexOp::vsuxei16_v((['\n                    Mem_vc.as<vu>()[0] = Vs3_vu[vs3ElemIdx];\n                ', '\n                    EA = Rs1 + Vs2_uh[vs2ElemIdx];\n                '], {'inst_flags': 'SimdIndexedStoreOp'}))


template<typename ElemType>
Fault
Vsuxei16_vMicro<ElemType>::execute(ExecContext *xc,
    trace::InstRecord *traceData)const
{
    using vu = std::make_unsigned_t<ElemType>;
    Fault fault = NoFault;
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    uint64_t Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<uint16_t>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
                    EA = Rs1 + Vs2[vs2ElemIdx];
                ;
    constexpr uint8_t elem_size = sizeof(Vs3[0]);
    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint32_t mem_size = elem_size;
    const std::vector<bool> byte_enable(mem_size, true);

    size_t ei = this->vs3RegIdx * vlenb / elem_size + this->vs3ElemIdx;
    if (machInst.vm || elem_mask(v0, ei)) {
        
                    Mem.as<vu>()[0] = Vs3[vs3ElemIdx];
                ; /* Mem[0] = Vs3[this->vs3ElemIdx] */
        fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA,
                             memAccessFlags, nullptr, byte_enable);
    }
    return fault;
}



template<typename ElemType>
Fault
Vsuxei16_vMicro<ElemType>::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    using vu = std::make_unsigned_t<ElemType>;
    Fault fault = NoFault;
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    uint64_t Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<uint16_t>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
                    EA = Rs1 + Vs2[vs2ElemIdx];
                ;
    constexpr uint8_t elem_size = sizeof(Vs3[0]);
    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    constexpr uint8_t mem_size = elem_size;
    const std::vector<bool> byte_enable(mem_size, true);

    size_t ei = this->vs3RegIdx * vlenb / elem_size + this->vs3ElemIdx;
    if (machInst.vm || elem_mask(v0, ei)) {
        
                    Mem.as<vu>()[0] = Vs3[vs3ElemIdx];
                ; /* Mem[0] = Vs3[this->vs3ElemIdx] */
        fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA,
                             memAccessFlags, nullptr, byte_enable);
    }
    return fault;
}



template<typename ElemType>
Fault
Vsuxei16_vMicro<ElemType>::completeAcc(PacketPtr pkt, ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    return NoFault;
}


    template class Vsuxei16_vMicro<uint8_t>;
    template class Vsuxei16_vMicro<uint16_t>;
    template class Vsuxei16_vMicro<uint32_t>;
    template class Vsuxei16_vMicro<uint64_t>;
    ;


// VsStrideOp::vsse16_v((['\n                    Mem_vc.as<uint16_t>()[0] = Vs3_uh[microIdx];\n                '], {'inst_flags': 'SimdStridedStoreOp'}))


Fault
Vsse16_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Fault fault = NoFault;
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<uint16_t>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    constexpr uint8_t elem_size = sizeof(Vs3[0]);
    
        EA = Rs1 + Rs2 * (regIdx * vlenb / elem_size + microIdx);
    ;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint32_t mem_size = elem_size;
    const std::vector<bool> byte_enable(mem_size, true);

    size_t ei = this->regIdx * vlenb / elem_size + this->microIdx;
    if (machInst.vm || elem_mask(v0, ei)) {
        
                    Mem.as<uint16_t>()[0] = Vs3[microIdx];
                ;
        fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA,
                             memAccessFlags, nullptr, byte_enable);
    }
    return fault;
}



Fault
Vsse16_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    Fault fault = NoFault;
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<uint16_t>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    constexpr uint8_t elem_size = sizeof(Vs3[0]);
    
        EA = Rs1 + Rs2 * (regIdx * vlenb / elem_size + microIdx);
    ;

    uint32_t mem_size = elem_size;

    size_t ei = this->regIdx * vlenb / elem_size + this->microIdx;
    bool need_store = machInst.vm || elem_mask(v0, ei);
    if (need_store) {
        const std::vector<bool> byte_enable(mem_size, need_store);
        
                    Mem.as<uint16_t>()[0] = Vs3[microIdx];
                ;
        fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA,
                            memAccessFlags, nullptr, byte_enable);
    }
    return fault;
}



Fault
Vsse16_vMicro::completeAcc(PacketPtr pkt, ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    return NoFault;
}


// VsIndexOp::vsoxei16_v((['\n                    Mem_vc.as<vu>()[0] = Vs3_vu[vs3ElemIdx];\n                ', '\n                    EA = Rs1 + Vs2_uh[vs2ElemIdx];\n                '], {'inst_flags': 'SimdIndexedStoreOp'}))


template<typename ElemType>
Fault
Vsoxei16_vMicro<ElemType>::execute(ExecContext *xc,
    trace::InstRecord *traceData)const
{
    using vu = std::make_unsigned_t<ElemType>;
    Fault fault = NoFault;
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    uint64_t Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<uint16_t>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
                    EA = Rs1 + Vs2[vs2ElemIdx];
                ;
    constexpr uint8_t elem_size = sizeof(Vs3[0]);
    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint32_t mem_size = elem_size;
    const std::vector<bool> byte_enable(mem_size, true);

    size_t ei = this->vs3RegIdx * vlenb / elem_size + this->vs3ElemIdx;
    if (machInst.vm || elem_mask(v0, ei)) {
        
                    Mem.as<vu>()[0] = Vs3[vs3ElemIdx];
                ; /* Mem[0] = Vs3[this->vs3ElemIdx] */
        fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA,
                             memAccessFlags, nullptr, byte_enable);
    }
    return fault;
}



template<typename ElemType>
Fault
Vsoxei16_vMicro<ElemType>::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    using vu = std::make_unsigned_t<ElemType>;
    Fault fault = NoFault;
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    uint64_t Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<uint16_t>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
                    EA = Rs1 + Vs2[vs2ElemIdx];
                ;
    constexpr uint8_t elem_size = sizeof(Vs3[0]);
    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    constexpr uint8_t mem_size = elem_size;
    const std::vector<bool> byte_enable(mem_size, true);

    size_t ei = this->vs3RegIdx * vlenb / elem_size + this->vs3ElemIdx;
    if (machInst.vm || elem_mask(v0, ei)) {
        
                    Mem.as<vu>()[0] = Vs3[vs3ElemIdx];
                ; /* Mem[0] = Vs3[this->vs3ElemIdx] */
        fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA,
                             memAccessFlags, nullptr, byte_enable);
    }
    return fault;
}



template<typename ElemType>
Fault
Vsoxei16_vMicro<ElemType>::completeAcc(PacketPtr pkt, ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    return NoFault;
}


    template class Vsoxei16_vMicro<uint8_t>;
    template class Vsoxei16_vMicro<uint16_t>;
    template class Vsoxei16_vMicro<uint32_t>;
    template class Vsoxei16_vMicro<uint64_t>;
    ;


// Unknown::unknown(([], {}))

// VseOp::vse32_v((['\n                            Mem_vc.as<uint32_t>()[i] = Vs3_uw[i];\n                        '], {'inst_flags': 'SimdUnitStrideStoreOp'}))


Fault
Vse32_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint32_t>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);
    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;
    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask(v0, ei)) {
            
                            Mem.as<uint32_t>()[i] = Vs3[i];
                        ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vse32_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    Addr EA;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint32_t>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);
    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;
    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask(v0, ei)) {
            
                            Mem.as<uint32_t>()[i] = Vs3[i];
                        ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vse32_vMicro::completeAcc(PacketPtr pkt, ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    return NoFault;
}


// VsSegOp::vsseg2e32_v(['\n                                Mem_vc.as<uint32_t>()[i] = Vs3_uw[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


Fault
Vsseg2e32_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint32_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vsseg inst");

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint32_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg2e32_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint32_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
        panic_if(((1 << vlmul) * this->numFields) > 8,
            "LMUL value is illegal for vsseg inst");


    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint32_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg2e32_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    return NoFault;
}


// VsSegOp::vsseg3e32_v(['\n                                Mem_vc.as<uint32_t>()[i] = Vs3_uw[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


Fault
Vsseg3e32_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint32_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vsseg inst");

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint32_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg3e32_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint32_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
        panic_if(((1 << vlmul) * this->numFields) > 8,
            "LMUL value is illegal for vsseg inst");


    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint32_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg3e32_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    return NoFault;
}


// VsSegOp::vsseg4e32_v(['\n                                Mem_vc.as<uint32_t>()[i] = Vs3_uw[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


Fault
Vsseg4e32_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint32_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vsseg inst");

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint32_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg4e32_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint32_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
        panic_if(((1 << vlmul) * this->numFields) > 8,
            "LMUL value is illegal for vsseg inst");


    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint32_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg4e32_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    return NoFault;
}


// VsSegOp::vsseg5e32_v(['\n                                Mem_vc.as<uint32_t>()[i] = Vs3_uw[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


Fault
Vsseg5e32_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint32_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vsseg inst");

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint32_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg5e32_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint32_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
        panic_if(((1 << vlmul) * this->numFields) > 8,
            "LMUL value is illegal for vsseg inst");


    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint32_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg5e32_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    return NoFault;
}


// VsSegOp::vsseg6e32_v(['\n                                Mem_vc.as<uint32_t>()[i] = Vs3_uw[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


Fault
Vsseg6e32_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint32_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vsseg inst");

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint32_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg6e32_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint32_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
        panic_if(((1 << vlmul) * this->numFields) > 8,
            "LMUL value is illegal for vsseg inst");


    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint32_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg6e32_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    return NoFault;
}


// VsSegOp::vsseg7e32_v(['\n                                Mem_vc.as<uint32_t>()[i] = Vs3_uw[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


Fault
Vsseg7e32_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint32_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vsseg inst");

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint32_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg7e32_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint32_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
        panic_if(((1 << vlmul) * this->numFields) > 8,
            "LMUL value is illegal for vsseg inst");


    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint32_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg7e32_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    return NoFault;
}


// VsSegOp::vsseg8e32_v(['\n                                Mem_vc.as<uint32_t>()[i] = Vs3_uw[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


Fault
Vsseg8e32_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint32_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vsseg inst");

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint32_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg8e32_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint32_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
        panic_if(((1 << vlmul) * this->numFields) > 8,
            "LMUL value is illegal for vsseg inst");


    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint32_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg8e32_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    return NoFault;
}


// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// VsIndexOp::vsuxei32_v((['\n                    Mem_vc.as<vu>()[0] = Vs3_vu[vs3ElemIdx];\n                ', '\n                    EA = Rs1 + Vs2_uw[vs2ElemIdx];\n                '], {'inst_flags': 'SimdIndexedStoreOp'}))


template<typename ElemType>
Fault
Vsuxei32_vMicro<ElemType>::execute(ExecContext *xc,
    trace::InstRecord *traceData)const
{
    using vu = std::make_unsigned_t<ElemType>;
    Fault fault = NoFault;
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    uint64_t Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<uint32_t>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
                    EA = Rs1 + Vs2[vs2ElemIdx];
                ;
    constexpr uint8_t elem_size = sizeof(Vs3[0]);
    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint32_t mem_size = elem_size;
    const std::vector<bool> byte_enable(mem_size, true);

    size_t ei = this->vs3RegIdx * vlenb / elem_size + this->vs3ElemIdx;
    if (machInst.vm || elem_mask(v0, ei)) {
        
                    Mem.as<vu>()[0] = Vs3[vs3ElemIdx];
                ; /* Mem[0] = Vs3[this->vs3ElemIdx] */
        fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA,
                             memAccessFlags, nullptr, byte_enable);
    }
    return fault;
}



template<typename ElemType>
Fault
Vsuxei32_vMicro<ElemType>::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    using vu = std::make_unsigned_t<ElemType>;
    Fault fault = NoFault;
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    uint64_t Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<uint32_t>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
                    EA = Rs1 + Vs2[vs2ElemIdx];
                ;
    constexpr uint8_t elem_size = sizeof(Vs3[0]);
    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    constexpr uint8_t mem_size = elem_size;
    const std::vector<bool> byte_enable(mem_size, true);

    size_t ei = this->vs3RegIdx * vlenb / elem_size + this->vs3ElemIdx;
    if (machInst.vm || elem_mask(v0, ei)) {
        
                    Mem.as<vu>()[0] = Vs3[vs3ElemIdx];
                ; /* Mem[0] = Vs3[this->vs3ElemIdx] */
        fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA,
                             memAccessFlags, nullptr, byte_enable);
    }
    return fault;
}



template<typename ElemType>
Fault
Vsuxei32_vMicro<ElemType>::completeAcc(PacketPtr pkt, ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    return NoFault;
}


    template class Vsuxei32_vMicro<uint8_t>;
    template class Vsuxei32_vMicro<uint16_t>;
    template class Vsuxei32_vMicro<uint32_t>;
    template class Vsuxei32_vMicro<uint64_t>;
    ;


// VsStrideOp::vsse32_v((['\n                    Mem_vc.as<uint32_t>()[0] = Vs3_uw[microIdx];\n                '], {'inst_flags': 'SimdStridedStoreOp'}))


Fault
Vsse32_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Fault fault = NoFault;
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<uint32_t>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    constexpr uint8_t elem_size = sizeof(Vs3[0]);
    
        EA = Rs1 + Rs2 * (regIdx * vlenb / elem_size + microIdx);
    ;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint32_t mem_size = elem_size;
    const std::vector<bool> byte_enable(mem_size, true);

    size_t ei = this->regIdx * vlenb / elem_size + this->microIdx;
    if (machInst.vm || elem_mask(v0, ei)) {
        
                    Mem.as<uint32_t>()[0] = Vs3[microIdx];
                ;
        fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA,
                             memAccessFlags, nullptr, byte_enable);
    }
    return fault;
}



Fault
Vsse32_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    Fault fault = NoFault;
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<uint32_t>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    constexpr uint8_t elem_size = sizeof(Vs3[0]);
    
        EA = Rs1 + Rs2 * (regIdx * vlenb / elem_size + microIdx);
    ;

    uint32_t mem_size = elem_size;

    size_t ei = this->regIdx * vlenb / elem_size + this->microIdx;
    bool need_store = machInst.vm || elem_mask(v0, ei);
    if (need_store) {
        const std::vector<bool> byte_enable(mem_size, need_store);
        
                    Mem.as<uint32_t>()[0] = Vs3[microIdx];
                ;
        fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA,
                            memAccessFlags, nullptr, byte_enable);
    }
    return fault;
}



Fault
Vsse32_vMicro::completeAcc(PacketPtr pkt, ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    return NoFault;
}


// VsIndexOp::vsoxei32_v((['\n                    Mem_vc.as<vu>()[0] = Vs3_vu[vs3ElemIdx];\n                ', '\n                    EA = Rs1 + Vs2_uw[vs2ElemIdx];\n                '], {'inst_flags': 'SimdIndexedStoreOp'}))


template<typename ElemType>
Fault
Vsoxei32_vMicro<ElemType>::execute(ExecContext *xc,
    trace::InstRecord *traceData)const
{
    using vu = std::make_unsigned_t<ElemType>;
    Fault fault = NoFault;
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    uint64_t Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<uint32_t>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
                    EA = Rs1 + Vs2[vs2ElemIdx];
                ;
    constexpr uint8_t elem_size = sizeof(Vs3[0]);
    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint32_t mem_size = elem_size;
    const std::vector<bool> byte_enable(mem_size, true);

    size_t ei = this->vs3RegIdx * vlenb / elem_size + this->vs3ElemIdx;
    if (machInst.vm || elem_mask(v0, ei)) {
        
                    Mem.as<vu>()[0] = Vs3[vs3ElemIdx];
                ; /* Mem[0] = Vs3[this->vs3ElemIdx] */
        fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA,
                             memAccessFlags, nullptr, byte_enable);
    }
    return fault;
}



template<typename ElemType>
Fault
Vsoxei32_vMicro<ElemType>::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    using vu = std::make_unsigned_t<ElemType>;
    Fault fault = NoFault;
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    uint64_t Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<uint32_t>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
                    EA = Rs1 + Vs2[vs2ElemIdx];
                ;
    constexpr uint8_t elem_size = sizeof(Vs3[0]);
    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    constexpr uint8_t mem_size = elem_size;
    const std::vector<bool> byte_enable(mem_size, true);

    size_t ei = this->vs3RegIdx * vlenb / elem_size + this->vs3ElemIdx;
    if (machInst.vm || elem_mask(v0, ei)) {
        
                    Mem.as<vu>()[0] = Vs3[vs3ElemIdx];
                ; /* Mem[0] = Vs3[this->vs3ElemIdx] */
        fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA,
                             memAccessFlags, nullptr, byte_enable);
    }
    return fault;
}



template<typename ElemType>
Fault
Vsoxei32_vMicro<ElemType>::completeAcc(PacketPtr pkt, ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    return NoFault;
}


    template class Vsoxei32_vMicro<uint8_t>;
    template class Vsoxei32_vMicro<uint16_t>;
    template class Vsoxei32_vMicro<uint32_t>;
    template class Vsoxei32_vMicro<uint64_t>;
    ;


// Unknown::unknown(([], {}))

// VseOp::vse64_v((['\n                            Mem_vc.as<uint64_t>()[i] = Vs3_ud[i];\n                        '], {'inst_flags': 'SimdUnitStrideStoreOp'}))


Fault
Vse64_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint64_t>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);
    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;
    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask(v0, ei)) {
            
                            Mem.as<uint64_t>()[i] = Vs3[i];
                        ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vse64_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    Addr EA;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint64_t>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
        EA = Rs1 + vlenb * microIdx;
    ;

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);
    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;
    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask(v0, ei)) {
            
                            Mem.as<uint64_t>()[i] = Vs3[i];
                        ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vse64_vMicro::completeAcc(PacketPtr pkt, ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    return NoFault;
}


// VsSegOp::vsseg2e64_v(['\n                                Mem_vc.as<uint64_t>()[i] = Vs3_ud[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


Fault
Vsseg2e64_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint64_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vsseg inst");

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint64_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg2e64_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint64_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
        panic_if(((1 << vlmul) * this->numFields) > 8,
            "LMUL value is illegal for vsseg inst");


    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint64_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg2e64_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    return NoFault;
}


// VsSegOp::vsseg3e64_v(['\n                                Mem_vc.as<uint64_t>()[i] = Vs3_ud[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


Fault
Vsseg3e64_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint64_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vsseg inst");

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint64_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg3e64_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint64_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
        panic_if(((1 << vlmul) * this->numFields) > 8,
            "LMUL value is illegal for vsseg inst");


    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint64_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg3e64_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    return NoFault;
}


// VsSegOp::vsseg4e64_v(['\n                                Mem_vc.as<uint64_t>()[i] = Vs3_ud[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


Fault
Vsseg4e64_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint64_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vsseg inst");

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint64_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg4e64_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint64_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
        panic_if(((1 << vlmul) * this->numFields) > 8,
            "LMUL value is illegal for vsseg inst");


    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint64_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg4e64_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    return NoFault;
}


// VsSegOp::vsseg5e64_v(['\n                                Mem_vc.as<uint64_t>()[i] = Vs3_ud[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


Fault
Vsseg5e64_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint64_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vsseg inst");

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint64_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg5e64_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint64_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
        panic_if(((1 << vlmul) * this->numFields) > 8,
            "LMUL value is illegal for vsseg inst");


    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint64_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg5e64_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    return NoFault;
}


// VsSegOp::vsseg6e64_v(['\n                                Mem_vc.as<uint64_t>()[i] = Vs3_ud[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


Fault
Vsseg6e64_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint64_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vsseg inst");

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint64_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg6e64_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint64_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
        panic_if(((1 << vlmul) * this->numFields) > 8,
            "LMUL value is illegal for vsseg inst");


    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint64_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg6e64_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    return NoFault;
}


// VsSegOp::vsseg7e64_v(['\n                                Mem_vc.as<uint64_t>()[i] = Vs3_ud[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


Fault
Vsseg7e64_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint64_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vsseg inst");

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint64_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg7e64_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint64_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
        panic_if(((1 << vlmul) * this->numFields) > 8,
            "LMUL value is illegal for vsseg inst");


    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint64_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg7e64_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    return NoFault;
}


// VsSegOp::vsseg8e64_v(['\n                                Mem_vc.as<uint64_t>()[i] = Vs3_ud[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


Fault
Vsseg8e64_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint64_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    panic_if(((1 << vlmul) * this->numFields) > 8,
        "LMUL value is illegal for vsseg inst");

    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint64_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg8e64_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{

    Addr EA;

    const size_t eewb = width_EEW(machInst.width) / 8;
    const size_t mem_size = eewb * microVl;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs3 = tmp_s1.as<uint64_t>();
;
    
        EA = Rs1 + mem_size * (microIdx + (field * numMicroops));
    ;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
        panic_if(((1 << vlmul) * this->numFields) > 8,
            "LMUL value is illegal for vsseg inst");


    const size_t micro_vlmax = vlen / width_EEW(machInst.width);

    std::vector<bool> byte_enable(mem_size, false);
    size_t ei;
    for (size_t i = 0; i < microVl; i++) {
        ei = i + micro_vlmax * microIdx;
        if (machInst.vm || elem_mask_vseg(v0, ei + (field * microVl),
            this->numFields)) {
            
                                Mem.as<uint64_t>()[i] = Vs3[i];
                            ;
            auto it = byte_enable.begin() + i * eewb;
            std::fill(it, it + eewb, true);
        }
    }

    Fault fault;
    fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA, memAccessFlags,
                         nullptr, byte_enable);
    return fault;
}



Fault
Vsseg8e64_vMicro::completeAcc(PacketPtr pkt, ExecContext *xc,
                            trace::InstRecord *traceData) const
{
    return NoFault;
}


// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// VsIndexOp::vsuxei64_v((['\n                    Mem_vc.as<vu>()[0] = Vs3_vu[vs3ElemIdx];\n                ', '\n                    EA = Rs1 + Vs2_ud[vs2ElemIdx];\n                '], {'inst_flags': 'SimdIndexedStoreOp'}))


template<typename ElemType>
Fault
Vsuxei64_vMicro<ElemType>::execute(ExecContext *xc,
    trace::InstRecord *traceData)const
{
    using vu = std::make_unsigned_t<ElemType>;
    Fault fault = NoFault;
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    uint64_t Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<uint64_t>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
                    EA = Rs1 + Vs2[vs2ElemIdx];
                ;
    constexpr uint8_t elem_size = sizeof(Vs3[0]);
    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint32_t mem_size = elem_size;
    const std::vector<bool> byte_enable(mem_size, true);

    size_t ei = this->vs3RegIdx * vlenb / elem_size + this->vs3ElemIdx;
    if (machInst.vm || elem_mask(v0, ei)) {
        
                    Mem.as<vu>()[0] = Vs3[vs3ElemIdx];
                ; /* Mem[0] = Vs3[this->vs3ElemIdx] */
        fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA,
                             memAccessFlags, nullptr, byte_enable);
    }
    return fault;
}



template<typename ElemType>
Fault
Vsuxei64_vMicro<ElemType>::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    using vu = std::make_unsigned_t<ElemType>;
    Fault fault = NoFault;
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    uint64_t Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<uint64_t>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
                    EA = Rs1 + Vs2[vs2ElemIdx];
                ;
    constexpr uint8_t elem_size = sizeof(Vs3[0]);
    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    constexpr uint8_t mem_size = elem_size;
    const std::vector<bool> byte_enable(mem_size, true);

    size_t ei = this->vs3RegIdx * vlenb / elem_size + this->vs3ElemIdx;
    if (machInst.vm || elem_mask(v0, ei)) {
        
                    Mem.as<vu>()[0] = Vs3[vs3ElemIdx];
                ; /* Mem[0] = Vs3[this->vs3ElemIdx] */
        fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA,
                             memAccessFlags, nullptr, byte_enable);
    }
    return fault;
}



template<typename ElemType>
Fault
Vsuxei64_vMicro<ElemType>::completeAcc(PacketPtr pkt, ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    return NoFault;
}


    template class Vsuxei64_vMicro<uint8_t>;
    template class Vsuxei64_vMicro<uint16_t>;
    template class Vsuxei64_vMicro<uint32_t>;
    template class Vsuxei64_vMicro<uint64_t>;
    ;


// VsStrideOp::vsse64_v((['\n                    Mem_vc.as<uint64_t>()[0] = Vs3_ud[microIdx];\n                '], {'inst_flags': 'SimdStridedStoreOp'}))


Fault
Vsse64_vMicro::execute(ExecContext *xc, trace::InstRecord *traceData) const
{
    Fault fault = NoFault;
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<uint64_t>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    constexpr uint8_t elem_size = sizeof(Vs3[0]);
    
        EA = Rs1 + Rs2 * (regIdx * vlenb / elem_size + microIdx);
    ;

    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint32_t mem_size = elem_size;
    const std::vector<bool> byte_enable(mem_size, true);

    size_t ei = this->regIdx * vlenb / elem_size + this->microIdx;
    if (machInst.vm || elem_mask(v0, ei)) {
        
                    Mem.as<uint64_t>()[0] = Vs3[microIdx];
                ;
        fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA,
                             memAccessFlags, nullptr, byte_enable);
    }
    return fault;
}



Fault
Vsse64_vMicro::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    Fault fault = NoFault;
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if(!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs - 1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<uint64_t>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    constexpr uint8_t elem_size = sizeof(Vs3[0]);
    
        EA = Rs1 + Rs2 * (regIdx * vlenb / elem_size + microIdx);
    ;

    uint32_t mem_size = elem_size;

    size_t ei = this->regIdx * vlenb / elem_size + this->microIdx;
    bool need_store = machInst.vm || elem_mask(v0, ei);
    if (need_store) {
        const std::vector<bool> byte_enable(mem_size, need_store);
        
                    Mem.as<uint64_t>()[0] = Vs3[microIdx];
                ;
        fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA,
                            memAccessFlags, nullptr, byte_enable);
    }
    return fault;
}



Fault
Vsse64_vMicro::completeAcc(PacketPtr pkt, ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    return NoFault;
}


// VsIndexOp::vsoxei64_v((['\n                    Mem_vc.as<vu>()[0] = Vs3_vu[vs3ElemIdx];\n                ', '\n                    EA = Rs1 + Vs2_ud[vs2ElemIdx];\n                '], {'inst_flags': 'SimdIndexedStoreOp'}))


template<typename ElemType>
Fault
Vsoxei64_vMicro<ElemType>::execute(ExecContext *xc,
    trace::InstRecord *traceData)const
{
    using vu = std::make_unsigned_t<ElemType>;
    Fault fault = NoFault;
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    uint64_t Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<uint64_t>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
                    EA = Rs1 + Vs2[vs2ElemIdx];
                ;
    constexpr uint8_t elem_size = sizeof(Vs3[0]);
    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    uint32_t mem_size = elem_size;
    const std::vector<bool> byte_enable(mem_size, true);

    size_t ei = this->vs3RegIdx * vlenb / elem_size + this->vs3ElemIdx;
    if (machInst.vm || elem_mask(v0, ei)) {
        
                    Mem.as<vu>()[0] = Vs3[vs3ElemIdx];
                ; /* Mem[0] = Vs3[this->vs3ElemIdx] */
        fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA,
                             memAccessFlags, nullptr, byte_enable);
    }
    return fault;
}



template<typename ElemType>
Fault
Vsoxei64_vMicro<ElemType>::initiateAcc(ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    using vu = std::make_unsigned_t<ElemType>;
    Fault fault = NoFault;
    Addr EA;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);
    uint64_t Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
RiscvISA::VecRegContainer Mem = {};
;
    Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<uint64_t>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
                    EA = Rs1 + Vs2[vs2ElemIdx];
                ;
    constexpr uint8_t elem_size = sizeof(Vs3[0]);
    RiscvISA::vreg_t tmp_v0;
    uint8_t *v0;
    if (!machInst.vm) {
        xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
        v0 = tmp_v0.as<uint8_t>();
    }

    constexpr uint8_t mem_size = elem_size;
    const std::vector<bool> byte_enable(mem_size, true);

    size_t ei = this->vs3RegIdx * vlenb / elem_size + this->vs3ElemIdx;
    if (machInst.vm || elem_mask(v0, ei)) {
        
                    Mem.as<vu>()[0] = Vs3[vs3ElemIdx];
                ; /* Mem[0] = Vs3[this->vs3ElemIdx] */
        fault = xc->writeMem(Mem.as<uint8_t>(), mem_size, EA,
                             memAccessFlags, nullptr, byte_enable);
    }
    return fault;
}



template<typename ElemType>
Fault
Vsoxei64_vMicro<ElemType>::completeAcc(PacketPtr pkt, ExecContext* xc,
                            trace::InstRecord* traceData) const
{
    return NoFault;
}


    template class Vsoxei64_vMicro<uint8_t>;
    template class Vsoxei64_vMicro<uint16_t>;
    template class Vsoxei64_vMicro<uint32_t>;
    template class Vsoxei64_vMicro<uint64_t>;
    ;


// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// LoadReserved::lr_w((['\n                    Rd_sd = Mem_sw;\n                '], {'mem_flags': 'LLSC'}))

    Fault
    Lr_w::Lr_wMicro::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        Addr EA;

        int64_t Rd = 0;
uint64_t Rs1 = 0;
int32_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
;
        EA = rvSext(Rs1);;

        {
            Fault fault =
                readMemAtomicLE(xc, traceData, EA, Mem, memAccessFlags);
            if (fault != NoFault)
                return fault;
        }

        
                    Rd = Mem;
                ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

    Fault
    Lr_w::Lr_wMicro::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
int32_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
;
        EA = rvSext(Rs1);;

        return initiateMemRead(xc, traceData, EA, Mem, memAccessFlags);
    }

    Fault
    Lr_w::Lr_wMicro::completeAcc(PacketPtr pkt,
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int32_t Mem = {};
;
        ;

        getMemLE(pkt, Mem, traceData);

        
                    Rd = Mem;
                ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// StoreCond::sc_w((['\n                    Mem_uw = Rs2_uw;\n                ', '\n                    Rd = rvSext(result);\n                '], {'inst_flags': 'IsStoreConditional', 'mem_flags': 'LLSC'}))

    Fault Sc_w::Sc_wMicro::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;
        uint64_t result;

        uint64_t Rd = 0;
uint64_t Rs1 = 0;
uint32_t Rs2 = 0;
uint32_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1);;

        
                    Mem = Rs2;
                ;

        {
            Fault fault =
                writeMemAtomicLE(xc, traceData, Mem, EA, memAccessFlags,
                        &result);
            if (fault != NoFault)
                return fault;
        }
        // RISC-V has the opposite convention gem5 has for success flags,
        // so we invert the result here.
        result = !result;

        
                    Rd = rvSext(result);
                ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

    Fault
    Sc_w::Sc_wMicro::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
uint32_t Rs2 = 0;
uint32_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1);;
        
                    Mem = Rs2;
                ;

        {
            Fault fault = writeMemTimingLE(xc, traceData, Mem, EA,
                memAccessFlags, nullptr);
            if (fault != NoFault)
                return fault;
        }

        ;

        return NoFault;
    }

    Fault Sc_w::Sc_wMicro::completeAcc(Packet *pkt,
          ExecContext *xc, trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
;

        // RISC-V has the opposite convention gem5 has for success flags,
        // so we invert the result here.
        uint64_t result = !pkt->req->getExtraData();

        
                    Rd = rvSext(result);
                ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// AtomicMemOp::amoadd_w((['\n                    Rd_sd = Mem_sw;\n                ', '\n                    TypedAtomicOpFunctor<int32_t> *amo_op =\n                          new AtomicGenericOp<int32_t>(Rs2_sw,\n                                  [](int32_t* b, int32_t a){ *b += a; });\n                '], {'mem_flags': 'ATOMIC_RETURN_OP'}))

    Fault Amoadd_w::Amoadd_wRMW::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        int64_t Rd = 0;
uint64_t Rs1 = 0;
int32_t Rs2 = 0;
int32_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1);;
        
                    TypedAtomicOpFunctor<int32_t> *amo_op =
                          new AtomicGenericOp<int32_t>(Rs2,
                                  [](int32_t* b, int32_t a){ *b += a; });
                ;

        assert(amo_op);

        {
            Fault fault =
                amoMemAtomicLE(xc, traceData, Mem, EA, memAccessFlags, amo_op);
            if (fault != NoFault)
                return fault;
        }

        
                    Rd = Mem;
                ;
         ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

    Fault
    Amoadd_w::Amoadd_wRMW::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
int32_t Rs2 = 0;
int32_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1);;
        
                    TypedAtomicOpFunctor<int32_t> *amo_op =
                          new AtomicGenericOp<int32_t>(Rs2,
                                  [](int32_t* b, int32_t a){ *b += a; });
                ;

        assert(amo_op);

        return initiateMemAMO(xc, traceData, EA, Mem, memAccessFlags, amo_op);
    }

    Fault Amoadd_w::Amoadd_wRMW::completeAcc(Packet *pkt,
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int32_t Mem = {};
;
        ;

        getMemLE(pkt, Mem, traceData);

        
                    Rd = Mem;
                ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// AtomicMemOp::amoswap_w((['\n                    Rd_sd = Mem_sw;\n                ', '\n                    TypedAtomicOpFunctor<uint32_t> *amo_op =\n                          new AtomicGenericOp<uint32_t>(Rs2_uw,\n                                  [](uint32_t* b, uint32_t a){ *b = a; });\n                '], {'mem_flags': 'ATOMIC_RETURN_OP'}))

    Fault Amoswap_w::Amoswap_wRMW::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        int64_t Rd = 0;
uint64_t Rs1 = 0;
uint32_t Rs2 = 0;
int32_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1);;
        
                    TypedAtomicOpFunctor<uint32_t> *amo_op =
                          new AtomicGenericOp<uint32_t>(Rs2,
                                  [](uint32_t* b, uint32_t a){ *b = a; });
                ;

        assert(amo_op);

        {
            Fault fault =
                amoMemAtomicLE(xc, traceData, Mem, EA, memAccessFlags, amo_op);
            if (fault != NoFault)
                return fault;
        }

        
                    Rd = Mem;
                ;
         ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

    Fault
    Amoswap_w::Amoswap_wRMW::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
uint32_t Rs2 = 0;
int32_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1);;
        
                    TypedAtomicOpFunctor<uint32_t> *amo_op =
                          new AtomicGenericOp<uint32_t>(Rs2,
                                  [](uint32_t* b, uint32_t a){ *b = a; });
                ;

        assert(amo_op);

        return initiateMemAMO(xc, traceData, EA, Mem, memAccessFlags, amo_op);
    }

    Fault Amoswap_w::Amoswap_wRMW::completeAcc(Packet *pkt,
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int32_t Mem = {};
;
        ;

        getMemLE(pkt, Mem, traceData);

        
                    Rd = Mem;
                ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// AtomicMemOp::amoxor_w((['\n                    Rd_sd = Mem_sw;\n                ', '\n                    TypedAtomicOpFunctor<uint32_t> *amo_op =\n                          new AtomicGenericOp<uint32_t>(Rs2_uw,\n                                  [](uint32_t* b, uint32_t a){ *b ^= a; });\n                '], {'mem_flags': 'ATOMIC_RETURN_OP'}))

    Fault Amoxor_w::Amoxor_wRMW::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        int64_t Rd = 0;
uint64_t Rs1 = 0;
uint32_t Rs2 = 0;
int32_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1);;
        
                    TypedAtomicOpFunctor<uint32_t> *amo_op =
                          new AtomicGenericOp<uint32_t>(Rs2,
                                  [](uint32_t* b, uint32_t a){ *b ^= a; });
                ;

        assert(amo_op);

        {
            Fault fault =
                amoMemAtomicLE(xc, traceData, Mem, EA, memAccessFlags, amo_op);
            if (fault != NoFault)
                return fault;
        }

        
                    Rd = Mem;
                ;
         ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

    Fault
    Amoxor_w::Amoxor_wRMW::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
uint32_t Rs2 = 0;
int32_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1);;
        
                    TypedAtomicOpFunctor<uint32_t> *amo_op =
                          new AtomicGenericOp<uint32_t>(Rs2,
                                  [](uint32_t* b, uint32_t a){ *b ^= a; });
                ;

        assert(amo_op);

        return initiateMemAMO(xc, traceData, EA, Mem, memAccessFlags, amo_op);
    }

    Fault Amoxor_w::Amoxor_wRMW::completeAcc(Packet *pkt,
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int32_t Mem = {};
;
        ;

        getMemLE(pkt, Mem, traceData);

        
                    Rd = Mem;
                ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// AtomicMemOp::amoor_w((['\n                    Rd_sd = Mem_sw;\n                ', '\n                    TypedAtomicOpFunctor<uint32_t> *amo_op =\n                          new AtomicGenericOp<uint32_t>(Rs2_uw,\n                                  [](uint32_t* b, uint32_t a){ *b |= a; });\n                '], {'mem_flags': 'ATOMIC_RETURN_OP'}))

    Fault Amoor_w::Amoor_wRMW::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        int64_t Rd = 0;
uint64_t Rs1 = 0;
uint32_t Rs2 = 0;
int32_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1);;
        
                    TypedAtomicOpFunctor<uint32_t> *amo_op =
                          new AtomicGenericOp<uint32_t>(Rs2,
                                  [](uint32_t* b, uint32_t a){ *b |= a; });
                ;

        assert(amo_op);

        {
            Fault fault =
                amoMemAtomicLE(xc, traceData, Mem, EA, memAccessFlags, amo_op);
            if (fault != NoFault)
                return fault;
        }

        
                    Rd = Mem;
                ;
         ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

    Fault
    Amoor_w::Amoor_wRMW::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
uint32_t Rs2 = 0;
int32_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1);;
        
                    TypedAtomicOpFunctor<uint32_t> *amo_op =
                          new AtomicGenericOp<uint32_t>(Rs2,
                                  [](uint32_t* b, uint32_t a){ *b |= a; });
                ;

        assert(amo_op);

        return initiateMemAMO(xc, traceData, EA, Mem, memAccessFlags, amo_op);
    }

    Fault Amoor_w::Amoor_wRMW::completeAcc(Packet *pkt,
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int32_t Mem = {};
;
        ;

        getMemLE(pkt, Mem, traceData);

        
                    Rd = Mem;
                ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// AtomicMemOp::amoand_w((['\n                    Rd_sd = Mem_sw;\n                ', '\n                    TypedAtomicOpFunctor<uint32_t> *amo_op =\n                          new AtomicGenericOp<uint32_t>(Rs2_uw,\n                                  [](uint32_t* b, uint32_t a){ *b &= a; });\n                '], {'mem_flags': 'ATOMIC_RETURN_OP'}))

    Fault Amoand_w::Amoand_wRMW::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        int64_t Rd = 0;
uint64_t Rs1 = 0;
uint32_t Rs2 = 0;
int32_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1);;
        
                    TypedAtomicOpFunctor<uint32_t> *amo_op =
                          new AtomicGenericOp<uint32_t>(Rs2,
                                  [](uint32_t* b, uint32_t a){ *b &= a; });
                ;

        assert(amo_op);

        {
            Fault fault =
                amoMemAtomicLE(xc, traceData, Mem, EA, memAccessFlags, amo_op);
            if (fault != NoFault)
                return fault;
        }

        
                    Rd = Mem;
                ;
         ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

    Fault
    Amoand_w::Amoand_wRMW::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
uint32_t Rs2 = 0;
int32_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1);;
        
                    TypedAtomicOpFunctor<uint32_t> *amo_op =
                          new AtomicGenericOp<uint32_t>(Rs2,
                                  [](uint32_t* b, uint32_t a){ *b &= a; });
                ;

        assert(amo_op);

        return initiateMemAMO(xc, traceData, EA, Mem, memAccessFlags, amo_op);
    }

    Fault Amoand_w::Amoand_wRMW::completeAcc(Packet *pkt,
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int32_t Mem = {};
;
        ;

        getMemLE(pkt, Mem, traceData);

        
                    Rd = Mem;
                ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// AtomicMemOp::amomin_w((['\n                    Rd_sd = Mem_sw;\n                ', '\n                    TypedAtomicOpFunctor<int32_t> *amo_op =\n                      new AtomicGenericOp<int32_t>(Rs2_sw,\n                        [](int32_t* b, int32_t a){ if (a < *b) *b = a; });\n                '], {'mem_flags': 'ATOMIC_RETURN_OP'}))

    Fault Amomin_w::Amomin_wRMW::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        int64_t Rd = 0;
uint64_t Rs1 = 0;
int32_t Rs2 = 0;
int32_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1);;
        
                    TypedAtomicOpFunctor<int32_t> *amo_op =
                      new AtomicGenericOp<int32_t>(Rs2,
                        [](int32_t* b, int32_t a){ if (a < *b) *b = a; });
                ;

        assert(amo_op);

        {
            Fault fault =
                amoMemAtomicLE(xc, traceData, Mem, EA, memAccessFlags, amo_op);
            if (fault != NoFault)
                return fault;
        }

        
                    Rd = Mem;
                ;
         ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

    Fault
    Amomin_w::Amomin_wRMW::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
int32_t Rs2 = 0;
int32_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1);;
        
                    TypedAtomicOpFunctor<int32_t> *amo_op =
                      new AtomicGenericOp<int32_t>(Rs2,
                        [](int32_t* b, int32_t a){ if (a < *b) *b = a; });
                ;

        assert(amo_op);

        return initiateMemAMO(xc, traceData, EA, Mem, memAccessFlags, amo_op);
    }

    Fault Amomin_w::Amomin_wRMW::completeAcc(Packet *pkt,
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int32_t Mem = {};
;
        ;

        getMemLE(pkt, Mem, traceData);

        
                    Rd = Mem;
                ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// AtomicMemOp::amomax_w((['\n                    Rd_sd = Mem_sw;\n                ', '\n                    TypedAtomicOpFunctor<int32_t> *amo_op =\n                      new AtomicGenericOp<int32_t>(Rs2_sw,\n                        [](int32_t* b, int32_t a){ if (a > *b) *b = a; });\n                '], {'mem_flags': 'ATOMIC_RETURN_OP'}))

    Fault Amomax_w::Amomax_wRMW::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        int64_t Rd = 0;
uint64_t Rs1 = 0;
int32_t Rs2 = 0;
int32_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1);;
        
                    TypedAtomicOpFunctor<int32_t> *amo_op =
                      new AtomicGenericOp<int32_t>(Rs2,
                        [](int32_t* b, int32_t a){ if (a > *b) *b = a; });
                ;

        assert(amo_op);

        {
            Fault fault =
                amoMemAtomicLE(xc, traceData, Mem, EA, memAccessFlags, amo_op);
            if (fault != NoFault)
                return fault;
        }

        
                    Rd = Mem;
                ;
         ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

    Fault
    Amomax_w::Amomax_wRMW::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
int32_t Rs2 = 0;
int32_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1);;
        
                    TypedAtomicOpFunctor<int32_t> *amo_op =
                      new AtomicGenericOp<int32_t>(Rs2,
                        [](int32_t* b, int32_t a){ if (a > *b) *b = a; });
                ;

        assert(amo_op);

        return initiateMemAMO(xc, traceData, EA, Mem, memAccessFlags, amo_op);
    }

    Fault Amomax_w::Amomax_wRMW::completeAcc(Packet *pkt,
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int32_t Mem = {};
;
        ;

        getMemLE(pkt, Mem, traceData);

        
                    Rd = Mem;
                ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// AtomicMemOp::amominu_w((['\n                    Rd_sd = Mem_sw;\n                ', '\n                    TypedAtomicOpFunctor<uint32_t> *amo_op =\n                      new AtomicGenericOp<uint32_t>(Rs2_uw,\n                        [](uint32_t* b, uint32_t a){ if (a < *b) *b = a; });\n                '], {'mem_flags': 'ATOMIC_RETURN_OP'}))

    Fault Amominu_w::Amominu_wRMW::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        int64_t Rd = 0;
uint64_t Rs1 = 0;
uint32_t Rs2 = 0;
int32_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1);;
        
                    TypedAtomicOpFunctor<uint32_t> *amo_op =
                      new AtomicGenericOp<uint32_t>(Rs2,
                        [](uint32_t* b, uint32_t a){ if (a < *b) *b = a; });
                ;

        assert(amo_op);

        {
            Fault fault =
                amoMemAtomicLE(xc, traceData, Mem, EA, memAccessFlags, amo_op);
            if (fault != NoFault)
                return fault;
        }

        
                    Rd = Mem;
                ;
         ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

    Fault
    Amominu_w::Amominu_wRMW::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
uint32_t Rs2 = 0;
int32_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1);;
        
                    TypedAtomicOpFunctor<uint32_t> *amo_op =
                      new AtomicGenericOp<uint32_t>(Rs2,
                        [](uint32_t* b, uint32_t a){ if (a < *b) *b = a; });
                ;

        assert(amo_op);

        return initiateMemAMO(xc, traceData, EA, Mem, memAccessFlags, amo_op);
    }

    Fault Amominu_w::Amominu_wRMW::completeAcc(Packet *pkt,
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int32_t Mem = {};
;
        ;

        getMemLE(pkt, Mem, traceData);

        
                    Rd = Mem;
                ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// AtomicMemOp::amomaxu_w((['\n                    Rd_sd = Mem_sw;\n                ', '\n                    TypedAtomicOpFunctor<uint32_t> *amo_op =\n                      new AtomicGenericOp<uint32_t>(Rs2_uw,\n                        [](uint32_t* b, uint32_t a){ if (a > *b) *b = a; });\n                '], {'mem_flags': 'ATOMIC_RETURN_OP'}))

    Fault Amomaxu_w::Amomaxu_wRMW::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        int64_t Rd = 0;
uint64_t Rs1 = 0;
uint32_t Rs2 = 0;
int32_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1);;
        
                    TypedAtomicOpFunctor<uint32_t> *amo_op =
                      new AtomicGenericOp<uint32_t>(Rs2,
                        [](uint32_t* b, uint32_t a){ if (a > *b) *b = a; });
                ;

        assert(amo_op);

        {
            Fault fault =
                amoMemAtomicLE(xc, traceData, Mem, EA, memAccessFlags, amo_op);
            if (fault != NoFault)
                return fault;
        }

        
                    Rd = Mem;
                ;
         ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

    Fault
    Amomaxu_w::Amomaxu_wRMW::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
uint32_t Rs2 = 0;
int32_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1);;
        
                    TypedAtomicOpFunctor<uint32_t> *amo_op =
                      new AtomicGenericOp<uint32_t>(Rs2,
                        [](uint32_t* b, uint32_t a){ if (a > *b) *b = a; });
                ;

        assert(amo_op);

        return initiateMemAMO(xc, traceData, EA, Mem, memAccessFlags, amo_op);
    }

    Fault Amomaxu_w::Amomaxu_wRMW::completeAcc(Packet *pkt,
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int32_t Mem = {};
;
        ;

        getMemLE(pkt, Mem, traceData);

        
                    Rd = Mem;
                ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// Unknown::unknown(([], {}))

// LoadReserved::lr_d((['\n                        Rd_sd = Mem_sd;\n                    '], {'mem_flags': 'LLSC'}))

    Fault
    Lr_d::Lr_dMicro::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        Addr EA;

        int64_t Rd = 0;
uint64_t Rs1 = 0;
int64_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
;
        EA = rvSext(Rs1);;

        {
            Fault fault =
                readMemAtomicLE(xc, traceData, EA, Mem, memAccessFlags);
            if (fault != NoFault)
                return fault;
        }

        
                        Rd = Mem;
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

    Fault
    Lr_d::Lr_dMicro::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
int64_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
;
        EA = rvSext(Rs1);;

        return initiateMemRead(xc, traceData, EA, Mem, memAccessFlags);
    }

    Fault
    Lr_d::Lr_dMicro::completeAcc(PacketPtr pkt,
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int64_t Mem = {};
;
        ;

        getMemLE(pkt, Mem, traceData);

        
                        Rd = Mem;
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// StoreCond::sc_d((['\n                        Mem = Rs2;\n                    ', '\n                        Rd = result;\n                    '], {'mem_flags': 'LLSC', 'inst_flags': 'IsStoreConditional'}))

    Fault Sc_d::Sc_dMicro::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;
        uint64_t result;

        uint64_t Rd = 0;
uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
uint64_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1);;

        
                        Mem = Rs2;
                    ;

        {
            Fault fault =
                writeMemAtomicLE(xc, traceData, Mem, EA, memAccessFlags,
                        &result);
            if (fault != NoFault)
                return fault;
        }
        // RISC-V has the opposite convention gem5 has for success flags,
        // so we invert the result here.
        result = !result;

        
                        Rd = result;
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

    Fault
    Sc_d::Sc_dMicro::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
uint64_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1);;
        
                        Mem = Rs2;
                    ;

        {
            Fault fault = writeMemTimingLE(xc, traceData, Mem, EA,
                memAccessFlags, nullptr);
            if (fault != NoFault)
                return fault;
        }

        ;

        return NoFault;
    }

    Fault Sc_d::Sc_dMicro::completeAcc(Packet *pkt,
          ExecContext *xc, trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
;

        // RISC-V has the opposite convention gem5 has for success flags,
        // so we invert the result here.
        uint64_t result = !pkt->req->getExtraData();

        
                        Rd = result;
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// AtomicMemOp::amoadd_d((['\n                        Rd_sd = Mem_sd;\n                    ', '\n                        TypedAtomicOpFunctor<int64_t> *amo_op =\n                              new AtomicGenericOp<int64_t>(Rs2_sd,\n                                      [](int64_t* b, int64_t a){ *b += a; });\n                    '], {'mem_flags': 'ATOMIC_RETURN_OP'}))

    Fault Amoadd_d::Amoadd_dRMW::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        int64_t Rd = 0;
uint64_t Rs1 = 0;
int64_t Rs2 = 0;
int64_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1);;
        
                        TypedAtomicOpFunctor<int64_t> *amo_op =
                              new AtomicGenericOp<int64_t>(Rs2,
                                      [](int64_t* b, int64_t a){ *b += a; });
                    ;

        assert(amo_op);

        {
            Fault fault =
                amoMemAtomicLE(xc, traceData, Mem, EA, memAccessFlags, amo_op);
            if (fault != NoFault)
                return fault;
        }

        
                        Rd = Mem;
                    ;
         ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

    Fault
    Amoadd_d::Amoadd_dRMW::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
int64_t Rs2 = 0;
int64_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1);;
        
                        TypedAtomicOpFunctor<int64_t> *amo_op =
                              new AtomicGenericOp<int64_t>(Rs2,
                                      [](int64_t* b, int64_t a){ *b += a; });
                    ;

        assert(amo_op);

        return initiateMemAMO(xc, traceData, EA, Mem, memAccessFlags, amo_op);
    }

    Fault Amoadd_d::Amoadd_dRMW::completeAcc(Packet *pkt,
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int64_t Mem = {};
;
        ;

        getMemLE(pkt, Mem, traceData);

        
                        Rd = Mem;
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// AtomicMemOp::amoswap_d((['\n                        Rd_sd = Mem_sd;\n                    ', '\n                        TypedAtomicOpFunctor<uint64_t> *amo_op =\n                              new AtomicGenericOp<uint64_t>(Rs2_ud,\n                                      [](uint64_t* b, uint64_t a){ *b = a; });\n                    '], {'mem_flags': 'ATOMIC_RETURN_OP'}))

    Fault Amoswap_d::Amoswap_dRMW::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        int64_t Rd = 0;
uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
int64_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1);;
        
                        TypedAtomicOpFunctor<uint64_t> *amo_op =
                              new AtomicGenericOp<uint64_t>(Rs2,
                                      [](uint64_t* b, uint64_t a){ *b = a; });
                    ;

        assert(amo_op);

        {
            Fault fault =
                amoMemAtomicLE(xc, traceData, Mem, EA, memAccessFlags, amo_op);
            if (fault != NoFault)
                return fault;
        }

        
                        Rd = Mem;
                    ;
         ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

    Fault
    Amoswap_d::Amoswap_dRMW::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
int64_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1);;
        
                        TypedAtomicOpFunctor<uint64_t> *amo_op =
                              new AtomicGenericOp<uint64_t>(Rs2,
                                      [](uint64_t* b, uint64_t a){ *b = a; });
                    ;

        assert(amo_op);

        return initiateMemAMO(xc, traceData, EA, Mem, memAccessFlags, amo_op);
    }

    Fault Amoswap_d::Amoswap_dRMW::completeAcc(Packet *pkt,
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int64_t Mem = {};
;
        ;

        getMemLE(pkt, Mem, traceData);

        
                        Rd = Mem;
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// AtomicMemOp::amoxor_d((['\n                        Rd_sd = Mem_sd;\n                    ', '\n                        TypedAtomicOpFunctor<uint64_t> *amo_op =\n                              new AtomicGenericOp<uint64_t>(Rs2_ud,\n                                     [](uint64_t* b, uint64_t a){ *b ^= a; });\n                    '], {'mem_flags': 'ATOMIC_RETURN_OP'}))

    Fault Amoxor_d::Amoxor_dRMW::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        int64_t Rd = 0;
uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
int64_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1);;
        
                        TypedAtomicOpFunctor<uint64_t> *amo_op =
                              new AtomicGenericOp<uint64_t>(Rs2,
                                     [](uint64_t* b, uint64_t a){ *b ^= a; });
                    ;

        assert(amo_op);

        {
            Fault fault =
                amoMemAtomicLE(xc, traceData, Mem, EA, memAccessFlags, amo_op);
            if (fault != NoFault)
                return fault;
        }

        
                        Rd = Mem;
                    ;
         ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

    Fault
    Amoxor_d::Amoxor_dRMW::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
int64_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1);;
        
                        TypedAtomicOpFunctor<uint64_t> *amo_op =
                              new AtomicGenericOp<uint64_t>(Rs2,
                                     [](uint64_t* b, uint64_t a){ *b ^= a; });
                    ;

        assert(amo_op);

        return initiateMemAMO(xc, traceData, EA, Mem, memAccessFlags, amo_op);
    }

    Fault Amoxor_d::Amoxor_dRMW::completeAcc(Packet *pkt,
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int64_t Mem = {};
;
        ;

        getMemLE(pkt, Mem, traceData);

        
                        Rd = Mem;
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// AtomicMemOp::amoor_d((['\n                        Rd_sd = Mem_sd;\n                    ', '\n                        TypedAtomicOpFunctor<uint64_t> *amo_op =\n                              new AtomicGenericOp<uint64_t>(Rs2_ud,\n                                     [](uint64_t* b, uint64_t a){ *b |= a; });\n                    '], {'mem_flags': 'ATOMIC_RETURN_OP'}))

    Fault Amoor_d::Amoor_dRMW::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        int64_t Rd = 0;
uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
int64_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1);;
        
                        TypedAtomicOpFunctor<uint64_t> *amo_op =
                              new AtomicGenericOp<uint64_t>(Rs2,
                                     [](uint64_t* b, uint64_t a){ *b |= a; });
                    ;

        assert(amo_op);

        {
            Fault fault =
                amoMemAtomicLE(xc, traceData, Mem, EA, memAccessFlags, amo_op);
            if (fault != NoFault)
                return fault;
        }

        
                        Rd = Mem;
                    ;
         ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

    Fault
    Amoor_d::Amoor_dRMW::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
int64_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1);;
        
                        TypedAtomicOpFunctor<uint64_t> *amo_op =
                              new AtomicGenericOp<uint64_t>(Rs2,
                                     [](uint64_t* b, uint64_t a){ *b |= a; });
                    ;

        assert(amo_op);

        return initiateMemAMO(xc, traceData, EA, Mem, memAccessFlags, amo_op);
    }

    Fault Amoor_d::Amoor_dRMW::completeAcc(Packet *pkt,
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int64_t Mem = {};
;
        ;

        getMemLE(pkt, Mem, traceData);

        
                        Rd = Mem;
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// AtomicMemOp::amoand_d((['\n                        Rd_sd = Mem_sd;\n                    ', '\n                        TypedAtomicOpFunctor<uint64_t> *amo_op =\n                              new AtomicGenericOp<uint64_t>(Rs2_ud,\n                                     [](uint64_t* b, uint64_t a){ *b &= a; });\n                    '], {'mem_flags': 'ATOMIC_RETURN_OP'}))

    Fault Amoand_d::Amoand_dRMW::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        int64_t Rd = 0;
uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
int64_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1);;
        
                        TypedAtomicOpFunctor<uint64_t> *amo_op =
                              new AtomicGenericOp<uint64_t>(Rs2,
                                     [](uint64_t* b, uint64_t a){ *b &= a; });
                    ;

        assert(amo_op);

        {
            Fault fault =
                amoMemAtomicLE(xc, traceData, Mem, EA, memAccessFlags, amo_op);
            if (fault != NoFault)
                return fault;
        }

        
                        Rd = Mem;
                    ;
         ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

    Fault
    Amoand_d::Amoand_dRMW::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
int64_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1);;
        
                        TypedAtomicOpFunctor<uint64_t> *amo_op =
                              new AtomicGenericOp<uint64_t>(Rs2,
                                     [](uint64_t* b, uint64_t a){ *b &= a; });
                    ;

        assert(amo_op);

        return initiateMemAMO(xc, traceData, EA, Mem, memAccessFlags, amo_op);
    }

    Fault Amoand_d::Amoand_dRMW::completeAcc(Packet *pkt,
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int64_t Mem = {};
;
        ;

        getMemLE(pkt, Mem, traceData);

        
                        Rd = Mem;
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// AtomicMemOp::amomin_d((['\n                        Rd_sd = Mem_sd;\n                    ', '\n                        TypedAtomicOpFunctor<int64_t> *amo_op =\n                          new AtomicGenericOp<int64_t>(Rs2_sd,\n                            [](int64_t* b, int64_t a){ if (a < *b) *b = a; });\n                    '], {'mem_flags': 'ATOMIC_RETURN_OP'}))

    Fault Amomin_d::Amomin_dRMW::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        int64_t Rd = 0;
uint64_t Rs1 = 0;
int64_t Rs2 = 0;
int64_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1);;
        
                        TypedAtomicOpFunctor<int64_t> *amo_op =
                          new AtomicGenericOp<int64_t>(Rs2,
                            [](int64_t* b, int64_t a){ if (a < *b) *b = a; });
                    ;

        assert(amo_op);

        {
            Fault fault =
                amoMemAtomicLE(xc, traceData, Mem, EA, memAccessFlags, amo_op);
            if (fault != NoFault)
                return fault;
        }

        
                        Rd = Mem;
                    ;
         ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

    Fault
    Amomin_d::Amomin_dRMW::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
int64_t Rs2 = 0;
int64_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1);;
        
                        TypedAtomicOpFunctor<int64_t> *amo_op =
                          new AtomicGenericOp<int64_t>(Rs2,
                            [](int64_t* b, int64_t a){ if (a < *b) *b = a; });
                    ;

        assert(amo_op);

        return initiateMemAMO(xc, traceData, EA, Mem, memAccessFlags, amo_op);
    }

    Fault Amomin_d::Amomin_dRMW::completeAcc(Packet *pkt,
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int64_t Mem = {};
;
        ;

        getMemLE(pkt, Mem, traceData);

        
                        Rd = Mem;
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// AtomicMemOp::amomax_d((['\n                        Rd_sd = Mem_sd;\n                    ', '\n                        TypedAtomicOpFunctor<int64_t> *amo_op =\n                          new AtomicGenericOp<int64_t>(Rs2_sd,\n                            [](int64_t* b, int64_t a){ if (a > *b) *b = a; });\n                    '], {'mem_flags': 'ATOMIC_RETURN_OP'}))

    Fault Amomax_d::Amomax_dRMW::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        int64_t Rd = 0;
uint64_t Rs1 = 0;
int64_t Rs2 = 0;
int64_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1);;
        
                        TypedAtomicOpFunctor<int64_t> *amo_op =
                          new AtomicGenericOp<int64_t>(Rs2,
                            [](int64_t* b, int64_t a){ if (a > *b) *b = a; });
                    ;

        assert(amo_op);

        {
            Fault fault =
                amoMemAtomicLE(xc, traceData, Mem, EA, memAccessFlags, amo_op);
            if (fault != NoFault)
                return fault;
        }

        
                        Rd = Mem;
                    ;
         ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

    Fault
    Amomax_d::Amomax_dRMW::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
int64_t Rs2 = 0;
int64_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1);;
        
                        TypedAtomicOpFunctor<int64_t> *amo_op =
                          new AtomicGenericOp<int64_t>(Rs2,
                            [](int64_t* b, int64_t a){ if (a > *b) *b = a; });
                    ;

        assert(amo_op);

        return initiateMemAMO(xc, traceData, EA, Mem, memAccessFlags, amo_op);
    }

    Fault Amomax_d::Amomax_dRMW::completeAcc(Packet *pkt,
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int64_t Mem = {};
;
        ;

        getMemLE(pkt, Mem, traceData);

        
                        Rd = Mem;
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// AtomicMemOp::amominu_d((['\n                        Rd_sd = Mem_sd;\n                    ', '\n                        TypedAtomicOpFunctor<uint64_t> *amo_op =\n                          new AtomicGenericOp<uint64_t>(Rs2_ud,\n                            [](uint64_t* b, uint64_t a){\n                              if (a < *b) *b = a;\n                            });\n                    '], {'mem_flags': 'ATOMIC_RETURN_OP'}))

    Fault Amominu_d::Amominu_dRMW::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        int64_t Rd = 0;
uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
int64_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1);;
        
                        TypedAtomicOpFunctor<uint64_t> *amo_op =
                          new AtomicGenericOp<uint64_t>(Rs2,
                            [](uint64_t* b, uint64_t a){
                              if (a < *b) *b = a;
                            });
                    ;

        assert(amo_op);

        {
            Fault fault =
                amoMemAtomicLE(xc, traceData, Mem, EA, memAccessFlags, amo_op);
            if (fault != NoFault)
                return fault;
        }

        
                        Rd = Mem;
                    ;
         ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

    Fault
    Amominu_d::Amominu_dRMW::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
int64_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1);;
        
                        TypedAtomicOpFunctor<uint64_t> *amo_op =
                          new AtomicGenericOp<uint64_t>(Rs2,
                            [](uint64_t* b, uint64_t a){
                              if (a < *b) *b = a;
                            });
                    ;

        assert(amo_op);

        return initiateMemAMO(xc, traceData, EA, Mem, memAccessFlags, amo_op);
    }

    Fault Amominu_d::Amominu_dRMW::completeAcc(Packet *pkt,
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int64_t Mem = {};
;
        ;

        getMemLE(pkt, Mem, traceData);

        
                        Rd = Mem;
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// AtomicMemOp::amomaxu_d((['\n                        Rd_sd = Mem_sd;\n                    ', '\n                        TypedAtomicOpFunctor<uint64_t> *amo_op =\n                          new AtomicGenericOp<uint64_t>(Rs2_ud,\n                            [](uint64_t* b, uint64_t a){\n                              if (a > *b) *b = a;\n                            });\n                    '], {'mem_flags': 'ATOMIC_RETURN_OP'}))

    Fault Amomaxu_d::Amomaxu_dRMW::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        int64_t Rd = 0;
uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
int64_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1);;
        
                        TypedAtomicOpFunctor<uint64_t> *amo_op =
                          new AtomicGenericOp<uint64_t>(Rs2,
                            [](uint64_t* b, uint64_t a){
                              if (a > *b) *b = a;
                            });
                    ;

        assert(amo_op);

        {
            Fault fault =
                amoMemAtomicLE(xc, traceData, Mem, EA, memAccessFlags, amo_op);
            if (fault != NoFault)
                return fault;
        }

        
                        Rd = Mem;
                    ;
         ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

    Fault
    Amomaxu_d::Amomaxu_dRMW::initiateAcc(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        Addr EA;

        uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
int64_t Mem = {};
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        EA = rvSext(Rs1);;
        
                        TypedAtomicOpFunctor<uint64_t> *amo_op =
                          new AtomicGenericOp<uint64_t>(Rs2,
                            [](uint64_t* b, uint64_t a){
                              if (a > *b) *b = a;
                            });
                    ;

        assert(amo_op);

        return initiateMemAMO(xc, traceData, EA, Mem, memAccessFlags, amo_op);
    }

    Fault Amomaxu_d::Amomaxu_dRMW::completeAcc(Packet *pkt,
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int64_t Mem = {};
;
        ;

        getMemLE(pkt, Mem, traceData);

        
                        Rd = Mem;
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// ROp::add(['\n                            Rd = rvSext(Rs1_sd + Rs2_sd);\n                        '],{})

    Fault
    Add::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
int64_t Rs1 = 0;
int64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                            Rd = rvSext(Rs1 + Rs2);
                        ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::sub(['\n                            Rd = rvSext(Rs1_sd - Rs2_sd);\n                        '],{})

    Fault
    Sub::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
int64_t Rs1 = 0;
int64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                            Rd = rvSext(Rs1 - Rs2);
                        ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// Unknown::unknown(([], {}))

// ROp::mul(['\n                            Rd = rvSext(Rs1_sd * Rs2_sd);\n                        ', 'IntMultOp'],{})

    Fault
    Mul::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
int64_t Rs1 = 0;
int64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                            Rd = rvSext(Rs1 * Rs2);
                        ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// Unknown::unknown(([], {}))

// ROp::sha512sum0r(['\n                                Rd_sw = _rvk_emu_sha512sum0r(Rs1_sw, Rs2_sw);\n                            '],{})

    Fault
    Sha512sum0r::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int32_t Rd = 0;
int32_t Rs1 = 0;
int32_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                                Rd = _rvk_emu_sha512sum0r(Rs1, Rs2);
                            ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// ROp::sha512sum1r(['\n                                Rd_sw = _rvk_emu_sha512sum1r(Rs1_sw, Rs2_sw);\n                            '],{})

    Fault
    Sha512sum1r::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int32_t Rd = 0;
int32_t Rs1 = 0;
int32_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                                Rd = _rvk_emu_sha512sum1r(Rs1, Rs2);
                            ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// ROp::sha512sig0l(['\n                                Rd_sw = _rvk_emu_sha512sig0l(Rs1_sw, Rs2_sw);\n                            '],{})

    Fault
    Sha512sig0l::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int32_t Rd = 0;
int32_t Rs1 = 0;
int32_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                                Rd = _rvk_emu_sha512sig0l(Rs1, Rs2);
                            ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// ROp::sha512sig1l(['\n                                Rd_sw = _rvk_emu_sha512sig1l(Rs1_sw, Rs2_sw);\n                            '],{})

    Fault
    Sha512sig1l::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int32_t Rd = 0;
int32_t Rs1 = 0;
int32_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                                Rd = _rvk_emu_sha512sig1l(Rs1, Rs2);
                            ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// ROp::sha512sig0h(['\n                                Rd_sw = _rvk_emu_sha512sig0h(Rs1_sw, Rs2_sw);\n                            '],{})

    Fault
    Sha512sig0h::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int32_t Rd = 0;
int32_t Rs1 = 0;
int32_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                                Rd = _rvk_emu_sha512sig0h(Rs1, Rs2);
                            ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// ROp::sha512sig1h(['\n                                Rd_sw = _rvk_emu_sha512sig1h(Rs1_sw, Rs2_sw);\n                            '],{})

    Fault
    Sha512sig1h::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int32_t Rd = 0;
int32_t Rs1 = 0;
int32_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                                Rd = _rvk_emu_sha512sig1h(Rs1, Rs2);
                            ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// BSOp::aes32esi((['\n                            Rd_sw = _rvk_emu_aes32esi(Rs1_sw, Rs2_sw, bs);\n                        '], {}))

    Fault
    Aes32esi::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int32_t Rd = 0;
int32_t Rs1 = 0;
int32_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                            Rd = _rvk_emu_aes32esi(Rs1, Rs2, bs);
                        ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// Unknown::unknown(([], {}))

// BSOp::aes32esmi((['\n                            Rd_sw = _rvk_emu_aes32esmi(Rs1_sw, Rs2_sw, bs);\n                        '], {}))

    Fault
    Aes32esmi::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int32_t Rd = 0;
int32_t Rs1 = 0;
int32_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                            Rd = _rvk_emu_aes32esmi(Rs1, Rs2, bs);
                        ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// Unknown::unknown(([], {}))

// BSOp::aes32dsi((['\n                            Rd_sw = _rvk_emu_aes32dsi(Rs1_sw, Rs2_sw, bs);\n                        '], {}))

    Fault
    Aes32dsi::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int32_t Rd = 0;
int32_t Rs1 = 0;
int32_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                            Rd = _rvk_emu_aes32dsi(Rs1, Rs2, bs);
                        ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// Unknown::unknown(([], {}))

// BSOp::aes32dsmi((['\n                            Rd_sw = _rvk_emu_aes32dsmi(Rs1_sw, Rs2_sw, bs);\n                        '], {}))

    Fault
    Aes32dsmi::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int32_t Rd = 0;
int32_t Rs1 = 0;
int32_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                            Rd = _rvk_emu_aes32dsmi(Rs1, Rs2, bs);
                        ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// Unknown::unknown(([], {}))

// BSOp::sm4ed((['\n                        Rd_sw = _rvk_emu_sm4ed(Rs1_sw, Rs2_sw, bs);\n                    '], {}))

    Fault
    Sm4ed::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int32_t Rd = 0;
int32_t Rs1 = 0;
int32_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                        Rd = _rvk_emu_sm4ed(Rs1, Rs2, bs);
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::aes64es(['\n                                Rd_sd = _rvk_emu_aes64es(Rs1_sd, Rs2_sd);\n                            '],{})

    Fault
    Aes64es::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int64_t Rs1 = 0;
int64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                                Rd = _rvk_emu_aes64es(Rs1, Rs2);
                            ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// BSOp::sm4ks((['\n                        Rd_sw = _rvk_emu_sm4ks(Rs1_sw, Rs2_sw, bs);\n                    '], {}))

    Fault
    Sm4ks::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int32_t Rd = 0;
int32_t Rs1 = 0;
int32_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                        Rd = _rvk_emu_sm4ks(Rs1, Rs2, bs);
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::aes64esm(['\n                                Rd_sd = _rvk_emu_aes64esm(Rs1_sd, Rs2_sd);\n                            '],{})

    Fault
    Aes64esm::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int64_t Rs1 = 0;
int64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                                Rd = _rvk_emu_aes64esm(Rs1, Rs2);
                            ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// ROp::aes64ds(['\n                                Rd_sd = _rvk_emu_aes64ds(Rs1_sd, Rs2_sd);\n                            '],{})

    Fault
    Aes64ds::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int64_t Rs1 = 0;
int64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                                Rd = _rvk_emu_aes64ds(Rs1, Rs2);
                            ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// ROp::aes64dsm(['\n                                Rd_sd = _rvk_emu_aes64dsm(Rs1_sd, Rs2_sd);\n                            '],{})

    Fault
    Aes64dsm::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int64_t Rs1 = 0;
int64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                                Rd = _rvk_emu_aes64dsm(Rs1, Rs2);
                            ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// Unknown::unknown(([], {}))

// ROp::aes64ks2(['\n                                Rd_sd = _rvk_emu_aes64ks2(Rs1_sd, Rs2_sd);\n                            '],{})

    Fault
    Aes64ks2::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int64_t Rs1 = 0;
int64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                                Rd = _rvk_emu_aes64ks2(Rs1, Rs2);
                            ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// ROp::sll(['\n                        Rd = rvSext(Rs1 << rvSelect(Rs2<4:0>, Rs2<5:0>));\n                    '],{})

    Fault
    Sll::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                        Rd = rvSext(Rs1 << rvSelect(bits(Rs2, 4, 0), bits(Rs2, 5, 0)));
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::mulh(['\n                        if (machInst.rv_type == RV32) {\n                            Rd_sd = mulh<int32_t>(Rs1_sd, Rs2_sd);\n                        } else {\n                            Rd_sd = mulh<int64_t>(Rs1_sd, Rs2_sd);\n                        }\n                    ', 'IntMultOp'],{})

    Fault
    Mulh::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int64_t Rs1 = 0;
int64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                        if (machInst.rv_type == RV32) {
                            Rd = mulh<int32_t>(Rs1, Rs2);
                        } else {
                            Rd = mulh<int64_t>(Rs1, Rs2);
                        }
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::clmul(['\n                        uint64_t result = 0;\n                        for (int i = 0; i < rvSelect(32, 64); i++) {\n                            if ((Rs2 >> i) & 1) {\n                                result ^= Rs1 << i;\n                            }\n                        }\n                        Rd = rvSext(result);\n                    '],{})

    Fault
    Clmul::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                        uint64_t result = 0;
                        for (int i = 0; i < rvSelect(32, 64); i++) {
                            if ((Rs2 >> i) & 1) {
                                result ^= Rs1 << i;
                            }
                        }
                        Rd = rvSext(result);
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::bset(['\n                        Rs2 &= rvSelect(32 - 1, 64 - 1);\n                        Rd = rvSext(Rs1 | (UINT64_C(1) << Rs2));\n                    '],{})

    Fault
    Bset::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                        Rs2 &= rvSelect(32 - 1, 64 - 1);
                        Rd = rvSext(Rs1 | (UINT64_C(1) << Rs2));
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::bclr(['\n                        Rs2 &= rvSelect(32 - 1, 64 - 1);\n                        Rd = rvSext(Rs1 & (~(UINT64_C(1) << Rs2)));\n                    '],{})

    Fault
    Bclr::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                        Rs2 &= rvSelect(32 - 1, 64 - 1);
                        Rd = rvSext(Rs1 & (~(UINT64_C(1) << Rs2)));
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::rol(['\n                        uint64_t xlen = rvSelect(32, 64);\n                        int shamt = Rs2 & (xlen - 1);\n                        Rd = rvSext((Rs1 << shamt)\n                            | (rvZext(Rs1) >> ((xlen - shamt) & (xlen - 1))));\n                    '],{})

    Fault
    Rol::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                        uint64_t xlen = rvSelect(32, 64);
                        int shamt = Rs2 & (xlen - 1);
                        Rd = rvSext((Rs1 << shamt)
                            | (rvZext(Rs1) >> ((xlen - shamt) & (xlen - 1))));
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::binv(['\n                        Rs2 &= rvSelect(32 - 1, 64 - 1);\n                        Rd = rvSext(Rs1 ^ (UINT64_C(1) << Rs2));\n                    '],{})

    Fault
    Binv::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                        Rs2 &= rvSelect(32 - 1, 64 - 1);
                        Rd = rvSext(Rs1 ^ (UINT64_C(1) << Rs2));
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// Unknown::unknown(([], {}))

// ROp::slt(['\n                        Rd = (rvSext(Rs1_sd) < rvSext(Rs2_sd)) ? 1 : 0;\n                    '],{})

    Fault
    Slt::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
int64_t Rs1 = 0;
int64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                        Rd = (rvSext(Rs1) < rvSext(Rs2)) ? 1 : 0;
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::mulhsu(['\n                        if (machInst.rv_type == RV32) {\n                            Rd_sd = mulhsu<int32_t>(Rs1_sd, Rs2);\n                        } else {\n                            Rd_sd = mulhsu<int64_t>(Rs1_sd, Rs2);\n                        }\n                    ', 'IntMultOp'],{})

    Fault
    Mulhsu::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int64_t Rs1 = 0;
uint64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                        if (machInst.rv_type == RV32) {
                            Rd = mulhsu<int32_t>(Rs1, Rs2);
                        } else {
                            Rd = mulhsu<int64_t>(Rs1, Rs2);
                        }
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::clmulr(['\n                        uint64_t result = 0;\n                        uint64_t xlen = rvSelect(32, 64);\n                        uint64_t zextRs1 = rvZext(Rs1);\n                        for (int i = 0; i < xlen; i++) {\n                            if ((Rs2 >> i) & 1) {\n                                result ^= zextRs1 >> (xlen-i-1);\n                            }\n                        }\n                        Rd = rvSext(result);\n                    '],{})

    Fault
    Clmulr::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                        uint64_t result = 0;
                        uint64_t xlen = rvSelect(32, 64);
                        uint64_t zextRs1 = rvZext(Rs1);
                        for (int i = 0; i < xlen; i++) {
                            if ((Rs2 >> i) & 1) {
                                result ^= zextRs1 >> (xlen-i-1);
                            }
                        }
                        Rd = rvSext(result);
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::sh1add(['\n                        Rd = rvSext((Rs1 << 1) + Rs2);\n                    '],{})

    Fault
    Sh1add::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                        Rd = rvSext((Rs1 << 1) + Rs2);
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::xperm4(['\n                        if (machInst.rv_type == RV32) {\n                            Rd_sd = _rvk_emu_xperm4_32(Rs1_sd, Rs2_sd);\n                        } else {\n                            Rd_sd = _rvk_emu_xperm4_64(Rs1_sd, Rs2_sd);\n                        }\n                    '],{})

    Fault
    Xperm4::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int64_t Rs1 = 0;
int64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                        if (machInst.rv_type == RV32) {
                            Rd = _rvk_emu_xperm4_32(Rs1, Rs2);
                        } else {
                            Rd = _rvk_emu_xperm4_64(Rs1, Rs2);
                        }
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// Unknown::unknown(([], {}))

// ROp::sltu(['\n                        Rd = (rvZext(Rs1) < rvZext(Rs2)) ? 1 : 0;\n                    '],{})

    Fault
    Sltu::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                        Rd = (rvZext(Rs1) < rvZext(Rs2)) ? 1 : 0;
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::mulhu(['\n                        if (machInst.rv_type == RV32) {\n                            Rd = (int32_t)mulhu<uint32_t>(Rs1, Rs2);\n                        } else {\n                            Rd = mulhu<uint64_t>(Rs1, Rs2);\n                        }\n                    ', 'IntMultOp'],{})

    Fault
    Mulhu::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                        if (machInst.rv_type == RV32) {
                            Rd = (int32_t)mulhu<uint32_t>(Rs1, Rs2);
                        } else {
                            Rd = mulhu<uint64_t>(Rs1, Rs2);
                        }
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::clmulh(['\n                        uint64_t result = 0;\n                        uint64_t xlen = rvSelect(32, 64);\n                        uint64_t zextRs1 = rvZext(Rs1);\n                        for (int i = 1; i < xlen; i++) {\n                            if ((Rs2 >> i) & 1) {\n                                result ^= zextRs1 >> (xlen-i);\n                            }\n                        }\n                        // The MSB can never be 1, no need to sign extend.\n                        Rd = result;\n                    '],{})

    Fault
    Clmulh::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                        uint64_t result = 0;
                        uint64_t xlen = rvSelect(32, 64);
                        uint64_t zextRs1 = rvZext(Rs1);
                        for (int i = 1; i < xlen; i++) {
                            if ((Rs2 >> i) & 1) {
                                result ^= zextRs1 >> (xlen-i);
                            }
                        }
                        // The MSB can never be 1, no need to sign extend.
                        Rd = result;
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// Unknown::unknown(([], {}))

// ROp::xor(['\n                        Rd = rvSext(Rs1 ^ Rs2);\n                    '],{})

    Fault
    Xor::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                        Rd = rvSext(Rs1 ^ Rs2);
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::div(['\n                        if (machInst.rv_type == RV32) {\n                            Rd_sd = div<int32_t>(Rs1, Rs2);\n                        } else {\n                            Rd_sd = div<int64_t>(Rs1, Rs2);\n                        }\n                    ', 'IntDivOp'],{})

    Fault
    Div::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                        if (machInst.rv_type == RV32) {
                            Rd = div<int32_t>(Rs1, Rs2);
                        } else {
                            Rd = div<int64_t>(Rs1, Rs2);
                        }
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::pack(['\n                        int xlen = rvSelect(32, 64);\n                        Rd = rvSext(\n                            (bits(Rs2, xlen/2-1, 0) << (xlen / 2)) | \\\n                            bits(Rs1, xlen/2-1, 0)\n                        );\n                    '],{})

    Fault
    Pack::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                        int xlen = rvSelect(32, 64);
                        Rd = rvSext(
                            (bits(Rs2, xlen/2-1, 0) << (xlen / 2)) | \
                            bits(Rs1, xlen/2-1, 0)
                        );
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::min(['\n                        Rd_sd = std::min(rvSext(Rs1_sd), rvSext(Rs2_sd));\n                    '],{})

    Fault
    Min::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int64_t Rs1 = 0;
int64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                        Rd = std::min(rvSext(Rs1), rvSext(Rs2));
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::sh2add(['\n                        Rd = rvSext((Rs1 << 2) + Rs2);\n                    '],{})

    Fault
    Sh2add::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                        Rd = rvSext((Rs1 << 2) + Rs2);
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::xperm8(['\n                        if (machInst.rv_type == RV32) {\n                            Rd_sd = _rvk_emu_xperm8_32(Rs1_sd, Rs2_sd);\n                        } else {\n                            Rd_sd = _rvk_emu_xperm8_64(Rs1_sd, Rs2_sd);\n                        }\n                    '],{})

    Fault
    Xperm8::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int64_t Rs1 = 0;
int64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                        if (machInst.rv_type == RV32) {
                            Rd = _rvk_emu_xperm8_32(Rs1, Rs2);
                        } else {
                            Rd = _rvk_emu_xperm8_64(Rs1, Rs2);
                        }
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::xnor(['\n                        Rd = rvSext(~(Rs1 ^ Rs2));\n                    '],{})

    Fault
    Xnor::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                        Rd = rvSext(~(Rs1 ^ Rs2));
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// Unknown::unknown(([], {}))

// ROp::srl(['\n                        Rd = rvSext(rvZext(Rs1) >>\n                                    rvSelect(Rs2<4:0>, Rs2<5:0>));\n                    '],{})

    Fault
    Srl::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                        Rd = rvSext(rvZext(Rs1) >>
                                    rvSelect(bits(Rs2, 4, 0), bits(Rs2, 5, 0)));
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::divu(['\n                        if (machInst.rv_type == RV32) {\n                            Rd = (int32_t)divu<uint32_t>(Rs1, Rs2);\n                        } else {\n                            Rd = divu<uint64_t>(Rs1, Rs2);\n                        }\n                    ', 'IntDivOp'],{})

    Fault
    Divu::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                        if (machInst.rv_type == RV32) {
                            Rd = (int32_t)divu<uint32_t>(Rs1, Rs2);
                        } else {
                            Rd = divu<uint64_t>(Rs1, Rs2);
                        }
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::czero_eqz(['\n                        Rd = rvSext(Rs2) == 0 ? 0 : rvSext(Rs1);\n                    '],{})

    Fault
    Czero_eqz::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                        Rd = rvSext(Rs2) == 0 ? 0 : rvSext(Rs1);
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::sra(['\n                        Rd = rvSext(Rs1_sd) >> rvSelect(Rs2<4:0>, Rs2<5:0>);\n                    '],{})

    Fault
    Sra::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
int64_t Rs1 = 0;
uint64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                        Rd = rvSext(Rs1) >> rvSelect(bits(Rs2, 4, 0), bits(Rs2, 5, 0));
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::minu(['\n                        Rd = rvSext(std::min(rvZext(Rs1), rvZext(Rs2)));\n                    '],{})

    Fault
    Minu::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                        Rd = rvSext(std::min(rvZext(Rs1), rvZext(Rs2)));
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::bext(["\n                        Rs2 &= (rvSelect(32, 64) - 1);\n                        // It doesn't need to sign ext because MSB is always 0\n                        Rd = (Rs1 >> Rs2) & 0x1;\n                    "],{})

    Fault
    Bext::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                        Rs2 &= (rvSelect(32, 64) - 1);
                        // It doesn't need to sign ext because MSB is always 0
                        Rd = (Rs1 >> Rs2) & 0x1;
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::ror(['\n                        uint64_t xlen = rvSelect(32, 64);\n                        int shamt = Rs2 & (xlen - 1);\n                        Rd = rvSext((rvZext(Rs1) >> shamt)\n                            | (Rs1 << ((xlen - shamt) & (xlen - 1))));\n                    '],{})

    Fault
    Ror::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                        uint64_t xlen = rvSelect(32, 64);
                        int shamt = Rs2 & (xlen - 1);
                        Rd = rvSext((rvZext(Rs1) >> shamt)
                            | (Rs1 << ((xlen - shamt) & (xlen - 1))));
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// Unknown::unknown(([], {}))

// ROp::or(['\n                        Rd = rvSext(Rs1 | Rs2);\n                    '],{})

    Fault
    Or::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                        Rd = rvSext(Rs1 | Rs2);
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::rem(['\n                        if (machInst.rv_type == RV32) {\n                            Rd_sd = rem<int32_t>(Rs1, Rs2);\n                        } else {\n                            Rd_sd = rem<int64_t>(Rs1, Rs2);\n                        }\n                    ', 'IntDivOp'],{})

    Fault
    Rem::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                        if (machInst.rv_type == RV32) {
                            Rd = rem<int32_t>(Rs1, Rs2);
                        } else {
                            Rd = rem<int64_t>(Rs1, Rs2);
                        }
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::max(['\n                        Rd_sd = std::max(rvSext(Rs1_sd), rvSext(Rs2_sd));\n                    '],{})

    Fault
    Max::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int64_t Rs1 = 0;
int64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                        Rd = std::max(rvSext(Rs1), rvSext(Rs2));
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::sh3add(['\n                        Rd = rvSext((Rs1 << 3) + Rs2);\n                    '],{})

    Fault
    Sh3add::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                        Rd = rvSext((Rs1 << 3) + Rs2);
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::orn(['\n                        Rd = rvSext(Rs1 | (~Rs2));\n                    '],{})

    Fault
    Orn::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                        Rd = rvSext(Rs1 | (~Rs2));
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// Unknown::unknown(([], {}))

// ROp::and(['\n                        Rd = rvSext(Rs1 & Rs2);\n                    '],{})

    Fault
    And::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                        Rd = rvSext(Rs1 & Rs2);
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::remu(['\n                        if (machInst.rv_type == RV32) {\n                            Rd = (int32_t)remu<uint32_t>(Rs1, Rs2);\n                        } else {\n                            Rd = remu<uint64_t>(Rs1, Rs2);\n                        }\n                    ', 'IntDivOp'],{})

    Fault
    Remu::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                        if (machInst.rv_type == RV32) {
                            Rd = (int32_t)remu<uint32_t>(Rs1, Rs2);
                        } else {
                            Rd = remu<uint64_t>(Rs1, Rs2);
                        }
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::packh(["\n                        // It doesn't need to sign ext as MSB is always 0\n                        Rd = (Rs2_ub << 8) | Rs1_ub;\n                    "],{})

    Fault
    Packh::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint8_t Rs1 = 0;
uint8_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                        // It doesn't need to sign ext as MSB is always 0
                        Rd = (Rs2 << 8) | Rs1;
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::maxu(['\n                        Rd = rvSext(std::max(rvZext(Rs1), rvZext(Rs2)));\n                    '],{})

    Fault
    Maxu::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                        Rd = rvSext(std::max(rvZext(Rs1), rvZext(Rs2)));
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::czero_nez(['\n                        Rd = rvSext(Rs2) != 0 ? 0 : rvSext(Rs1);\n                    '],{})

    Fault
    Czero_nez::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                        Rd = rvSext(Rs2) != 0 ? 0 : rvSext(Rs1);
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::andn(['\n                        Rd = rvSext(Rs1 & (~Rs2));\n                    '],{})

    Fault
    Andn::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                        Rd = rvSext(Rs1 & (~Rs2));
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// UOp::lui((['\n            Rd = (sext<20>(imm) << 12);\n        '], {}))

    Fault
    Lui::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
;
        ;
        
            Rd = (sext<20>(imm) << 12);
        ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

    std::string
    Lui::generateDisassembly(Addr pc,
            const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// ROp::addw(['\n                            Rd_sd = Rs1_sw + Rs2_sw;\n                        '],{})

    Fault
    Addw::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int32_t Rs1 = 0;
int32_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                            Rd = Rs1 + Rs2;
                        ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::mulw(['\n                            Rd_sd = (int32_t)(Rs1_sw*Rs2_sw);\n                        ', 'IntMultOp'],{})

    Fault
    Mulw::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int32_t Rs1 = 0;
int32_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                            Rd = (int32_t)(Rs1*Rs2);
                        ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::add_uw(['\n                            Rd = Rs1_uw + Rs2;\n                        '],{})

    Fault
    Add_uw::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint32_t Rs1 = 0;
uint64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                            Rd = Rs1 + Rs2;
                        ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::subw(['\n                            Rd_sd = Rs1_sw - Rs2_sw;\n                        '],{})

    Fault
    Subw::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int32_t Rs1 = 0;
int32_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                            Rd = Rs1 - Rs2;
                        ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// Unknown::unknown(([], {}))

// ROp::sllw(['\n                            Rd_sd = Rs1_sw << Rs2<4:0>;\n                        '],{})

    Fault
    Sllw::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int32_t Rs1 = 0;
uint64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                            Rd = Rs1 << bits(Rs2, 4, 0);
                        ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::rolw(['\n                            int shamt = Rs2 & (32 - 1);\n                            Rd = (int32_t) ((Rs1_uw << shamt) | (Rs1_uw >> ((32 - shamt) & (32 - 1))));\n                        '],{})

    Fault
    Rolw::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint32_t Rs1 = 0;
uint64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                            int shamt = Rs2 & (32 - 1);
                            Rd = (int32_t) ((Rs1 << shamt) | (Rs1 >> ((32 - shamt) & (32 - 1))));
                        ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// Unknown::unknown(([], {}))

// ROp::sh1add_uw(['\n                            Rd = (((uint64_t)Rs1_uw) << 1) + Rs2;\n                        '],{})

    Fault
    Sh1add_uw::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint32_t Rs1 = 0;
uint64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                            Rd = (((uint64_t)Rs1) << 1) + Rs2;
                        ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// Unknown::unknown(([], {}))

// ROp::divw(['\n                            Rd_sd = div<int32_t>(Rs1, Rs2);\n                        ', 'IntDivOp'],{})

    Fault
    Divw::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                            Rd = div<int32_t>(Rs1, Rs2);
                        ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::packw(['\n                            Rd_sd = sext<32>((Rs2_uh << 16) | Rs1_uh);\n                        '],{})

    Fault
    Packw::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
uint16_t Rs1 = 0;
uint16_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                            Rd = sext<32>((Rs2 << 16) | Rs1);
                        ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::sh2add_uw(['\n                            Rd = (((uint64_t)Rs1_uw) << 2) + Rs2;\n                        '],{})

    Fault
    Sh2add_uw::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint32_t Rs1 = 0;
uint64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                            Rd = (((uint64_t)Rs1) << 2) + Rs2;
                        ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// Unknown::unknown(([], {}))

// ROp::srlw(['\n                            Rd_sd = (int32_t)(Rs1_uw >> Rs2<4:0>);\n                        '],{})

    Fault
    Srlw::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
uint32_t Rs1 = 0;
uint64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                            Rd = (int32_t)(Rs1 >> bits(Rs2, 4, 0));
                        ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::divuw(['\n                            Rd = sext<32>(divu<uint32_t>(Rs1, Rs2));\n                        ', 'IntDivOp'],{})

    Fault
    Divuw::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                            Rd = sext<32>(divu<uint32_t>(Rs1, Rs2));
                        ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::sraw(['\n                            Rd_sd = Rs1_sw >> Rs2<4:0>;\n                        '],{})

    Fault
    Sraw::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
int32_t Rs1 = 0;
uint64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                            Rd = Rs1 >> bits(Rs2, 4, 0);
                        ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::rorw(['\n                            int shamt = Rs2 & (32 - 1);\n                            Rd = (int32_t) ((Rs1_uw >> shamt) | (Rs1_uw << ((32 - shamt) & (32 - 1))));\n                        '],{})

    Fault
    Rorw::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint32_t Rs1 = 0;
uint64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                            int shamt = Rs2 & (32 - 1);
                            Rd = (int32_t) ((Rs1 >> shamt) | (Rs1 << ((32 - shamt) & (32 - 1))));
                        ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// Unknown::unknown(([], {}))

// ROp::remw(['\n                            Rd_sd = rem<int32_t>(Rs1, Rs2);\n                        ', 'IntDivOp'],{})

    Fault
    Remw::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int64_t Rd = 0;
uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                            Rd = rem<int32_t>(Rs1, Rs2);
                        ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// ROp::sh3add_uw(['\n                            Rd = (((uint64_t)Rs1_uw) << 3) + Rs2;\n                        '],{})

    Fault
    Sh3add_uw::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint32_t Rs1 = 0;
uint64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                            Rd = (((uint64_t)Rs1) << 3) + Rs2;
                        ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// Unknown::unknown(([], {}))

// ROp::remuw(['\n                        Rd = sext<32>(remu<uint32_t>(Rs1, Rs2));\n                    ', 'IntDivOp'],{})

    Fault
    Remuw::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                        Rd = sext<32>(remu<uint32_t>(Rs1, Rs2));
                    ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// FPROp::fmadd_s(['\n                    RM_REQUIRED;\n                    freg_t fd;\n                    fd = freg(f32_mulAdd(f32(freg(Fs1_bits)),\n                                         f32(freg(Fs2_bits)),\n                                         f32(freg(Fs3_bits))));\n                    Fd_bits = fd.v;\n                ', 'FloatMultAccOp'],{})

    Fault Fmadd_s::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Fs1_bits = 0;
uint64_t Fs2_bits = 0;
uint64_t Fs3_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
Fs3_bits = xc->getRegOperand(this, 2);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                    RM_REQUIRED;
                    freg_t fd;
                    fd = freg(f32_mulAdd(f32(freg(Fs1_bits)),
                                         f32(freg(Fs2_bits)),
                                         f32(freg(Fs3_bits))));
                    Fd_bits = fd.v;
                ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::fmadd_d(['\n                    RM_REQUIRED;\n                    freg_t fd;\n                    fd = freg(f64_mulAdd(f64(freg(Fs1_bits)),\n                                         f64(freg(Fs2_bits)),\n                                         f64(freg(Fs3_bits))));\n                    Fd_bits = fd.v;\n                ', 'FloatMultAccOp'],{})

    Fault Fmadd_d::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Fs1_bits = 0;
uint64_t Fs2_bits = 0;
uint64_t Fs3_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
Fs3_bits = xc->getRegOperand(this, 2);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                    RM_REQUIRED;
                    freg_t fd;
                    fd = freg(f64_mulAdd(f64(freg(Fs1_bits)),
                                         f64(freg(Fs2_bits)),
                                         f64(freg(Fs3_bits))));
                    Fd_bits = fd.v;
                ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::fmadd_h(['\n                    RM_REQUIRED;\n                    freg_t fd;\n                    fd = freg(f16_mulAdd(f16(freg(Fs1_bits)),\n                                         f16(freg(Fs2_bits)),\n                                         f16(freg(Fs3_bits))));\n                    Fd_bits = fd.v;\n                ', 'FloatMultAccOp'],{})

    Fault Fmadd_h::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Fs1_bits = 0;
uint64_t Fs2_bits = 0;
uint64_t Fs3_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
Fs3_bits = xc->getRegOperand(this, 2);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                    RM_REQUIRED;
                    freg_t fd;
                    fd = freg(f16_mulAdd(f16(freg(Fs1_bits)),
                                         f16(freg(Fs2_bits)),
                                         f16(freg(Fs3_bits))));
                    Fd_bits = fd.v;
                ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// Unknown::unknown(([], {}))

// FPROp::fmsub_s(['\n                    RM_REQUIRED;\n                    freg_t fd;\n                    fd = freg(f32_mulAdd(f32(freg(Fs1_bits)),\n                                    f32(freg(Fs2_bits)),\n                                    f32(f32(freg(Fs3_bits)).v ^\n                                        mask(31, 31))));\n                    Fd_bits = fd.v;\n                ', 'FloatMultAccOp'],{})

    Fault Fmsub_s::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Fs1_bits = 0;
uint64_t Fs2_bits = 0;
uint64_t Fs3_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
Fs3_bits = xc->getRegOperand(this, 2);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                    RM_REQUIRED;
                    freg_t fd;
                    fd = freg(f32_mulAdd(f32(freg(Fs1_bits)),
                                    f32(freg(Fs2_bits)),
                                    f32(f32(freg(Fs3_bits)).v ^
                                        mask(31, 31))));
                    Fd_bits = fd.v;
                ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::fmsub_d(['\n                    RM_REQUIRED;\n                    freg_t fd;\n                    fd = freg(f64_mulAdd(f64(freg(Fs1_bits)),\n                                    f64(freg(Fs2_bits)),\n                                    f64(f64(freg(Fs3_bits)).v ^\n                                        mask(63, 63))));\n                    Fd_bits = fd.v;\n                ', 'FloatMultAccOp'],{})

    Fault Fmsub_d::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Fs1_bits = 0;
uint64_t Fs2_bits = 0;
uint64_t Fs3_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
Fs3_bits = xc->getRegOperand(this, 2);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                    RM_REQUIRED;
                    freg_t fd;
                    fd = freg(f64_mulAdd(f64(freg(Fs1_bits)),
                                    f64(freg(Fs2_bits)),
                                    f64(f64(freg(Fs3_bits)).v ^
                                        mask(63, 63))));
                    Fd_bits = fd.v;
                ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::fmsub_h(['\n                    RM_REQUIRED;\n                    freg_t fd;\n                    fd = freg(f16_mulAdd(f16(freg(Fs1_bits)),\n                                    f16(freg(Fs2_bits)),\n                                    f16(f16(freg(Fs3_bits)).v ^\n                                        mask(15, 15))));\n                    Fd_bits = fd.v;\n                ', 'FloatMultAccOp'],{})

    Fault Fmsub_h::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Fs1_bits = 0;
uint64_t Fs2_bits = 0;
uint64_t Fs3_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
Fs3_bits = xc->getRegOperand(this, 2);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                    RM_REQUIRED;
                    freg_t fd;
                    fd = freg(f16_mulAdd(f16(freg(Fs1_bits)),
                                    f16(freg(Fs2_bits)),
                                    f16(f16(freg(Fs3_bits)).v ^
                                        mask(15, 15))));
                    Fd_bits = fd.v;
                ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// Unknown::unknown(([], {}))

// FPROp::fnmsub_s(['\n                    RM_REQUIRED;\n                    freg_t fd;\n                    fd = freg(f32_mulAdd(f32(f32(freg(Fs1_bits)).v ^\n                                             mask(31, 31)),\n                                         f32(freg(Fs2_bits)),\n                                         f32(freg(Fs3_bits))));\n                    Fd_bits = fd.v;\n                ', 'FloatMultAccOp'],{})

    Fault Fnmsub_s::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Fs1_bits = 0;
uint64_t Fs2_bits = 0;
uint64_t Fs3_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
Fs3_bits = xc->getRegOperand(this, 2);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                    RM_REQUIRED;
                    freg_t fd;
                    fd = freg(f32_mulAdd(f32(f32(freg(Fs1_bits)).v ^
                                             mask(31, 31)),
                                         f32(freg(Fs2_bits)),
                                         f32(freg(Fs3_bits))));
                    Fd_bits = fd.v;
                ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::fnmsub_d(['\n                    RM_REQUIRED;\n                    freg_t fd;\n                    fd = freg(f64_mulAdd(f64(f64(freg(Fs1_bits)).v ^\n                                             mask(63, 63)),\n                                         f64(freg(Fs2_bits)),\n                                         f64(freg(Fs3_bits))));\n                    Fd_bits = fd.v;\n                ', 'FloatMultAccOp'],{})

    Fault Fnmsub_d::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Fs1_bits = 0;
uint64_t Fs2_bits = 0;
uint64_t Fs3_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
Fs3_bits = xc->getRegOperand(this, 2);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                    RM_REQUIRED;
                    freg_t fd;
                    fd = freg(f64_mulAdd(f64(f64(freg(Fs1_bits)).v ^
                                             mask(63, 63)),
                                         f64(freg(Fs2_bits)),
                                         f64(freg(Fs3_bits))));
                    Fd_bits = fd.v;
                ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::fnmsub_h(['\n                    RM_REQUIRED;\n                    freg_t fd;\n                    fd = freg(f16_mulAdd(f16(f16(freg(Fs1_bits)).v ^\n                                             mask(15, 15)),\n                                         f16(freg(Fs2_bits)),\n                                         f16(freg(Fs3_bits))));\n                    Fd_bits = fd.v;\n                ', 'FloatMultAccOp'],{})

    Fault Fnmsub_h::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Fs1_bits = 0;
uint64_t Fs2_bits = 0;
uint64_t Fs3_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
Fs3_bits = xc->getRegOperand(this, 2);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                    RM_REQUIRED;
                    freg_t fd;
                    fd = freg(f16_mulAdd(f16(f16(freg(Fs1_bits)).v ^
                                             mask(15, 15)),
                                         f16(freg(Fs2_bits)),
                                         f16(freg(Fs3_bits))));
                    Fd_bits = fd.v;
                ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// Unknown::unknown(([], {}))

// FPROp::fnmadd_s(['\n                    RM_REQUIRED;\n                    freg_t fd;\n                    fd = freg(f32_mulAdd(f32(f32(freg(Fs1_bits)).v ^\n                                             mask(31, 31)),\n                                    f32(freg(Fs2_bits)),\n                                    f32(f32(freg(Fs3_bits)).v ^\n                                        mask(31, 31))));\n                    Fd_bits = fd.v;\n                ', 'FloatMultAccOp'],{})

    Fault Fnmadd_s::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Fs1_bits = 0;
uint64_t Fs2_bits = 0;
uint64_t Fs3_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
Fs3_bits = xc->getRegOperand(this, 2);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                    RM_REQUIRED;
                    freg_t fd;
                    fd = freg(f32_mulAdd(f32(f32(freg(Fs1_bits)).v ^
                                             mask(31, 31)),
                                    f32(freg(Fs2_bits)),
                                    f32(f32(freg(Fs3_bits)).v ^
                                        mask(31, 31))));
                    Fd_bits = fd.v;
                ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::fnmadd_d(['\n                    RM_REQUIRED;\n                    freg_t fd;\n                    fd = freg(f64_mulAdd(f64(f64(freg(Fs1_bits)).v ^\n                                             mask(63, 63)),\n                                    f64(freg(Fs2_bits)),\n                                    f64(f64(freg(Fs3_bits)).v ^\n                                        mask(63, 63))));\n                    Fd_bits = fd.v;\n                ', 'FloatMultAccOp'],{})

    Fault Fnmadd_d::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Fs1_bits = 0;
uint64_t Fs2_bits = 0;
uint64_t Fs3_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
Fs3_bits = xc->getRegOperand(this, 2);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                    RM_REQUIRED;
                    freg_t fd;
                    fd = freg(f64_mulAdd(f64(f64(freg(Fs1_bits)).v ^
                                             mask(63, 63)),
                                    f64(freg(Fs2_bits)),
                                    f64(f64(freg(Fs3_bits)).v ^
                                        mask(63, 63))));
                    Fd_bits = fd.v;
                ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::fnmadd_h(['\n                    RM_REQUIRED;\n                    freg_t fd;\n                    fd = freg(f16_mulAdd(f16(f16(freg(Fs1_bits)).v ^\n                                             mask(15, 15)),\n                                    f16(freg(Fs2_bits)),\n                                    f16(f16(freg(Fs3_bits)).v ^\n                                        mask(15, 15))));\n                    Fd_bits = fd.v;\n                ', 'FloatMultAccOp'],{})

    Fault Fnmadd_h::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Fs1_bits = 0;
uint64_t Fs2_bits = 0;
uint64_t Fs3_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
Fs3_bits = xc->getRegOperand(this, 2);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                    RM_REQUIRED;
                    freg_t fd;
                    fd = freg(f16_mulAdd(f16(f16(freg(Fs1_bits)).v ^
                                             mask(15, 15)),
                                    f16(freg(Fs2_bits)),
                                    f16(f16(freg(Fs3_bits)).v ^
                                        mask(15, 15))));
                    Fd_bits = fd.v;
                ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// Unknown::unknown(([], {}))

// FPROp::fadd_s(['\n                    RM_REQUIRED;\n                    freg_t fd;\n                    fd = freg(f32_add(f32(freg(Fs1_bits)),\n                                      f32(freg(Fs2_bits))));\n                    Fd_bits = fd.v;\n                ', 'FloatAddOp'],{})

    Fault Fadd_s::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Fs1_bits = 0;
uint64_t Fs2_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                    RM_REQUIRED;
                    freg_t fd;
                    fd = freg(f32_add(f32(freg(Fs1_bits)),
                                      f32(freg(Fs2_bits))));
                    Fd_bits = fd.v;
                ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::fadd_d(['\n                    RM_REQUIRED;\n                    freg_t fd;\n                    fd = freg(f64_add(f64(freg(Fs1_bits)),\n                                      f64(freg(Fs2_bits))));\n                    Fd_bits = fd.v;\n                ', 'FloatAddOp'],{})

    Fault Fadd_d::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Fs1_bits = 0;
uint64_t Fs2_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                    RM_REQUIRED;
                    freg_t fd;
                    fd = freg(f64_add(f64(freg(Fs1_bits)),
                                      f64(freg(Fs2_bits))));
                    Fd_bits = fd.v;
                ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::fadd_h(['\n                    RM_REQUIRED;\n                    freg_t fd;\n                    fd = freg(f16_add(f16(freg(Fs1_bits)),\n                                      f16(freg(Fs2_bits))));\n                    Fd_bits = fd.v;\n                ', 'FloatAddOp'],{})

    Fault Fadd_h::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Fs1_bits = 0;
uint64_t Fs2_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                    RM_REQUIRED;
                    freg_t fd;
                    fd = freg(f16_add(f16(freg(Fs1_bits)),
                                      f16(freg(Fs2_bits))));
                    Fd_bits = fd.v;
                ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::fsub_s(['\n                    RM_REQUIRED;\n                    freg_t fd;\n                    fd = freg(f32_sub(f32(freg(Fs1_bits)),\n                                      f32(freg(Fs2_bits))));\n                    Fd_bits = fd.v;\n                ', 'FloatAddOp'],{})

    Fault Fsub_s::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Fs1_bits = 0;
uint64_t Fs2_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                    RM_REQUIRED;
                    freg_t fd;
                    fd = freg(f32_sub(f32(freg(Fs1_bits)),
                                      f32(freg(Fs2_bits))));
                    Fd_bits = fd.v;
                ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::fsub_d(['\n                    RM_REQUIRED;\n                    freg_t fd;\n                    fd = freg(f64_sub(f64(freg(Fs1_bits)),\n                                      f64(freg(Fs2_bits))));\n                    Fd_bits = fd.v;\n                ', 'FloatAddOp'],{})

    Fault Fsub_d::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Fs1_bits = 0;
uint64_t Fs2_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                    RM_REQUIRED;
                    freg_t fd;
                    fd = freg(f64_sub(f64(freg(Fs1_bits)),
                                      f64(freg(Fs2_bits))));
                    Fd_bits = fd.v;
                ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::fsub_h(['\n                    RM_REQUIRED;\n                    freg_t fd;\n                    fd = freg(f16_sub(f16(freg(Fs1_bits)),\n                                      f16(freg(Fs2_bits))));\n                    Fd_bits = fd.v;\n                ', 'FloatAddOp'],{})

    Fault Fsub_h::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Fs1_bits = 0;
uint64_t Fs2_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                    RM_REQUIRED;
                    freg_t fd;
                    fd = freg(f16_sub(f16(freg(Fs1_bits)),
                                      f16(freg(Fs2_bits))));
                    Fd_bits = fd.v;
                ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::fmul_s(['\n                    RM_REQUIRED;\n                    freg_t fd;\n                    fd = freg(f32_mul(f32(freg(Fs1_bits)),\n                                      f32(freg(Fs2_bits))));\n                    Fd_bits = fd.v;\n                ', 'FloatMultOp'],{})

    Fault Fmul_s::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Fs1_bits = 0;
uint64_t Fs2_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                    RM_REQUIRED;
                    freg_t fd;
                    fd = freg(f32_mul(f32(freg(Fs1_bits)),
                                      f32(freg(Fs2_bits))));
                    Fd_bits = fd.v;
                ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::fmul_d(['\n                    RM_REQUIRED;\n                    freg_t fd;\n                    fd = freg(f64_mul(f64(freg(Fs1_bits)),\n                                      f64(freg(Fs2_bits))));\n                    Fd_bits = fd.v;\n                ', 'FloatMultOp'],{})

    Fault Fmul_d::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Fs1_bits = 0;
uint64_t Fs2_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                    RM_REQUIRED;
                    freg_t fd;
                    fd = freg(f64_mul(f64(freg(Fs1_bits)),
                                      f64(freg(Fs2_bits))));
                    Fd_bits = fd.v;
                ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::fmul_h(['\n                    RM_REQUIRED;\n                    freg_t fd;\n                    fd = freg(f16_mul(f16(freg(Fs1_bits)),\n                                      f16(freg(Fs2_bits))));\n                    Fd_bits = fd.v;\n                ', 'FloatMultOp'],{})

    Fault Fmul_h::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Fs1_bits = 0;
uint64_t Fs2_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                    RM_REQUIRED;
                    freg_t fd;
                    fd = freg(f16_mul(f16(freg(Fs1_bits)),
                                      f16(freg(Fs2_bits))));
                    Fd_bits = fd.v;
                ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::fdiv_s(['\n                    RM_REQUIRED;\n                    freg_t fd;\n                    fd = freg(f32_div(f32(freg(Fs1_bits)),\n                                      f32(freg(Fs2_bits))));\n                    Fd_bits = fd.v;\n                ', 'FloatDivOp'],{})

    Fault Fdiv_s::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Fs1_bits = 0;
uint64_t Fs2_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                    RM_REQUIRED;
                    freg_t fd;
                    fd = freg(f32_div(f32(freg(Fs1_bits)),
                                      f32(freg(Fs2_bits))));
                    Fd_bits = fd.v;
                ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::fdiv_d(['\n                    RM_REQUIRED;\n                    freg_t fd;\n                    fd = freg(f64_div(f64(freg(Fs1_bits)),\n                                      f64(freg(Fs2_bits))));\n                    Fd_bits = fd.v;\n                ', 'FloatDivOp'],{})

    Fault Fdiv_d::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Fs1_bits = 0;
uint64_t Fs2_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                    RM_REQUIRED;
                    freg_t fd;
                    fd = freg(f64_div(f64(freg(Fs1_bits)),
                                      f64(freg(Fs2_bits))));
                    Fd_bits = fd.v;
                ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::fdiv_h(['\n                    RM_REQUIRED;\n                    freg_t fd;\n                    fd = freg(f16_div(f16(freg(Fs1_bits)),\n                                      f16(freg(Fs2_bits))));\n                    Fd_bits = fd.v;\n                ', 'FloatDivOp'],{})

    Fault Fdiv_h::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Fs1_bits = 0;
uint64_t Fs2_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                    RM_REQUIRED;
                    freg_t fd;
                    fd = freg(f16_div(f16(freg(Fs1_bits)),
                                      f16(freg(Fs2_bits))));
                    Fd_bits = fd.v;
                ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::fsgnj_s(['\n                        auto sign = bits(unboxF32(Fs2_bits), 31);\n                        Fd_bits = boxF32(insertBits(unboxF32(Fs1_bits), 31,\n                                                    sign));\n                        ', 'FloatMiscOp'],{})

    Fault Fsgnj_s::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Fs1_bits = 0;
uint64_t Fs2_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                        auto sign = bits(unboxF32(Fs2_bits), 31);
                        Fd_bits = boxF32(insertBits(unboxF32(Fs1_bits), 31,
                                                    sign));
                        ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::fsgnjn_s(['\n                        auto sign = ~bits(unboxF32(Fs2_bits), 31);\n                        Fd_bits = boxF32(insertBits(unboxF32(Fs1_bits), 31,\n                                                    sign));\n                        ', 'FloatMiscOp'],{})

    Fault Fsgnjn_s::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Fs1_bits = 0;
uint64_t Fs2_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                        auto sign = ~bits(unboxF32(Fs2_bits), 31);
                        Fd_bits = boxF32(insertBits(unboxF32(Fs1_bits), 31,
                                                    sign));
                        ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::fsgnjx_s(['\n                        auto sign = bits(\n                            unboxF32(Fs1_bits) ^ unboxF32(Fs2_bits), 31);\n                        Fd_bits = boxF32(insertBits(unboxF32(Fs1_bits), 31,\n                                                    sign));\n                        ', 'FloatMiscOp'],{})

    Fault Fsgnjx_s::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Fs1_bits = 0;
uint64_t Fs2_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                        auto sign = bits(
                            unboxF32(Fs1_bits) ^ unboxF32(Fs2_bits), 31);
                        Fd_bits = boxF32(insertBits(unboxF32(Fs1_bits), 31,
                                                    sign));
                        ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// Unknown::unknown(([], {}))

// FPROp::fsgnj_d(['\n                        Fd_bits = insertBits(Fs2_bits, 62, 0, Fs1_bits);\n                    ', 'FloatMiscOp'],{})

    Fault Fsgnj_d::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Fs1_bits = 0;
uint64_t Fs2_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                        Fd_bits = insertBits(Fs2_bits, 62, 0, Fs1_bits);
                    ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::fsgnjn_d(['\n                        Fd_bits = insertBits(~Fs2_bits, 62, 0, Fs1_bits);\n                    ', 'FloatMiscOp'],{})

    Fault Fsgnjn_d::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Fs1_bits = 0;
uint64_t Fs2_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                        Fd_bits = insertBits(~Fs2_bits, 62, 0, Fs1_bits);
                    ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::fsgnjx_d(['\n                        Fd_bits = insertBits(\n                                Fs1_bits ^ Fs2_bits, 62, 0, Fs1_bits);\n                    ', 'FloatMiscOp'],{})

    Fault Fsgnjx_d::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Fs1_bits = 0;
uint64_t Fs2_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                        Fd_bits = insertBits(
                                Fs1_bits ^ Fs2_bits, 62, 0, Fs1_bits);
                    ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// Unknown::unknown(([], {}))

// FPROp::fsgnj_h(['\n                        auto sign = bits(unboxF16(Fs2_bits), 15);\n                        Fd_bits = boxF16(insertBits(unboxF16(Fs1_bits), 15,\n                                                    sign));\n                        ', 'FloatMiscOp'],{})

    Fault Fsgnj_h::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Fs1_bits = 0;
uint64_t Fs2_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                        auto sign = bits(unboxF16(Fs2_bits), 15);
                        Fd_bits = boxF16(insertBits(unboxF16(Fs1_bits), 15,
                                                    sign));
                        ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::fsgnjn_h(['\n                        auto sign = ~bits(unboxF16(Fs2_bits), 15);\n                        Fd_bits = boxF16(insertBits(unboxF16(Fs1_bits), 15,\n                                                    sign));\n                        ', 'FloatMiscOp'],{})

    Fault Fsgnjn_h::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Fs1_bits = 0;
uint64_t Fs2_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                        auto sign = ~bits(unboxF16(Fs2_bits), 15);
                        Fd_bits = boxF16(insertBits(unboxF16(Fs1_bits), 15,
                                                    sign));
                        ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::fsgnjx_h(['\n                        auto sign = bits(\n                            unboxF16(Fs1_bits) ^ unboxF16(Fs2_bits), 15);\n                        Fd_bits = boxF16(insertBits(unboxF16(Fs1_bits), 15,\n                                                    sign));\n                        ', 'FloatMiscOp'],{})

    Fault Fsgnjx_h::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Fs1_bits = 0;
uint64_t Fs2_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                        auto sign = bits(
                            unboxF16(Fs1_bits) ^ unboxF16(Fs2_bits), 15);
                        Fd_bits = boxF16(insertBits(unboxF16(Fs1_bits), 15,
                                                    sign));
                        ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// Unknown::unknown(([], {}))

// FPROp::fmin_s(['\n                        float32_t fs1 = f32(freg(Fs1_bits));\n                        float32_t fs2 = f32(freg(Fs2_bits));\n                        float32_t fd;\n                        bool less = f32_lt_quiet(fs1, fs2) ||\n                            (f32_eq(fs1, fs2) && bits(fs1.v, 31));\n\n                        fd = less || isNaNF32UI(fs2.v) ? fs1 : fs2;\n                        if (isNaNF32UI(fs1.v) && isNaNF32UI(fs2.v))\n                            fd = f32(defaultNaNF32UI);\n                        Fd_bits = freg(fd).v;\n                        ', 'FloatCmpOp'],{})

    Fault Fmin_s::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Fs1_bits = 0;
uint64_t Fs2_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                        float32_t fs1 = f32(freg(Fs1_bits));
                        float32_t fs2 = f32(freg(Fs2_bits));
                        float32_t fd;
                        bool less = f32_lt_quiet(fs1, fs2) ||
                            (f32_eq(fs1, fs2) && bits(fs1.v, 31));

                        fd = less || isNaNF32UI(fs2.v) ? fs1 : fs2;
                        if (isNaNF32UI(fs1.v) && isNaNF32UI(fs2.v))
                            fd = f32(defaultNaNF32UI);
                        Fd_bits = freg(fd).v;
                        ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::fmax_s(['\n                        float32_t fs1 = f32(freg(Fs1_bits));\n                        float32_t fs2 = f32(freg(Fs2_bits));\n                        float32_t fd;\n                        bool greater = f32_lt_quiet(fs2, fs1) ||\n                            (f32_eq(fs2, fs1) && bits(fs2.v, 31));\n\n                        fd = greater || isNaNF32UI(fs2.v) ? fs1: fs2;\n                        if (isNaNF32UI(fs1.v) && isNaNF32UI(fs2.v))\n                            fd = f32(defaultNaNF32UI);\n                        Fd_bits = freg(fd).v;\n                        ', 'FloatCmpOp'],{})

    Fault Fmax_s::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Fs1_bits = 0;
uint64_t Fs2_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                        float32_t fs1 = f32(freg(Fs1_bits));
                        float32_t fs2 = f32(freg(Fs2_bits));
                        float32_t fd;
                        bool greater = f32_lt_quiet(fs2, fs1) ||
                            (f32_eq(fs2, fs1) && bits(fs2.v, 31));

                        fd = greater || isNaNF32UI(fs2.v) ? fs1: fs2;
                        if (isNaNF32UI(fs1.v) && isNaNF32UI(fs2.v))
                            fd = f32(defaultNaNF32UI);
                        Fd_bits = freg(fd).v;
                        ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// Unknown::unknown(([], {}))

// FPROp::fmin_d(['\n                        float64_t fs1 = f64(freg(Fs1_bits));\n                        float64_t fs2 = f64(freg(Fs2_bits));\n                        float64_t fd;\n                        bool less = f64_lt_quiet(fs1, fs2) ||\n                            (f64_eq(fs1, fs2) && bits(fs1.v, 63));\n\n                        fd = less || isNaNF64UI(fs2.v) ? fs1 : fs2;\n                        if (isNaNF64UI(fs1.v) && isNaNF64UI(fs2.v))\n                            fd = f64(defaultNaNF64UI);\n                        Fd_bits = freg(fd).v;\n                    ', 'FloatCmpOp'],{})

    Fault Fmin_d::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Fs1_bits = 0;
uint64_t Fs2_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                        float64_t fs1 = f64(freg(Fs1_bits));
                        float64_t fs2 = f64(freg(Fs2_bits));
                        float64_t fd;
                        bool less = f64_lt_quiet(fs1, fs2) ||
                            (f64_eq(fs1, fs2) && bits(fs1.v, 63));

                        fd = less || isNaNF64UI(fs2.v) ? fs1 : fs2;
                        if (isNaNF64UI(fs1.v) && isNaNF64UI(fs2.v))
                            fd = f64(defaultNaNF64UI);
                        Fd_bits = freg(fd).v;
                    ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::fmax_d(['\n                        float64_t fs1 = f64(freg(Fs1_bits));\n                        float64_t fs2 = f64(freg(Fs2_bits));\n                        float64_t fd;\n                        bool greater = f64_lt_quiet(fs2, fs1) ||\n                            (f64_eq(fs2, fs1) && bits(fs2.v, 63));\n\n                        fd = greater || isNaNF64UI(fs2.v) ? fs1 : fs2;\n                        if (isNaNF64UI(fs1.v) && isNaNF64UI(fs2.v))\n                            fd = f64(defaultNaNF64UI);\n                        Fd_bits = freg(fd).v;\n                    ', 'FloatCmpOp'],{})

    Fault Fmax_d::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Fs1_bits = 0;
uint64_t Fs2_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                        float64_t fs1 = f64(freg(Fs1_bits));
                        float64_t fs2 = f64(freg(Fs2_bits));
                        float64_t fd;
                        bool greater = f64_lt_quiet(fs2, fs1) ||
                            (f64_eq(fs2, fs1) && bits(fs2.v, 63));

                        fd = greater || isNaNF64UI(fs2.v) ? fs1 : fs2;
                        if (isNaNF64UI(fs1.v) && isNaNF64UI(fs2.v))
                            fd = f64(defaultNaNF64UI);
                        Fd_bits = freg(fd).v;
                    ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// Unknown::unknown(([], {}))

// FPROp::fmin_h(['\n                        float16_t fs1 = f16(freg(Fs1_bits));\n                        float16_t fs2 = f16(freg(Fs2_bits));\n                        float16_t fd;\n                        bool less = f16_lt_quiet(fs1, fs2) ||\n                            (f16_eq(fs1, fs2) && bits(fs1.v, 15));\n\n                        fd = less || isNaNF16UI(fs2.v) ? fs1 : fs2;\n                        if (isNaNF16UI(fs1.v) && isNaNF16UI(fs2.v))\n                            fd = f16(defaultNaNF16UI);\n                        Fd_bits = freg(fd).v;\n                        ', 'FloatCmpOp'],{})

    Fault Fmin_h::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Fs1_bits = 0;
uint64_t Fs2_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                        float16_t fs1 = f16(freg(Fs1_bits));
                        float16_t fs2 = f16(freg(Fs2_bits));
                        float16_t fd;
                        bool less = f16_lt_quiet(fs1, fs2) ||
                            (f16_eq(fs1, fs2) && bits(fs1.v, 15));

                        fd = less || isNaNF16UI(fs2.v) ? fs1 : fs2;
                        if (isNaNF16UI(fs1.v) && isNaNF16UI(fs2.v))
                            fd = f16(defaultNaNF16UI);
                        Fd_bits = freg(fd).v;
                        ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::fmax_h(['\n                        float16_t fs1 = f16(freg(Fs1_bits));\n                        float16_t fs2 = f16(freg(Fs2_bits));\n                        float16_t fd;\n                        bool greater = f16_lt_quiet(fs2, fs1) ||\n                            (f16_eq(fs2, fs1) && bits(fs2.v, 15));\n\n                        fd = greater || isNaNF16UI(fs2.v) ? fs1 : fs2;\n                        if (isNaNF16UI(fs1.v) && isNaNF16UI(fs2.v))\n                            fd = f16(defaultNaNF16UI);\n                        Fd_bits = freg(fd).v;\n                        ', 'FloatCmpOp'],{})

    Fault Fmax_h::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Fs1_bits = 0;
uint64_t Fs2_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                        float16_t fs1 = f16(freg(Fs1_bits));
                        float16_t fs2 = f16(freg(Fs2_bits));
                        float16_t fd;
                        bool greater = f16_lt_quiet(fs2, fs1) ||
                            (f16_eq(fs2, fs1) && bits(fs2.v, 15));

                        fd = greater || isNaNF16UI(fs2.v) ? fs1 : fs2;
                        if (isNaNF16UI(fs1.v) && isNaNF16UI(fs2.v))
                            fd = f16(defaultNaNF16UI);
                        Fd_bits = freg(fd).v;
                        ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// Unknown::unknown(([], {}))

// FPROp::fcvt_s_d(['\n                        RM_REQUIRED;\n                        freg_t fd;\n                        fd = freg(f64_to_f32(f64(freg(Fs1_bits))));\n                        Fd_bits = fd.v;\n                    ', 'FloatCvtOp'],{})

    Fault Fcvt_s_d::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Fs1_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                        RM_REQUIRED;
                        freg_t fd;
                        fd = freg(f64_to_f32(f64(freg(Fs1_bits))));
                        Fd_bits = fd.v;
                    ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::fcvt_s_h(['\n                        RM_REQUIRED;\n                        freg_t fd;\n                        fd = freg(f16_to_f32(f16(freg(Fs1_bits))));\n                        Fd_bits = fd.v;\n                    ', 'FloatCvtOp'],{})

    Fault Fcvt_s_h::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Fs1_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                        RM_REQUIRED;
                        freg_t fd;
                        fd = freg(f16_to_f32(f16(freg(Fs1_bits))));
                        Fd_bits = fd.v;
                    ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// Unknown::unknown(([], {}))

// FPROp::fcvt_d_s(['\n                        RM_REQUIRED;\n                        freg_t fd;\n                        fd = freg(f32_to_f64(f32(freg(Fs1_bits))));\n                        Fd_bits = fd.v;\n                    ', 'FloatCvtOp'],{})

    Fault Fcvt_d_s::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Fs1_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                        RM_REQUIRED;
                        freg_t fd;
                        fd = freg(f32_to_f64(f32(freg(Fs1_bits))));
                        Fd_bits = fd.v;
                    ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::fcvt_d_h(['\n                        RM_REQUIRED;\n                        freg_t fd;\n                        fd = freg(f16_to_f64(f16(freg(Fs1_bits))));\n                        Fd_bits = fd.v;\n                    ', 'FloatCvtOp'],{})

    Fault Fcvt_d_h::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Fs1_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                        RM_REQUIRED;
                        freg_t fd;
                        fd = freg(f16_to_f64(f16(freg(Fs1_bits))));
                        Fd_bits = fd.v;
                    ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// Unknown::unknown(([], {}))

// FPROp::fcvt_h_s(['\n                        RM_REQUIRED;\n                        freg_t fd;\n                        fd = freg(f32_to_f16(f32(freg(Fs1_bits))));\n                        Fd_bits = fd.v;\n                    ', 'FloatCvtOp'],{})

    Fault Fcvt_h_s::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Fs1_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                        RM_REQUIRED;
                        freg_t fd;
                        fd = freg(f32_to_f16(f32(freg(Fs1_bits))));
                        Fd_bits = fd.v;
                    ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::fcvt_h_d(['\n                        RM_REQUIRED;\n                        freg_t fd;\n                        fd = freg(f64_to_f16(f64(freg(Fs1_bits))));\n                        Fd_bits = fd.v;\n                    ', 'FloatCvtOp'],{})

    Fault Fcvt_h_d::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Fs1_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                        RM_REQUIRED;
                        freg_t fd;
                        fd = freg(f64_to_f16(f64(freg(Fs1_bits))));
                        Fd_bits = fd.v;
                    ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// Unknown::unknown(([], {}))

// FPROp::fsqrt_s(['\n                    if (RS2 != 0) {\n                        return std::make_shared<IllegalInstFault>(\n                                "source reg x1", machInst);\n                    }\n                    freg_t fd;\n                    RM_REQUIRED;\n                    fd = freg(f32_sqrt(f32(freg(Fs1_bits))));\n                    Fd_bits = fd.v;\n                ', 'FloatSqrtOp'],{})

    Fault Fsqrt_s::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Fs1_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                    if (RS2 != 0) {
                        return std::make_shared<IllegalInstFault>(
                                "source reg x1", machInst);
                    }
                    freg_t fd;
                    RM_REQUIRED;
                    fd = freg(f32_sqrt(f32(freg(Fs1_bits))));
                    Fd_bits = fd.v;
                ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::fsqrt_d(['\n                    if (RS2 != 0) {\n                        return std::make_shared<IllegalInstFault>(\n                                "source reg x1", machInst);\n                    }\n                    freg_t fd;\n                    RM_REQUIRED;\n                    fd = freg(f64_sqrt(f64(freg(Fs1_bits))));\n                    Fd_bits = fd.v;\n                ', 'FloatSqrtOp'],{})

    Fault Fsqrt_d::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Fs1_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                    if (RS2 != 0) {
                        return std::make_shared<IllegalInstFault>(
                                "source reg x1", machInst);
                    }
                    freg_t fd;
                    RM_REQUIRED;
                    fd = freg(f64_sqrt(f64(freg(Fs1_bits))));
                    Fd_bits = fd.v;
                ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::fsqrt_h(['\n                    if (RS2 != 0) {\n                        return std::make_shared<IllegalInstFault>(\n                                "source reg x1", machInst);\n                    }\n                    freg_t fd;\n                    RM_REQUIRED;\n                    fd = freg(f16_sqrt(f16(freg(Fs1_bits))));\n                    Fd_bits = fd.v;\n                ', 'FloatSqrtOp'],{})

    Fault Fsqrt_h::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Fs1_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                    if (RS2 != 0) {
                        return std::make_shared<IllegalInstFault>(
                                "source reg x1", machInst);
                    }
                    freg_t fd;
                    RM_REQUIRED;
                    fd = freg(f16_sqrt(f16(freg(Fs1_bits))));
                    Fd_bits = fd.v;
                ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::fle_s(['\n                        Rd = f32_le(f32(freg(Fs1_bits)), f32(freg(Fs2_bits)));\n                    ', 'FloatCmpOp'],{})

    Fault Fle_s::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Rd = 0;
uint64_t Fs1_bits = 0;
uint64_t Fs2_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                        Rd = f32_le(f32(freg(Fs1_bits)), f32(freg(Fs2_bits)));
                    ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::flt_s(['\n                        Rd = f32_lt(f32(freg(Fs1_bits)), f32(freg(Fs2_bits)));\n                    ', 'FloatCmpOp'],{})

    Fault Flt_s::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Rd = 0;
uint64_t Fs1_bits = 0;
uint64_t Fs2_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                        Rd = f32_lt(f32(freg(Fs1_bits)), f32(freg(Fs2_bits)));
                    ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::feq_s(['\n                        Rd = f32_eq(f32(freg(Fs1_bits)), f32(freg(Fs2_bits)));\n                    ', 'FloatCmpOp'],{})

    Fault Feq_s::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Rd = 0;
uint64_t Fs1_bits = 0;
uint64_t Fs2_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                        Rd = f32_eq(f32(freg(Fs1_bits)), f32(freg(Fs2_bits)));
                    ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// Unknown::unknown(([], {}))

// FPROp::fle_d(['\n                        Rd = f64_le(f64(freg(Fs1_bits)), f64(freg(Fs2_bits)));\n                    ', 'FloatCmpOp'],{})

    Fault Fle_d::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Rd = 0;
uint64_t Fs1_bits = 0;
uint64_t Fs2_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                        Rd = f64_le(f64(freg(Fs1_bits)), f64(freg(Fs2_bits)));
                    ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::flt_d(['\n                        Rd = f64_lt(f64(freg(Fs1_bits)), f64(freg(Fs2_bits)));\n                    ', 'FloatCmpOp'],{})

    Fault Flt_d::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Rd = 0;
uint64_t Fs1_bits = 0;
uint64_t Fs2_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                        Rd = f64_lt(f64(freg(Fs1_bits)), f64(freg(Fs2_bits)));
                    ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::feq_d(['\n                        Rd = f64_eq(f64(freg(Fs1_bits)), f64(freg(Fs2_bits)));\n                    ', 'FloatCmpOp'],{})

    Fault Feq_d::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Rd = 0;
uint64_t Fs1_bits = 0;
uint64_t Fs2_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                        Rd = f64_eq(f64(freg(Fs1_bits)), f64(freg(Fs2_bits)));
                    ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// Unknown::unknown(([], {}))

// FPROp::fle_h(['\n                        Rd = f16_le(f16(freg(Fs1_bits)), f16(freg(Fs2_bits)));\n                    ', 'FloatCmpOp'],{})

    Fault Fle_h::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Rd = 0;
uint64_t Fs1_bits = 0;
uint64_t Fs2_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                        Rd = f16_le(f16(freg(Fs1_bits)), f16(freg(Fs2_bits)));
                    ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::flt_h(['\n                        Rd = f16_lt(f16(freg(Fs1_bits)), f16(freg(Fs2_bits)));\n                    ', 'FloatCmpOp'],{})

    Fault Flt_h::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Rd = 0;
uint64_t Fs1_bits = 0;
uint64_t Fs2_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                        Rd = f16_lt(f16(freg(Fs1_bits)), f16(freg(Fs2_bits)));
                    ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::feq_h(['\n                        Rd = f16_eq(f16(freg(Fs1_bits)), f16(freg(Fs2_bits)));\n                    ', 'FloatCmpOp'],{})

    Fault Feq_h::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Rd = 0;
uint64_t Fs1_bits = 0;
uint64_t Fs2_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
Fs2_bits = xc->getRegOperand(this, 1);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                        Rd = f16_eq(f16(freg(Fs1_bits)), f16(freg(Fs2_bits)));
                    ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// Unknown::unknown(([], {}))

// FPROp::fcvt_w_s(['\n                        RM_REQUIRED;\n                        Rd_sd = sext<32>(f32_to_i32(f32(freg(Fs1_bits)), rm,\n                                                    true));\n                    ', 'FloatCvtOp'],{})

    Fault Fcvt_w_s::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        int64_t Rd = 0;
uint64_t Fs1_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                        RM_REQUIRED;
                        Rd = sext<32>(f32_to_i32(f32(freg(Fs1_bits)), rm,
                                                    true));
                    ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::fcvt_wu_s(['\n                        RM_REQUIRED;\n                        Rd = sext<32>(f32_to_ui32(f32(freg(Fs1_bits)), rm,\n                                                  true));\n                    ', 'FloatCvtOp'],{})

    Fault Fcvt_wu_s::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Rd = 0;
uint64_t Fs1_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                        RM_REQUIRED;
                        Rd = sext<32>(f32_to_ui32(f32(freg(Fs1_bits)), rm,
                                                  true));
                    ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::fcvt_l_s(['\n                            RM_REQUIRED;\n                            Rd_sd = f32_to_i64(f32(freg(Fs1_bits)), rm, true);\n                        ', 'FloatCvtOp'],{})

    Fault Fcvt_l_s::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        int64_t Rd = 0;
uint64_t Fs1_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                            RM_REQUIRED;
                            Rd = f32_to_i64(f32(freg(Fs1_bits)), rm, true);
                        ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// Unknown::unknown(([], {}))

// FPROp::fcvt_lu_s(['\n                            RM_REQUIRED;\n                            Rd = f32_to_ui64(f32(freg(Fs1_bits)), rm, true);\n                        ', 'FloatCvtOp'],{})

    Fault Fcvt_lu_s::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Rd = 0;
uint64_t Fs1_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                            RM_REQUIRED;
                            Rd = f32_to_ui64(f32(freg(Fs1_bits)), rm, true);
                        ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// FPROp::fcvt_w_d(['\n                        RM_REQUIRED;\n                        Rd_sd = sext<32>(f64_to_i32(f64(freg(Fs1_bits)), rm,\n                                                    true));\n                    ', 'FloatCvtOp'],{})

    Fault Fcvt_w_d::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        int64_t Rd = 0;
uint64_t Fs1_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                        RM_REQUIRED;
                        Rd = sext<32>(f64_to_i32(f64(freg(Fs1_bits)), rm,
                                                    true));
                    ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::fcvt_wu_d(['\n                        RM_REQUIRED;\n                        Rd = sext<32>(f64_to_ui32(f64(freg(Fs1_bits)), rm,\n                                                  true));\n                    ', 'FloatCvtOp'],{})

    Fault Fcvt_wu_d::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Rd = 0;
uint64_t Fs1_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                        RM_REQUIRED;
                        Rd = sext<32>(f64_to_ui32(f64(freg(Fs1_bits)), rm,
                                                  true));
                    ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::fcvt_l_d(['\n                            RM_REQUIRED;\n                            Rd_sd = f64_to_i64(f64(freg(Fs1_bits)), rm, true);\n                        ', 'FloatCvtOp'],{})

    Fault Fcvt_l_d::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        int64_t Rd = 0;
uint64_t Fs1_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                            RM_REQUIRED;
                            Rd = f64_to_i64(f64(freg(Fs1_bits)), rm, true);
                        ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// Unknown::unknown(([], {}))

// FPROp::fcvt_lu_d(['\n                            RM_REQUIRED;\n                            Rd = f64_to_ui64(f64(freg(Fs1_bits)), rm, true);\n                        ', 'FloatCvtOp'],{})

    Fault Fcvt_lu_d::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Rd = 0;
uint64_t Fs1_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                            RM_REQUIRED;
                            Rd = f64_to_ui64(f64(freg(Fs1_bits)), rm, true);
                        ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// FPROp::fcvt_w_h(['\n                        RM_REQUIRED;\n                        Rd_sd = sext<32>(f16_to_i32(f16(freg(Fs1_bits)), rm,\n                                                    true));\n                    ', 'FloatCvtOp'],{})

    Fault Fcvt_w_h::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        int64_t Rd = 0;
uint64_t Fs1_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                        RM_REQUIRED;
                        Rd = sext<32>(f16_to_i32(f16(freg(Fs1_bits)), rm,
                                                    true));
                    ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::fcvt_wu_h(['\n                        RM_REQUIRED;\n                        Rd = sext<32>(f16_to_ui32(f16(freg(Fs1_bits)), rm,\n                                                  true));\n                    ', 'FloatCvtOp'],{})

    Fault Fcvt_wu_h::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Rd = 0;
uint64_t Fs1_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                        RM_REQUIRED;
                        Rd = sext<32>(f16_to_ui32(f16(freg(Fs1_bits)), rm,
                                                  true));
                    ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::fcvt_l_h(['\n                            RM_REQUIRED;\n                            Rd_sd = f16_to_i64(f16(freg(Fs1_bits)), rm, true);\n                        ', 'FloatCvtOp'],{})

    Fault Fcvt_l_h::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        int64_t Rd = 0;
uint64_t Fs1_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                            RM_REQUIRED;
                            Rd = f16_to_i64(f16(freg(Fs1_bits)), rm, true);
                        ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// Unknown::unknown(([], {}))

// FPROp::fcvt_lu_h(['\n                            RM_REQUIRED;\n                            Rd = f16_to_ui64(f16(freg(Fs1_bits)), rm, true);\n                        ', 'FloatCvtOp'],{})

    Fault Fcvt_lu_h::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Rd = 0;
uint64_t Fs1_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                            RM_REQUIRED;
                            Rd = f16_to_ui64(f16(freg(Fs1_bits)), rm, true);
                        ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// FPROp::fcvt_s_w(['\n                        RM_REQUIRED;\n                        freg_t fd;\n                        fd = freg(i32_to_f32(Rs1_sw));\n                        Fd_bits = fd.v;\n                        ', 'FloatCvtOp'],{})

    Fault Fcvt_s_w::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
int32_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                        RM_REQUIRED;
                        freg_t fd;
                        fd = freg(i32_to_f32(Rs1));
                        Fd_bits = fd.v;
                        ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::fcvt_s_wu(['\n                        RM_REQUIRED;\n                        freg_t fd;\n                        fd = freg(ui32_to_f32(Rs1_uw));\n                        Fd_bits = fd.v;\n                        ', 'FloatCvtOp'],{})

    Fault Fcvt_s_wu::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint32_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                        RM_REQUIRED;
                        freg_t fd;
                        fd = freg(ui32_to_f32(Rs1));
                        Fd_bits = fd.v;
                        ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::fcvt_s_l(['\n                            RM_REQUIRED;\n                            freg_t fd;\n                            fd = freg(i64_to_f32(Rs1_ud));\n                            Fd_bits = fd.v;\n                        ', 'FloatCvtOp'],{})

    Fault Fcvt_s_l::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                            RM_REQUIRED;
                            freg_t fd;
                            fd = freg(i64_to_f32(Rs1));
                            Fd_bits = fd.v;
                        ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// Unknown::unknown(([], {}))

// FPROp::fcvt_s_lu(['\n                            RM_REQUIRED;\n                            freg_t fd;\n                            fd = freg(ui64_to_f32(Rs1));\n                            Fd_bits = fd.v;\n                        ', 'FloatCvtOp'],{})

    Fault Fcvt_s_lu::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                            RM_REQUIRED;
                            freg_t fd;
                            fd = freg(ui64_to_f32(Rs1));
                            Fd_bits = fd.v;
                        ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// FPROp::fcvt_d_w(['\n                        RM_REQUIRED;\n                        freg_t fd;\n                        fd = freg(i32_to_f64(Rs1_sw));\n                        Fd_bits = fd.v;\n                    ', 'FloatCvtOp'],{})

    Fault Fcvt_d_w::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
int32_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                        RM_REQUIRED;
                        freg_t fd;
                        fd = freg(i32_to_f64(Rs1));
                        Fd_bits = fd.v;
                    ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::fcvt_d_wu(['\n                        RM_REQUIRED;\n                        freg_t fd;\n                        fd = freg(ui32_to_f64(Rs1_uw));\n                        Fd_bits = fd.v;\n                    ', 'FloatCvtOp'],{})

    Fault Fcvt_d_wu::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint32_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                        RM_REQUIRED;
                        freg_t fd;
                        fd = freg(ui32_to_f64(Rs1));
                        Fd_bits = fd.v;
                    ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::fcvt_d_l(['\n                            RM_REQUIRED;\n                            freg_t fd;\n                            fd = freg(i64_to_f64(Rs1_sd));\n                            Fd_bits = fd.v;\n                        ', 'FloatCvtOp'],{})

    Fault Fcvt_d_l::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
int64_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                            RM_REQUIRED;
                            freg_t fd;
                            fd = freg(i64_to_f64(Rs1));
                            Fd_bits = fd.v;
                        ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// Unknown::unknown(([], {}))

// FPROp::fcvt_d_lu(['\n                            RM_REQUIRED;\n                            freg_t fd;\n                            fd = freg(ui64_to_f64(Rs1));\n                            Fd_bits = fd.v;\n                        ', 'FloatCvtOp'],{})

    Fault Fcvt_d_lu::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                            RM_REQUIRED;
                            freg_t fd;
                            fd = freg(ui64_to_f64(Rs1));
                            Fd_bits = fd.v;
                        ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// FPROp::fcvt_h_w(['\n                        RM_REQUIRED;\n                        freg_t fd;\n                        fd = freg(i32_to_f16((int32_t)Rs1_sw));\n                        Fd_bits = fd.v;\n                        ', 'FloatCvtOp'],{})

    Fault Fcvt_h_w::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
int32_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                        RM_REQUIRED;
                        freg_t fd;
                        fd = freg(i32_to_f16((int32_t)Rs1));
                        Fd_bits = fd.v;
                        ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::fcvt_h_wu(['\n                        RM_REQUIRED;\n                        freg_t fd;\n                        fd = freg(ui32_to_f16((uint32_t)Rs1_uw));\n                        Fd_bits = fd.v;\n                        ', 'FloatCvtOp'],{})

    Fault Fcvt_h_wu::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint32_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                        RM_REQUIRED;
                        freg_t fd;
                        fd = freg(ui32_to_f16((uint32_t)Rs1));
                        Fd_bits = fd.v;
                        ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::fcvt_h_l(['\n                            RM_REQUIRED;\n                            freg_t fd;\n                            fd = freg(i64_to_f16(Rs1_ud));\n                            Fd_bits = fd.v;\n                            ', 'FloatCvtOp'],{})

    Fault Fcvt_h_l::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                            RM_REQUIRED;
                            freg_t fd;
                            fd = freg(i64_to_f16(Rs1));
                            Fd_bits = fd.v;
                            ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// Unknown::unknown(([], {}))

// FPROp::fcvt_h_lu(['\n                            RM_REQUIRED;\n                            freg_t fd;\n                            fd = freg(ui64_to_f16(Rs1));\n                            Fd_bits = fd.v;\n                            ', 'FloatCvtOp'],{})

    Fault Fcvt_h_lu::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                            RM_REQUIRED;
                            freg_t fd;
                            fd = freg(ui64_to_f16(Rs1));
                            Fd_bits = fd.v;
                            ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// FPROp::fmv_x_w(['\n                        uint64_t result = (uint32_t)Fs1_bits;\n                        if ((result&0x80000000) != 0) {\n                            result |= (0xFFFFFFFFULL << 32);\n                        }\n                        Rd = result;\n                    ', 'FloatCvtOp'],{})

    Fault Fmv_x_w::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Rd = 0;
uint64_t Fs1_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                        uint64_t result = (uint32_t)Fs1_bits;
                        if ((result&0x80000000) != 0) {
                            result |= (0xFFFFFFFFULL << 32);
                        }
                        Rd = result;
                    ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::fclass_s(['\n                        Rd = rvSext(f32_classify(f32(freg(Fs1_bits))));\n                    ', 'FloatMiscOp'],{})

    Fault Fclass_s::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Rd = 0;
uint64_t Fs1_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                        Rd = rvSext(f32_classify(f32(freg(Fs1_bits))));
                    ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// Unknown::unknown(([], {}))

// FPROp::fmv_x_d(['\n                            Rd = freg(Fs1_bits).v;\n                        ', 'FloatCvtOp'],{})

    Fault Fmv_x_d::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Rd = 0;
uint64_t Fs1_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                            Rd = freg(Fs1_bits).v;
                        ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// Unknown::unknown(([], {}))

// FPROp::fclass_d(['\n                        Rd = f64_classify(f64(freg(Fs1_bits)));\n                    ', 'FloatMiscOp'],{})

    Fault Fclass_d::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Rd = 0;
uint64_t Fs1_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                        Rd = f64_classify(f64(freg(Fs1_bits)));
                    ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// Unknown::unknown(([], {}))

// FPROp::fmv_x_h(['\n                        uint64_t result = (uint16_t)Fs1_bits;\n                        if ((result&0x8000) != 0) {\n                            result |= (0xFFFFFFFFFFFFULL << 16);\n                        }\n                        Rd = result;\n                    ', 'FloatCvtOp'],{})

    Fault Fmv_x_h::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Rd = 0;
uint64_t Fs1_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                        uint64_t result = (uint16_t)Fs1_bits;
                        if ((result&0x8000) != 0) {
                            result |= (0xFFFFFFFFFFFFULL << 16);
                        }
                        Rd = result;
                    ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::fclass_h(['\n                        Rd = f16_classify(f16(freg(Fs1_bits)));\n                    ', 'FloatMiscOp'],{})

    Fault Fclass_h::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Rd = 0;
uint64_t Fs1_bits = 0;
;
        Fs1_bits = xc->getRegOperand(this, 0);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                        Rd = f16_classify(f16(freg(Fs1_bits)));
                    ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };

        return NoFault;
    }

// Unknown::unknown(([], {}))

// FPROp::fmv_w_x(['\n                    freg_t fd;\n                    fd = freg(f32(Rs1_uw));\n                    Fd_bits = fd.v;\n                ', 'FloatCvtOp'],{})

    Fault Fmv_w_x::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint32_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                    freg_t fd;
                    fd = freg(f32(Rs1));
                    Fd_bits = fd.v;
                ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// FPROp::fmv_d_x(['\n                        freg_t fd;\n                        fd = freg(f64(Rs1));\n                        Fd_bits = fd.v;\n                    ', 'FloatCvtOp'],{})

    Fault Fmv_d_x::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint64_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                        freg_t fd;
                        fd = freg(f64(Rs1));
                        Fd_bits = fd.v;
                    ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// Unknown::unknown(([], {}))

// FPROp::fmv_h_x(['\n                    freg_t fd;\n                    fd = freg(f16(Rs1_uh));\n                    Fd_bits = fd.v;\n                ', 'FloatCvtOp'],{})

    Fault Fmv_h_x::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (status.fs == FPUStatus::OFF)
            return std::make_shared<IllegalInstFault>("FPU is off", machInst);

        status.fs = FPUStatus::DIRTY;
        xc->setMiscReg(MISCREG_STATUS, status);

        uint64_t Fd_bits = 0;
uint16_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;

        std::feclearexcept(FE_ALL_EXCEPT);
        
                    freg_t fd;
                    fd = freg(f16(Rs1));
                    Fd_bits = fd.v;
                ;
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;

        
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };

        return NoFault;
    }

// Unknown::unknown(([], {}))

// VectorIntFormat::vadd_vv(['\n                        Vd_vu[i] = Vs2_vu[i] + Vs1_vu[i];\n                    ', 'OPIVV', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vadd_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = Vs2[i] + Vs1[i];
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vadd_vvMicro<uint8_t>;
template class Vadd_vvMicro<uint16_t>;
template class Vadd_vvMicro<uint32_t>;
template class Vadd_vvMicro<uint64_t>;
;


// VectorIntFormat::vsub_vv(['\n                        Vd_vu[i] = Vs2_vu[i] - Vs1_vu[i];\n                    ', 'OPIVV', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vsub_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = Vs2[i] - Vs1[i];
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vsub_vvMicro<uint8_t>;
template class Vsub_vvMicro<uint16_t>;
template class Vsub_vvMicro<uint32_t>;
template class Vsub_vvMicro<uint64_t>;
;


// VectorIntFormat::vminu_vv(['\n                        Vd_vu[i] = Vs2_vu[i] < Vs1_vu[i] ?\n                                Vs2_vu[i] : Vs1_vu[i];\n                    ', 'OPIVV', 'SimdCmpOp'],{})


template <typename ElemType>
Fault
Vminu_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = Vs2[i] < Vs1[i] ?
                                Vs2[i] : Vs1[i];
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vminu_vvMicro<uint8_t>;
template class Vminu_vvMicro<uint16_t>;
template class Vminu_vvMicro<uint32_t>;
template class Vminu_vvMicro<uint64_t>;
;


// VectorIntFormat::vmin_vv(['\n                        Vd_vi[i] = Vs2_vi[i] < Vs1_vi[i] ?\n                                Vs2_vi[i] : Vs1_vi[i];\n                    ', 'OPIVV', 'SimdCmpOp'],{})


template <typename ElemType>
Fault
Vmin_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = Vs2[i] < Vs1[i] ?
                                Vs2[i] : Vs1[i];
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vmin_vvMicro<uint8_t>;
template class Vmin_vvMicro<uint16_t>;
template class Vmin_vvMicro<uint32_t>;
template class Vmin_vvMicro<uint64_t>;
;


// VectorIntFormat::vmaxu_vv(['\n                        Vd_vu[i] = Vs2_vu[i] > Vs1_vu[i] ?\n                                Vs2_vu[i] : Vs1_vu[i];\n                    ', 'OPIVV', 'SimdCmpOp'],{})


template <typename ElemType>
Fault
Vmaxu_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = Vs2[i] > Vs1[i] ?
                                Vs2[i] : Vs1[i];
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vmaxu_vvMicro<uint8_t>;
template class Vmaxu_vvMicro<uint16_t>;
template class Vmaxu_vvMicro<uint32_t>;
template class Vmaxu_vvMicro<uint64_t>;
;


// VectorIntFormat::vmax_vv(['\n                        Vd_vi[i] = Vs2_vi[i] > Vs1_vi[i] ?\n                                Vs2_vi[i] : Vs1_vi[i];\n                    ', 'OPIVV', 'SimdCmpOp'],{})


template <typename ElemType>
Fault
Vmax_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = Vs2[i] > Vs1[i] ?
                                Vs2[i] : Vs1[i];
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vmax_vvMicro<uint8_t>;
template class Vmax_vvMicro<uint16_t>;
template class Vmax_vvMicro<uint32_t>;
template class Vmax_vvMicro<uint64_t>;
;


// VectorIntFormat::vand_vv(['\n                        Vd_vu[i] = Vs2_vu[i] & Vs1_vu[i];\n                    ', 'OPIVV', 'SimdAluOp'],{})


template <typename ElemType>
Fault
Vand_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = Vs2[i] & Vs1[i];
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vand_vvMicro<uint8_t>;
template class Vand_vvMicro<uint16_t>;
template class Vand_vvMicro<uint32_t>;
template class Vand_vvMicro<uint64_t>;
;


// VectorIntFormat::vor_vv(['\n                        Vd_vu[i] = Vs2_vu[i] | Vs1_vu[i];\n                    ', 'OPIVV', 'SimdAluOp'],{})


template <typename ElemType>
Fault
Vor_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = Vs2[i] | Vs1[i];
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vor_vvMicro<uint8_t>;
template class Vor_vvMicro<uint16_t>;
template class Vor_vvMicro<uint32_t>;
template class Vor_vvMicro<uint64_t>;
;


// VectorIntFormat::vxor_vv(['\n                        Vd_vu[i] = Vs2_vu[i] ^ Vs1_vu[i];\n                    ', 'OPIVV', 'SimdAluOp'],{})


template <typename ElemType>
Fault
Vxor_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = Vs2[i] ^ Vs1[i];
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vxor_vvMicro<uint8_t>;
template class Vxor_vvMicro<uint16_t>;
template class Vxor_vvMicro<uint32_t>;
template class Vxor_vvMicro<uint64_t>;
;


// VectorGatherFormat::vrgather_vv((['\n                    for (uint32_t i = 0; i < microVl; i++) {\n                        uint32_t ei = i + vs1_idx * vs1_elems + vs1_bias;\n                        if (this->vm || elem_mask(v0, ei)) {\n                            const uint64_t idx = Vs1_vu[i]\n                                - vs2_elems * vs2_idx;\n                            if (Vs1_vu[i] >= vlmax)\n                                Vd_vu[i] = 0;\n                            else if (idx < vs2_elems)\n                                Vd_vu[i] = Vs2_vu[idx];\n                        }\n                    }\n                ', 'OPIVV', 'SimdMiscOp'], {}))


template <typename ElemType, typename IndexType>
Fault
Vrgather_vvMicro<ElemType, IndexType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    const uint32_t vlmax = vtype_VLMAX(vtype,vlen);
    constexpr uint32_t vd_eewb = sizeof(ElemType);
    constexpr uint32_t vs1_eewb = sizeof(IndexType);
    constexpr uint32_t vs2_eewb = sizeof(ElemType);
    constexpr uint32_t vs1_split_num = (vd_eewb + vs1_eewb - 1) / vs1_eewb;
    constexpr uint32_t vd_split_num = (vs1_eewb + vd_eewb - 1) / vd_eewb;
    [[maybe_unused]] const uint32_t vd_elems = vlenb / vd_eewb;
    [[maybe_unused]] const uint32_t vs1_elems = vlenb / vs1_eewb;
    [[maybe_unused]] const uint32_t vs2_elems = vlenb / vs2_eewb;
    [[maybe_unused]] const int8_t lmul = vtype_vlmul(vtype);
    [[maybe_unused]] const uint8_t vs2_vregs = lmul < 0 ? 1 : 1 << lmul;
    [[maybe_unused]] const uint32_t vs2_idx = microIdx % vs2_vregs;
    [[maybe_unused]] const uint32_t vs1_idx =
        microIdx / vs2_vregs / vs1_split_num;
    [[maybe_unused]] const uint32_t vd_idx =
        microIdx / vs2_vregs / vd_split_num;
    [[maybe_unused]] const uint32_t vs1_bias =
        vs1_elems * (vd_idx % vs1_split_num) / vs1_split_num;
    [[maybe_unused]] const uint32_t vd_bias =
        vd_elems * (vs1_idx % vd_split_num) / vd_split_num;


    
                    for (uint32_t i = 0; i < microVl; i++) {
                        uint32_t ei = i + vs1_idx * vs1_elems + vs1_bias;
                        if (this->vm || elem_mask(v0, ei)) {
                            const uint64_t idx = Vs1[i]
                                - vs2_elems * vs2_idx;
                            if (Vs1[i] >= vlmax)
                                Vd[i] = 0;
                            else if (idx < vs2_elems)
                                Vd[i] = Vs2[idx];
                        }
                    }
                ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vrgather_vvMicro<uint8_t, uint8_t>;
template class Vrgather_vvMicro<uint16_t, uint16_t>;
template class Vrgather_vvMicro<uint32_t, uint32_t>;
template class Vrgather_vvMicro<uint64_t, uint64_t>;
;


// VectorGatherFormat::vrgatherei16_vv((['\n                    for (uint32_t i = 0; i < microVl; i++) {\n                        uint32_t ei = i + vs1_idx * vs1_elems + vs1_bias;\n                        if (this->vm || elem_mask(v0, ei)) {\n                            const uint32_t idx = Vs1_uh[i + vs1_bias]\n                                - vs2_elems * vs2_idx;\n                            if (Vs1_uh[i + vs1_bias] >= vlmax)\n                                Vd_vu[i + vd_bias] = 0;\n                            else if (idx < vs2_elems)\n                                Vd_vu[i + vd_bias] = Vs2_vu[idx];\n                        }\n                    }\n                ', 'OPIVV', 'SimdMiscOp'], {}))


template <typename ElemType, typename IndexType>
Fault
Vrgatherei16_vvMicro<ElemType, IndexType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<uint16_t>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    const uint32_t vlmax = vtype_VLMAX(vtype,vlen);
    constexpr uint32_t vd_eewb = sizeof(ElemType);
    constexpr uint32_t vs1_eewb = sizeof(IndexType);
    constexpr uint32_t vs2_eewb = sizeof(ElemType);
    constexpr uint32_t vs1_split_num = (vd_eewb + vs1_eewb - 1) / vs1_eewb;
    constexpr uint32_t vd_split_num = (vs1_eewb + vd_eewb - 1) / vd_eewb;
    [[maybe_unused]] const uint32_t vd_elems = vlenb / vd_eewb;
    [[maybe_unused]] const uint32_t vs1_elems = vlenb / vs1_eewb;
    [[maybe_unused]] const uint32_t vs2_elems = vlenb / vs2_eewb;
    [[maybe_unused]] const int8_t lmul = vtype_vlmul(vtype);
    [[maybe_unused]] const uint8_t vs2_vregs = lmul < 0 ? 1 : 1 << lmul;
    [[maybe_unused]] const uint32_t vs2_idx = microIdx % vs2_vregs;
    [[maybe_unused]] const uint32_t vs1_idx =
        microIdx / vs2_vregs / vs1_split_num;
    [[maybe_unused]] const uint32_t vd_idx =
        microIdx / vs2_vregs / vd_split_num;
    [[maybe_unused]] const uint32_t vs1_bias =
        vs1_elems * (vd_idx % vs1_split_num) / vs1_split_num;
    [[maybe_unused]] const uint32_t vd_bias =
        vd_elems * (vs1_idx % vd_split_num) / vd_split_num;


    
                    for (uint32_t i = 0; i < microVl; i++) {
                        uint32_t ei = i + vs1_idx * vs1_elems + vs1_bias;
                        if (this->vm || elem_mask(v0, ei)) {
                            const uint32_t idx = Vs1[i + vs1_bias]
                                - vs2_elems * vs2_idx;
                            if (Vs1[i + vs1_bias] >= vlmax)
                                Vd[i + vd_bias] = 0;
                            else if (idx < vs2_elems)
                                Vd[i + vd_bias] = Vs2[idx];
                        }
                    }
                ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vrgatherei16_vvMicro<uint8_t, uint16_t>;
template class Vrgatherei16_vvMicro<uint16_t, uint16_t>;
template class Vrgatherei16_vvMicro<uint32_t, uint16_t>;
template class Vrgatherei16_vvMicro<uint64_t, uint16_t>;
;


// VectorIntFormat::vadc_vvm(['\n                            Vd_vi[i] = Vs2_vi[i] + Vs1_vi[i]\n                                    + elem_mask(v0, ei);\n                        ', 'OPIVV', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vadc_vvmMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            
                            Vd[i] = Vs2[i] + Vs1[i]
                                    + elem_mask(v0, ei);
                        
            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vadc_vvmMicro<uint8_t>;
template class Vadc_vvmMicro<uint16_t>;
template class Vadc_vvmMicro<uint32_t>;
template class Vadc_vvmMicro<uint64_t>;
;


// Unknown::unknown(([], {}))

// VectorIntFormat::vsbc_vvm(['\n                            Vd_vi[i] = Vs2_vi[i] - Vs1_vi[i]\n                                    - elem_mask(v0, ei);\n                        ', 'OPIVV', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vsbc_vvmMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            
                            Vd[i] = Vs2[i] - Vs1[i]
                                    - elem_mask(v0, ei);
                        
            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vsbc_vvmMicro<uint8_t>;
template class Vsbc_vvmMicro<uint16_t>;
template class Vsbc_vvmMicro<uint32_t>;
template class Vsbc_vvmMicro<uint64_t>;
;


// Unknown::unknown(([], {}))

// VectorIntFormat::vmerge_vvm(['\n                            Vd_vu[i] = elem_mask(v0, ei)\n                                    ? Vs1_vu[i]\n                                    : Vs2_vu[i];\n                        ', 'OPIVV', 'SimdMiscOp'],{})


template <typename ElemType>
Fault
Vmerge_vvmMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            
                            Vd[i] = elem_mask(v0, ei)
                                    ? Vs1[i]
                                    : Vs2[i];
                        
            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vmerge_vvmMicro<uint8_t>;
template class Vmerge_vvmMicro<uint16_t>;
template class Vmerge_vvmMicro<uint32_t>;
template class Vmerge_vvmMicro<uint64_t>;
;


// VectorIntFormat::vmv_v_v(['\n                                Vd_vu[i] = Vs1_vu[i];\n                            ', 'OPIVV', 'SimdMiscOp'],{})


template <typename ElemType>
Fault
Vmv_v_vMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
                                Vd[i] = Vs1[i];
                            
            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vmv_v_vMicro<uint8_t>;
template class Vmv_v_vMicro<uint16_t>;
template class Vmv_v_vMicro<uint32_t>;
template class Vmv_v_vMicro<uint64_t>;
;


// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// VectorIntVxsatFormat::vsaddu_vv(['\n                        Vd_vu[i] = sat_addu<vu>(Vs2_vu[i], Vs1_vu[i],\n                            vxsatptr);\n                    ', 'OPIVV', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vsaddu_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = sat_addu<vu>(Vs2[i], Vs1[i],
                            vxsatptr);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vsaddu_vvMicro<uint8_t>;
template class Vsaddu_vvMicro<uint16_t>;
template class Vsaddu_vvMicro<uint32_t>;
template class Vsaddu_vvMicro<uint64_t>;
;


// VectorIntVxsatFormat::vsadd_vv(['\n                        Vd_vu[i] = sat_add<vi>(Vs2_vu[i], Vs1_vu[i],\n                            vxsatptr);\n                    ', 'OPIVV', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vsadd_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = sat_add<vi>(Vs2[i], Vs1[i],
                            vxsatptr);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vsadd_vvMicro<uint8_t>;
template class Vsadd_vvMicro<uint16_t>;
template class Vsadd_vvMicro<uint32_t>;
template class Vsadd_vvMicro<uint64_t>;
;


// VectorIntVxsatFormat::vssubu_vv(['\n                        Vd_vu[i] = sat_subu<vu>(Vs2_vu[i], Vs1_vu[i],\n                            vxsatptr);\n                    ', 'OPIVV', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vssubu_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = sat_subu<vu>(Vs2[i], Vs1[i],
                            vxsatptr);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vssubu_vvMicro<uint8_t>;
template class Vssubu_vvMicro<uint16_t>;
template class Vssubu_vvMicro<uint32_t>;
template class Vssubu_vvMicro<uint64_t>;
;


// VectorIntVxsatFormat::vssub_vv(['\n                        Vd_vu[i] = sat_sub<vi>(Vs2_vu[i], Vs1_vu[i],\n                            vxsatptr);\n                    ', 'OPIVV', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vssub_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = sat_sub<vi>(Vs2[i], Vs1[i],
                            vxsatptr);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vssub_vvMicro<uint8_t>;
template class Vssub_vvMicro<uint16_t>;
template class Vssub_vvMicro<uint32_t>;
template class Vssub_vvMicro<uint64_t>;
;


// VectorIntVxsatFormat::vsmul_vv(['\n                        vi max = std::numeric_limits<vi>::max();\n                        vi min = std::numeric_limits<vi>::min();\n                        bool overflow = Vs1_vi[i] == Vs2_vi[i] &&\n                                        Vs1_vi[i] == min;\n                        __int128_t result = (__int128_t)Vs1_vi[i] *\n                                            (__int128_t)Vs2_vi[i];\n                        result = int_rounding<__int128_t>(\n                            result, 0 /* TODO */, sew - 1);\n                        result = result >> (sew - 1);\n                        if (overflow) {\n                            result = max;\n                            *vxsatptr = true;\n                        }\n\n                        Vd_vi[i] = (vi)result;\n                    ', 'OPIVV', 'SimdMultOp'],{})


template <typename ElemType>
Fault
Vsmul_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        vi max = std::numeric_limits<vi>::max();
                        vi min = std::numeric_limits<vi>::min();
                        bool overflow = Vs1[i] == Vs2[i] &&
                                        Vs1[i] == min;
                        __int128_t result = (__int128_t)Vs1[i] *
                                            (__int128_t)Vs2[i];
                        result = int_rounding<__int128_t>(
                            result, 0 /* TODO */, sew - 1);
                        result = result >> (sew - 1);
                        if (overflow) {
                            result = max;
                            *vxsatptr = true;
                        }

                        Vd[i] = (vi)result;
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vsmul_vvMicro<uint8_t>;
template class Vsmul_vvMicro<uint16_t>;
template class Vsmul_vvMicro<uint32_t>;
template class Vsmul_vvMicro<uint64_t>;
;


// VectorIntFormat::vsll_vv(['\n                        Vd_vu[i] = Vs2_vu[i] << (Vs1_vu[i] & (sew - 1));\n                    ', 'OPIVV', 'SimdShiftOp'],{})


template <typename ElemType>
Fault
Vsll_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = Vs2[i] << (Vs1[i] & (sew - 1));
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vsll_vvMicro<uint8_t>;
template class Vsll_vvMicro<uint16_t>;
template class Vsll_vvMicro<uint32_t>;
template class Vsll_vvMicro<uint64_t>;
;


// VectorIntFormat::vsrl_vv(['\n                        Vd_vu[i] = Vs2_vu[i] >> (Vs1_vu[i] & (sew - 1));\n                    ', 'OPIVV', 'SimdShiftOp'],{})


template <typename ElemType>
Fault
Vsrl_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = Vs2[i] >> (Vs1[i] & (sew - 1));
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vsrl_vvMicro<uint8_t>;
template class Vsrl_vvMicro<uint16_t>;
template class Vsrl_vvMicro<uint32_t>;
template class Vsrl_vvMicro<uint64_t>;
;


// VectorIntFormat::vsra_vv(['\n                        Vd_vi[i] = Vs2_vi[i] >> (Vs1_vu[i] & (sew - 1));\n                    ', 'OPIVV', 'SimdShiftOp'],{})


template <typename ElemType>
Fault
Vsra_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = Vs2[i] >> (Vs1[i] & (sew - 1));
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vsra_vvMicro<uint8_t>;
template class Vsra_vvMicro<uint16_t>;
template class Vsra_vvMicro<uint32_t>;
template class Vsra_vvMicro<uint64_t>;
;


// VectorIntFormat::vssrl_vv(['\n                        int sh = Vs1_vu[i] & (sew - 1);\n                        __uint128_t val = Vs2_vu[i];\n\n                        val = int_rounding<__uint128_t>(val,\n                            xc->readMiscReg(MISCREG_VXRM), sh);\n                        Vd_vu[i] = val >> sh;\n                    ', 'OPIVV', 'SimdShiftOp'],{})


template <typename ElemType>
Fault
Vssrl_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        int sh = Vs1[i] & (sew - 1);
                        __uint128_t val = Vs2[i];

                        val = int_rounding<__uint128_t>(val,
                            xc->readMiscReg(MISCREG_VXRM), sh);
                        Vd[i] = val >> sh;
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vssrl_vvMicro<uint8_t>;
template class Vssrl_vvMicro<uint16_t>;
template class Vssrl_vvMicro<uint32_t>;
template class Vssrl_vvMicro<uint64_t>;
;


// VectorIntFormat::vssra_vv(['\n                        int sh = Vs1_vi[i] & (sew - 1);\n                        __int128_t val = Vs2_vi[i];\n\n                        val = int_rounding<__int128_t>(val,\n                            xc->readMiscReg(MISCREG_VXRM), sh);\n                        Vd_vi[i] = val >> sh;\n                    ', 'OPIVV', 'SimdShiftOp'],{})


template <typename ElemType>
Fault
Vssra_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        int sh = Vs1[i] & (sew - 1);
                        __int128_t val = Vs2[i];

                        val = int_rounding<__int128_t>(val,
                            xc->readMiscReg(MISCREG_VXRM), sh);
                        Vd[i] = val >> sh;
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vssra_vvMicro<uint8_t>;
template class Vssra_vvMicro<uint16_t>;
template class Vssra_vvMicro<uint32_t>;
template class Vssra_vvMicro<uint64_t>;
;


// VectorReduceIntWideningFormat::vwredsumu_vs(['\n                        Vd_vwu[0] = reduce_loop(std::plus<vwu>(),\n                            Vs1_vwu, Vs2_vu);\n                    ', 'OPIVV', 'SimdReduceAddOp'],{})


template <typename ElemType>
Fault
Vwredsumu_vsMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    using vwu [[maybe_unused]] = typename double_width<vu>::type;
    using vwi [[maybe_unused]] = typename double_width<vi>::type;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vwu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;

    auto reduce_loop =
        [&, this](const auto& f, const auto* _, const auto* vs2) {
            vwu tmp_val = Vs1[0];
            for (uint32_t i = 0; i < this->microVl; i++) {
                uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) *
                    this->microIdx;
                if (this->vm || elem_mask(v0, ei)) {
                    tmp_val = f(tmp_val, Vs2[i]);
                }
            }
            return tmp_val;
        };

    
                        Vd[0] = reduce_loop(std::plus<vwu>(),
                            Vs1, Vs2);
                    ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vwredsumu_vsMicro<uint8_t>;
template class Vwredsumu_vsMicro<uint16_t>;
template class Vwredsumu_vsMicro<uint32_t>;
;


// VectorReduceIntWideningFormat::vwredsum_vs(['\n                        Vd_vwu[0] = reduce_loop(std::plus<vwi>(),\n                            Vs1_vwi, Vs2_vi);\n                    ', 'OPIVV', 'SimdReduceAddOp'],{})


template <typename ElemType>
Fault
Vwredsum_vsMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    using vwu [[maybe_unused]] = typename double_width<vu>::type;
    using vwi [[maybe_unused]] = typename double_width<vi>::type;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vwi>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;

    auto reduce_loop =
        [&, this](const auto& f, const auto* _, const auto* vs2) {
            vwu tmp_val = Vs1[0];
            for (uint32_t i = 0; i < this->microVl; i++) {
                uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) *
                    this->microIdx;
                if (this->vm || elem_mask(v0, ei)) {
                    tmp_val = f(tmp_val, Vs2[i]);
                }
            }
            return tmp_val;
        };

    
                        Vd[0] = reduce_loop(std::plus<vwi>(),
                            Vs1, Vs2);
                    ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vwredsum_vsMicro<uint8_t>;
template class Vwredsum_vsMicro<uint16_t>;
template class Vwredsum_vsMicro<uint32_t>;
;


// VectorIntMaskFormat::vmadc_vvm(['\n                            Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                                carry_out(Vs2_vu[i], Vs1_vu[i],\n                                    elem_mask(v0, ei)));\n                        ', 'OPIVV', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vmadc_vvmMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;

    const uint32_t bit_offset = vlenb / sizeof(ElemType);
    const uint32_t offset = bit_offset * microIdx;

    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            
                            Vd[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,
                                carry_out(Vs2[i], Vs1[i],
                                    elem_mask(v0, ei)));
                        
            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vmadc_vvmMicro<uint8_t>;
template class Vmadc_vvmMicro<uint16_t>;
template class Vmadc_vvmMicro<uint32_t>;
template class Vmadc_vvmMicro<uint64_t>;
;


// VectorIntMaskFormat::vmadc_vv(['\n                            Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                                carry_out(Vs2_vu[i], Vs1_vu[i]));\n                        ', 'OPIVV', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vmadc_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    ;

    const uint32_t bit_offset = vlenb / sizeof(ElemType);
    const uint32_t offset = bit_offset * microIdx;

    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
                            Vd[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,
                                carry_out(Vs2[i], Vs1[i]));
                        
            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vmadc_vvMicro<uint8_t>;
template class Vmadc_vvMicro<uint16_t>;
template class Vmadc_vvMicro<uint32_t>;
template class Vmadc_vvMicro<uint64_t>;
;


// Unknown::unknown(([], {}))

// VectorIntMaskFormat::vmsbc_vvm(['\n                            Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                                borrow_out(Vs2_vi[i], Vs1_vi[i],\n                                    elem_mask(v0, ei)));\n                        ', 'OPIVV', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vmsbc_vvmMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;

    const uint32_t bit_offset = vlenb / sizeof(ElemType);
    const uint32_t offset = bit_offset * microIdx;

    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            
                            Vd[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,
                                borrow_out(Vs2[i], Vs1[i],
                                    elem_mask(v0, ei)));
                        
            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vmsbc_vvmMicro<uint8_t>;
template class Vmsbc_vvmMicro<uint16_t>;
template class Vmsbc_vvmMicro<uint32_t>;
template class Vmsbc_vvmMicro<uint64_t>;
;


// VectorIntMaskFormat::vmsbc_vv(['\n                            Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                                borrow_out(Vs2_vi[i], Vs1_vi[i]));\n                        ', 'OPIVV', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vmsbc_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    ;

    const uint32_t bit_offset = vlenb / sizeof(ElemType);
    const uint32_t offset = bit_offset * microIdx;

    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
                            Vd[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,
                                borrow_out(Vs2[i], Vs1[i]));
                        
            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vmsbc_vvMicro<uint8_t>;
template class Vmsbc_vvMicro<uint16_t>;
template class Vmsbc_vvMicro<uint32_t>;
template class Vmsbc_vvMicro<uint64_t>;
;


// Unknown::unknown(([], {}))

// VectorIntMaskFormat::vmseq_vv(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            (Vs2_vu[i] == Vs1_vu[i]));\n                    ', 'OPIVV', 'SimdCmpOp'],{})


template <typename ElemType>
Fault
Vmseq_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;

    const uint32_t bit_offset = vlenb / sizeof(ElemType);
    const uint32_t offset = bit_offset * microIdx;

    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,
                            (Vs2[i] == Vs1[i]));
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vmseq_vvMicro<uint8_t>;
template class Vmseq_vvMicro<uint16_t>;
template class Vmseq_vvMicro<uint32_t>;
template class Vmseq_vvMicro<uint64_t>;
;


// VectorIntMaskFormat::vmsne_vv(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            (Vs2_vu[i] != Vs1_vu[i]));\n                    ', 'OPIVV', 'SimdCmpOp'],{})


template <typename ElemType>
Fault
Vmsne_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;

    const uint32_t bit_offset = vlenb / sizeof(ElemType);
    const uint32_t offset = bit_offset * microIdx;

    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,
                            (Vs2[i] != Vs1[i]));
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vmsne_vvMicro<uint8_t>;
template class Vmsne_vvMicro<uint16_t>;
template class Vmsne_vvMicro<uint32_t>;
template class Vmsne_vvMicro<uint64_t>;
;


// VectorIntMaskFormat::vmsltu_vv(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            (Vs2_vu[i] < Vs1_vu[i]));\n                    ', 'OPIVV', 'SimdCmpOp'],{})


template <typename ElemType>
Fault
Vmsltu_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;

    const uint32_t bit_offset = vlenb / sizeof(ElemType);
    const uint32_t offset = bit_offset * microIdx;

    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,
                            (Vs2[i] < Vs1[i]));
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vmsltu_vvMicro<uint8_t>;
template class Vmsltu_vvMicro<uint16_t>;
template class Vmsltu_vvMicro<uint32_t>;
template class Vmsltu_vvMicro<uint64_t>;
;


// VectorIntMaskFormat::vmslt_vv(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            (Vs2_vi[i] < Vs1_vi[i]));\n                    ', 'OPIVV', 'SimdCmpOp'],{})


template <typename ElemType>
Fault
Vmslt_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;

    const uint32_t bit_offset = vlenb / sizeof(ElemType);
    const uint32_t offset = bit_offset * microIdx;

    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,
                            (Vs2[i] < Vs1[i]));
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vmslt_vvMicro<uint8_t>;
template class Vmslt_vvMicro<uint16_t>;
template class Vmslt_vvMicro<uint32_t>;
template class Vmslt_vvMicro<uint64_t>;
;


// VectorIntMaskFormat::vmsleu_vv(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            (Vs2_vu[i] <= Vs1_vu[i]));\n                    ', 'OPIVV', 'SimdCmpOp'],{})


template <typename ElemType>
Fault
Vmsleu_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;

    const uint32_t bit_offset = vlenb / sizeof(ElemType);
    const uint32_t offset = bit_offset * microIdx;

    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,
                            (Vs2[i] <= Vs1[i]));
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vmsleu_vvMicro<uint8_t>;
template class Vmsleu_vvMicro<uint16_t>;
template class Vmsleu_vvMicro<uint32_t>;
template class Vmsleu_vvMicro<uint64_t>;
;


// VectorIntMaskFormat::vmsle_vv(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            (Vs2_vi[i] <= Vs1_vi[i]));\n                    ', 'OPIVV', 'SimdCmpOp'],{})


template <typename ElemType>
Fault
Vmsle_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;

    const uint32_t bit_offset = vlenb / sizeof(ElemType);
    const uint32_t offset = bit_offset * microIdx;

    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,
                            (Vs2[i] <= Vs1[i]));
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vmsle_vvMicro<uint8_t>;
template class Vmsle_vvMicro<uint16_t>;
template class Vmsle_vvMicro<uint32_t>;
template class Vmsle_vvMicro<uint64_t>;
;


// VectorIntNarrowingFormat::vnsrl_wv(['\n                        Vd_vu[i + offset] = (vu)(Vs2_vwu[i] >>\n                            ((vwu)Vs1_vu[i + offset] & (sew * 2 - 1)));\n                    ', 'OPIVV', 'SimdShiftOp'],{})


template <typename ElemType>
Fault
Vnsrl_wvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    using vwu [[maybe_unused]] = typename double_width<vu>::type;
    using vwi [[maybe_unused]] = typename double_width<vi>::type;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vwu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vs2 % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned VS2 group in Narrowing op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
        
            if ((VS2 < VD) &&
                (VD <= (VS2 + num_microops - 1))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is smaller than
                // the source EEW and the overlap is in the lowest-numbered
                // part of the source register group
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Narrowing op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            if ((VS1 < VD) &&
                (VD <= (VS1 + num_microops - 1))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is smaller than
                // the source EEW and the overlap is in the lowest-numbered
                // part of the source register group
                std::string error =
                    csprintf("Unsupported overlap in VS1 and VD for "
                             "Narrowing op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i + offset] = (vu)(Vs2[i] >>
                            ((vwu)Vs1[i + offset] & (sew * 2 - 1)));
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vnsrl_wvMicro<uint8_t>;
template class Vnsrl_wvMicro<uint16_t>;
template class Vnsrl_wvMicro<uint32_t>;
;


// VectorIntNarrowingFormat::vnsra_wv(['\n                        Vd_vi[i + offset] = (vi)(Vs2_vwi[i] >>\n                            ((vwu)Vs1_vu[i + offset] & (sew * 2 - 1)));\n                    ', 'OPIVV', 'SimdShiftOp'],{})


template <typename ElemType>
Fault
Vnsra_wvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    using vwu [[maybe_unused]] = typename double_width<vu>::type;
    using vwi [[maybe_unused]] = typename double_width<vi>::type;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vwi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vs2 % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned VS2 group in Narrowing op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
        
            if ((VS2 < VD) &&
                (VD <= (VS2 + num_microops - 1))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is smaller than
                // the source EEW and the overlap is in the lowest-numbered
                // part of the source register group
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Narrowing op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            if ((VS1 < VD) &&
                (VD <= (VS1 + num_microops - 1))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is smaller than
                // the source EEW and the overlap is in the lowest-numbered
                // part of the source register group
                std::string error =
                    csprintf("Unsupported overlap in VS1 and VD for "
                             "Narrowing op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i + offset] = (vi)(Vs2[i] >>
                            ((vwu)Vs1[i + offset] & (sew * 2 - 1)));
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vnsra_wvMicro<uint8_t>;
template class Vnsra_wvMicro<uint16_t>;
template class Vnsra_wvMicro<uint32_t>;
;


// VectorIntNarrowingFormat::vnclipu_wv(['\n                        vu max = std::numeric_limits<vu>::max();\n                        uint64_t sign_mask =\n                            std::numeric_limits<uint64_t>::max() << sew;\n                        __uint128_t res = Vs2_vwu[i];\n                        unsigned shift = Vs1_vu[i + offset] & ((sew * 2) - 1);\n\n                        res = int_rounding<__uint128_t>(\n                            res, 0 /* TODO */, shift) >> shift;\n\n                        if (res & sign_mask) {\n                            res = max;\n                            // TODO: vxsat\n                        }\n\n                        Vd_vu[i + offset] = (vu)res;\n                    ', 'OPIVV', 'SimdCvtOp'],{})


template <typename ElemType>
Fault
Vnclipu_wvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    using vwu [[maybe_unused]] = typename double_width<vu>::type;
    using vwi [[maybe_unused]] = typename double_width<vi>::type;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vwu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vs2 % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned VS2 group in Narrowing op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
        
            if ((VS2 < VD) &&
                (VD <= (VS2 + num_microops - 1))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is smaller than
                // the source EEW and the overlap is in the lowest-numbered
                // part of the source register group
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Narrowing op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            if ((VS1 < VD) &&
                (VD <= (VS1 + num_microops - 1))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is smaller than
                // the source EEW and the overlap is in the lowest-numbered
                // part of the source register group
                std::string error =
                    csprintf("Unsupported overlap in VS1 and VD for "
                             "Narrowing op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        vu max = std::numeric_limits<vu>::max();
                        uint64_t sign_mask =
                            std::numeric_limits<uint64_t>::max() << sew;
                        __uint128_t res = Vs2[i];
                        unsigned shift = Vs1[i + offset] & ((sew * 2) - 1);

                        res = int_rounding<__uint128_t>(
                            res, 0 /* TODO */, shift) >> shift;

                        if (res & sign_mask) {
                            res = max;
                            // TODO: vxsat
                        }

                        Vd[i + offset] = (vu)res;
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vnclipu_wvMicro<uint8_t>;
template class Vnclipu_wvMicro<uint16_t>;
template class Vnclipu_wvMicro<uint32_t>;
;


// VectorIntNarrowingFormat::vnclip_wv(['\n                        vi max = std::numeric_limits<vi>::max();\n                        vi min = std::numeric_limits<vi>::min();\n                        __int128_t res = Vs2_vwi[i];\n                        unsigned shift = Vs1_vi[i + offset] & ((sew * 2) - 1);\n\n                        res = int_rounding<__int128_t>(\n                            res, 0 /* TODO */, shift) >> shift;\n\n                        if (res < min) {\n                            res = min;\n                            // TODO: vxsat\n                        } else if (res > max) {\n                            res = max;\n                            // TODO: vxsat\n                        }\n\n                        Vd_vi[i + offset] = (vi)res;\n                    ', 'OPIVV', 'SimdCvtOp'],{})


template <typename ElemType>
Fault
Vnclip_wvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    using vwu [[maybe_unused]] = typename double_width<vu>::type;
    using vwi [[maybe_unused]] = typename double_width<vi>::type;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vwi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vs2 % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned VS2 group in Narrowing op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
        
            if ((VS2 < VD) &&
                (VD <= (VS2 + num_microops - 1))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is smaller than
                // the source EEW and the overlap is in the lowest-numbered
                // part of the source register group
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Narrowing op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            if ((VS1 < VD) &&
                (VD <= (VS1 + num_microops - 1))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is smaller than
                // the source EEW and the overlap is in the lowest-numbered
                // part of the source register group
                std::string error =
                    csprintf("Unsupported overlap in VS1 and VD for "
                             "Narrowing op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        vi max = std::numeric_limits<vi>::max();
                        vi min = std::numeric_limits<vi>::min();
                        __int128_t res = Vs2[i];
                        unsigned shift = Vs1[i + offset] & ((sew * 2) - 1);

                        res = int_rounding<__int128_t>(
                            res, 0 /* TODO */, shift) >> shift;

                        if (res < min) {
                            res = min;
                            // TODO: vxsat
                        } else if (res > max) {
                            res = max;
                            // TODO: vxsat
                        }

                        Vd[i + offset] = (vi)res;
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vnclip_wvMicro<uint8_t>;
template class Vnclip_wvMicro<uint16_t>;
template class Vnclip_wvMicro<uint32_t>;
;


// Unknown::unknown(([], {}))

// VectorFloatFormat::vfadd_vv((['\n                    auto fd = fadd<et>(ftype<et>(Vs2_vu[i]),\n                                       ftype<et>(Vs1_vu[i]));\n                    Vd_vu[i] = fd.v;\n                ', 'OPFVV', 'SimdFloatAddOp'], {}))


template <typename ElemType>
Fault
Vfadd_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                    auto fd = fadd<et>(ftype<et>(Vs2[i]),
                                       ftype<et>(Vs1[i]));
                    Vd[i] = fd.v;
                }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vfadd_vvMicro<float16_t>;
template class Vfadd_vvMicro<float32_t>;
template class Vfadd_vvMicro<float64_t>;
;


// VectorReduceFloatFormat::vfredusum_vs((['\n                    Vd_vu[0] = reduce_loop([](const vu& src1, const vu& src2) {\n                        return fadd<et>(ftype<et>(src1), ftype<et>(src2));\n                    }, Vs1_vu, Vs2_vu);\n                ', 'OPFVV', 'SimdFloatReduceAddOp'], {}))


template <typename ElemType>
Fault
Vfredusum_vsMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    
        using et = ElemType;
        using vu = decltype(et::v);
    ;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);

    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;

    auto reduce_loop =
        [&, this](const auto& f, const auto* _, const auto* vs2) {
            vu tmp_val = Vs1[0];
            for (uint32_t i = 0; i < this->microVl; i++) {
                uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) *
                    this->microIdx;
                if (this->vm || elem_mask(v0, ei)) {
                    tmp_val = f(tmp_val, Vs2[i]).v;
                }
            }
            return tmp_val;
        };

    
        std::feclearexcept(FE_ALL_EXCEPT);
        
                    Vd[0] = reduce_loop([](const vu& src1, const vu& src2) {
                        return fadd<et>(ftype<et>(src1), ftype<et>(src2));
                    }, Vs1, Vs2);
                
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vfredusum_vsMicro<float16_t>;
template class Vfredusum_vsMicro<float32_t>;
template class Vfredusum_vsMicro<float64_t>;
;


// VectorFloatFormat::vfsub_vv((['\n                    auto fd = fsub<et>(ftype<et>(Vs2_vu[i]),\n                                       ftype<et>(Vs1_vu[i]));\n                    Vd_vu[i] = fd.v;\n                ', 'OPFVV', 'SimdFloatAddOp'], {}))


template <typename ElemType>
Fault
Vfsub_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                    auto fd = fsub<et>(ftype<et>(Vs2[i]),
                                       ftype<et>(Vs1[i]));
                    Vd[i] = fd.v;
                }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vfsub_vvMicro<float16_t>;
template class Vfsub_vvMicro<float32_t>;
template class Vfsub_vvMicro<float64_t>;
;


// VectorReduceFloatFormat::vfredosum_vs((['\n                    Vd_vu[0] = reduce_loop([](const vu& src1, const vu& src2) {\n                        return fadd<et>(ftype<et>(src1), ftype<et>(src2));\n                    }, Vs1_vu, Vs2_vu);\n                ', 'OPFVV', 'SimdFloatReduceAddOp'], {}))


template <typename ElemType>
Fault
Vfredosum_vsMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    
        using et = ElemType;
        using vu = decltype(et::v);
    ;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);

    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;

    auto reduce_loop =
        [&, this](const auto& f, const auto* _, const auto* vs2) {
            vu tmp_val = Vs1[0];
            for (uint32_t i = 0; i < this->microVl; i++) {
                uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) *
                    this->microIdx;
                if (this->vm || elem_mask(v0, ei)) {
                    tmp_val = f(tmp_val, Vs2[i]).v;
                }
            }
            return tmp_val;
        };

    
        std::feclearexcept(FE_ALL_EXCEPT);
        
                    Vd[0] = reduce_loop([](const vu& src1, const vu& src2) {
                        return fadd<et>(ftype<et>(src1), ftype<et>(src2));
                    }, Vs1, Vs2);
                
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vfredosum_vsMicro<float16_t>;
template class Vfredosum_vsMicro<float32_t>;
template class Vfredosum_vsMicro<float64_t>;
;


// VectorFloatFormat::vfmin_vv((['\n                    auto fd = fmin<et>(ftype<et>(Vs2_vu[i]),\n                                       ftype<et>(Vs1_vu[i]));\n                    Vd_vu[i] = fd.v;\n                ', 'OPFVV', 'SimdFloatCmpOp'], {}))


template <typename ElemType>
Fault
Vfmin_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                    auto fd = fmin<et>(ftype<et>(Vs2[i]),
                                       ftype<et>(Vs1[i]));
                    Vd[i] = fd.v;
                }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vfmin_vvMicro<float16_t>;
template class Vfmin_vvMicro<float32_t>;
template class Vfmin_vvMicro<float64_t>;
;


// VectorReduceFloatFormat::vfredmin_vs((['\n                    Vd_vu[0] = reduce_loop([](const vu& src1, const vu& src2) {\n                        return fmin<et>(ftype<et>(src1), ftype<et>(src2));\n                    }, Vs1_vu, Vs2_vu);\n                ', 'OPFVV', 'SimdFloatReduceCmpOp'], {}))


template <typename ElemType>
Fault
Vfredmin_vsMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    
        using et = ElemType;
        using vu = decltype(et::v);
    ;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);

    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;

    auto reduce_loop =
        [&, this](const auto& f, const auto* _, const auto* vs2) {
            vu tmp_val = Vs1[0];
            for (uint32_t i = 0; i < this->microVl; i++) {
                uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) *
                    this->microIdx;
                if (this->vm || elem_mask(v0, ei)) {
                    tmp_val = f(tmp_val, Vs2[i]).v;
                }
            }
            return tmp_val;
        };

    
        std::feclearexcept(FE_ALL_EXCEPT);
        
                    Vd[0] = reduce_loop([](const vu& src1, const vu& src2) {
                        return fmin<et>(ftype<et>(src1), ftype<et>(src2));
                    }, Vs1, Vs2);
                
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vfredmin_vsMicro<float16_t>;
template class Vfredmin_vsMicro<float32_t>;
template class Vfredmin_vsMicro<float64_t>;
;


// VectorFloatFormat::vfmax_vv((['\n                    auto fd = fmax<et>(ftype<et>(Vs2_vu[i]),\n                                       ftype<et>(Vs1_vu[i]));\n                    Vd_vu[i] = fd.v;\n                ', 'OPFVV', 'SimdFloatCmpOp'], {}))


template <typename ElemType>
Fault
Vfmax_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                    auto fd = fmax<et>(ftype<et>(Vs2[i]),
                                       ftype<et>(Vs1[i]));
                    Vd[i] = fd.v;
                }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vfmax_vvMicro<float16_t>;
template class Vfmax_vvMicro<float32_t>;
template class Vfmax_vvMicro<float64_t>;
;


// VectorReduceFloatFormat::vfredmax_vs((['\n                    Vd_vu[0] = reduce_loop([](const vu& src1, const vu& src2) {\n                        return fmax<et>(ftype<et>(src1), ftype<et>(src2));\n                    }, Vs1_vu, Vs2_vu);\n                ', 'OPFVV', 'SimdFloatReduceCmpOp'], {}))


template <typename ElemType>
Fault
Vfredmax_vsMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    
        using et = ElemType;
        using vu = decltype(et::v);
    ;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);

    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;

    auto reduce_loop =
        [&, this](const auto& f, const auto* _, const auto* vs2) {
            vu tmp_val = Vs1[0];
            for (uint32_t i = 0; i < this->microVl; i++) {
                uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) *
                    this->microIdx;
                if (this->vm || elem_mask(v0, ei)) {
                    tmp_val = f(tmp_val, Vs2[i]).v;
                }
            }
            return tmp_val;
        };

    
        std::feclearexcept(FE_ALL_EXCEPT);
        
                    Vd[0] = reduce_loop([](const vu& src1, const vu& src2) {
                        return fmax<et>(ftype<et>(src1), ftype<et>(src2));
                    }, Vs1, Vs2);
                
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vfredmax_vsMicro<float16_t>;
template class Vfredmax_vsMicro<float32_t>;
template class Vfredmax_vsMicro<float64_t>;
;


// VectorFloatFormat::vfsgnj_vv((['\n                    Vd_vu[i] = fsgnj<et>(ftype<et>(Vs2_vu[i]),\n                                         ftype<et>(Vs1_vu[i]),\n                                         false, false).v;\n                ', 'OPFVV', 'SimdFloatCvtOp'], {}))


template <typename ElemType>
Fault
Vfsgnj_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                    Vd[i] = fsgnj<et>(ftype<et>(Vs2[i]),
                                         ftype<et>(Vs1[i]),
                                         false, false).v;
                }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vfsgnj_vvMicro<float16_t>;
template class Vfsgnj_vvMicro<float32_t>;
template class Vfsgnj_vvMicro<float64_t>;
;


// VectorFloatFormat::vfsgnjn_vv((['\n                    Vd_vu[i] = fsgnj<et>(ftype<et>(Vs2_vu[i]),\n                                         ftype<et>(Vs1_vu[i]),\n                                         true, false).v;\n                ', 'OPFVV', 'SimdFloatCvtOp'], {}))


template <typename ElemType>
Fault
Vfsgnjn_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                    Vd[i] = fsgnj<et>(ftype<et>(Vs2[i]),
                                         ftype<et>(Vs1[i]),
                                         true, false).v;
                }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vfsgnjn_vvMicro<float16_t>;
template class Vfsgnjn_vvMicro<float32_t>;
template class Vfsgnjn_vvMicro<float64_t>;
;


// VectorFloatFormat::vfsgnjx_vv((['\n                    Vd_vu[i] = fsgnj<et>(ftype<et>(Vs2_vu[i]),\n                                         ftype<et>(Vs1_vu[i]),\n                                         false, true).v;\n                ', 'OPFVV', 'SimdFloatCvtOp'], {}))


template <typename ElemType>
Fault
Vfsgnjx_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                    Vd[i] = fsgnj<et>(ftype<et>(Vs2[i]),
                                         ftype<et>(Vs1[i]),
                                         false, true).v;
                }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vfsgnjx_vvMicro<float16_t>;
template class Vfsgnjx_vvMicro<float32_t>;
template class Vfsgnjx_vvMicro<float64_t>;
;


// VectorNonSplitFormat::vfmv_f_s((['\n                            freg_t fd = freg(ftype<et>(Vs2_vu[0]));\n                            Fd_bits = fd.v;\n                        ', 'OPFVV', 'SimdMiscOp'], {}))


template <typename ElemType>
Fault
Vfmv_f_s<ElemType>::execute(ExecContext* xc,
                                    trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    uint64_t Fd_bits = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vu>();
;
    ;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
                            freg_t fd = freg(ftype<et>(Vs2[0]));
                            Fd_bits = fd.v;
                        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        {
            RegVal final_val = Fd_bits;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(floatRegClass, final_val);
            }
        };
    return NoFault;
}

template class Vfmv_f_s<float16_t>;
template class Vfmv_f_s<float32_t>;
template class Vfmv_f_s<float64_t>;
;


// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// VectorFloatCvtFormat::vfcvt_xu_f_v(['\n                            Vd_vu[i] = f_to_ui<et>(ftype<et>(Vs2_vu[i]),\n                                                   softfloat_roundingMode);\n                        ', 'OPFVV', 'SimdFloatCvtOp'],{})


template <typename ElemType>
Fault
Vfcvt_xu_f_vMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(1);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                            Vd[i] = f_to_ui<et>(ftype<et>(Vs2[i]),
                                                   softfloat_roundingMode);
                        }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vfcvt_xu_f_vMicro<float16_t>;
template class Vfcvt_xu_f_vMicro<float32_t>;
template class Vfcvt_xu_f_vMicro<float64_t>;
;


// VectorFloatCvtFormat::vfcvt_x_f_v(['\n                            Vd_vu[i] = f_to_i<et>(ftype<et>(Vs2_vu[i]),\n                                                  softfloat_roundingMode);\n                        ', 'OPFVV', 'SimdFloatCvtOp'],{})


template <typename ElemType>
Fault
Vfcvt_x_f_vMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(1);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                            Vd[i] = f_to_i<et>(ftype<et>(Vs2[i]),
                                                  softfloat_roundingMode);
                        }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vfcvt_x_f_vMicro<float16_t>;
template class Vfcvt_x_f_vMicro<float32_t>;
template class Vfcvt_x_f_vMicro<float64_t>;
;


// VectorFloatCvtFormat::vfcvt_f_xu_v(['\n                            auto fd = ui_to_f<et>(Vs2_vu[i]);\n                            Vd_vu[i] = fd.v;\n                        ', 'OPFVV', 'SimdFloatCvtOp'],{})


template <typename ElemType>
Fault
Vfcvt_f_xu_vMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(1);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                            auto fd = ui_to_f<et>(Vs2[i]);
                            Vd[i] = fd.v;
                        }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vfcvt_f_xu_vMicro<float16_t>;
template class Vfcvt_f_xu_vMicro<float32_t>;
template class Vfcvt_f_xu_vMicro<float64_t>;
;


// VectorFloatCvtFormat::vfcvt_f_x_v(['\n                            auto fd = i_to_f<et>(Vs2_vu[i]);\n                            Vd_vu[i] = fd.v;\n                        ', 'OPFVV', 'SimdFloatCvtOp'],{})


template <typename ElemType>
Fault
Vfcvt_f_x_vMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(1);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                            auto fd = i_to_f<et>(Vs2[i]);
                            Vd[i] = fd.v;
                        }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vfcvt_f_x_vMicro<float16_t>;
template class Vfcvt_f_x_vMicro<float32_t>;
template class Vfcvt_f_x_vMicro<float64_t>;
;


// VectorFloatCvtFormat::vfcvt_rtz_xu_f_v(['\n                            Vd_vu[i] = f_to_ui<et>(ftype<et>(Vs2_vu[i]),\n                                                   softfloat_round_minMag);\n                        ', 'OPFVV', 'SimdFloatCvtOp'],{})


template <typename ElemType>
Fault
Vfcvt_rtz_xu_f_vMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(1);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                            Vd[i] = f_to_ui<et>(ftype<et>(Vs2[i]),
                                                   softfloat_round_minMag);
                        }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vfcvt_rtz_xu_f_vMicro<float16_t>;
template class Vfcvt_rtz_xu_f_vMicro<float32_t>;
template class Vfcvt_rtz_xu_f_vMicro<float64_t>;
;


// VectorFloatCvtFormat::vfcvt_rtz_x_f_v(['\n                            Vd_vu[i] = f_to_i<et>(ftype<et>(Vs2_vu[i]),\n                                                  softfloat_round_minMag);\n                        ', 'OPFVV', 'SimdFloatCvtOp'],{})


template <typename ElemType>
Fault
Vfcvt_rtz_x_f_vMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(1);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                            Vd[i] = f_to_i<et>(ftype<et>(Vs2[i]),
                                                  softfloat_round_minMag);
                        }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vfcvt_rtz_x_f_vMicro<float16_t>;
template class Vfcvt_rtz_x_f_vMicro<float32_t>;
template class Vfcvt_rtz_x_f_vMicro<float64_t>;
;


// VectorFloatWideningCvtFormat::vfwcvt_xu_f_v(['\n                            Vd_vwu[i] = f_to_wui<et>(\n                                ftype<et>(Vs2_vu[i + offset]),\n                                softfloat_roundingMode);\n                        ', 'OPFVV', 'SimdFloatCvtOp'],{})


template <typename ElemType>
Fault
Vfwcvt_xu_f_vMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu [[maybe_unused]] = decltype(et::v);
    using ewt = typename double_width<et>::type;
    using vwu = decltype(ewt::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(1);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                            Vd[i] = f_to_wui<et>(
                                ftype<et>(Vs2[i + offset]),
                                softfloat_roundingMode);
                        }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vfwcvt_xu_f_vMicro<float8_t>;
template class Vfwcvt_xu_f_vMicro<float16_t>;
template class Vfwcvt_xu_f_vMicro<float32_t>;
;


// VectorFloatWideningCvtFormat::vfwcvt_x_f_v(['\n                            Vd_vwu[i] = f_to_wi<et>(\n                                ftype<et>(Vs2_vu[i + offset]),\n                                softfloat_roundingMode);\n                        ', 'OPFVV', 'SimdFloatCvtOp'],{})


template <typename ElemType>
Fault
Vfwcvt_x_f_vMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu [[maybe_unused]] = decltype(et::v);
    using ewt = typename double_width<et>::type;
    using vwu = decltype(ewt::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(1);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                            Vd[i] = f_to_wi<et>(
                                ftype<et>(Vs2[i + offset]),
                                softfloat_roundingMode);
                        }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vfwcvt_x_f_vMicro<float8_t>;
template class Vfwcvt_x_f_vMicro<float16_t>;
template class Vfwcvt_x_f_vMicro<float32_t>;
;


// VectorFloatWideningCvtFormat::vfwcvt_f_xu_v(['\n                            auto fd = ui_to_wf<vu>(Vs2_vu[i + offset]);\n                            Vd_vwu[i] = fd.v;\n                        ', 'OPFVV', 'SimdFloatCvtOp'],{})


template <typename ElemType>
Fault
Vfwcvt_f_xu_vMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu [[maybe_unused]] = decltype(et::v);
    using ewt = typename double_width<et>::type;
    using vwu = decltype(ewt::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(1);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                            auto fd = ui_to_wf<vu>(Vs2[i + offset]);
                            Vd[i] = fd.v;
                        }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vfwcvt_f_xu_vMicro<float8_t>;
template class Vfwcvt_f_xu_vMicro<float16_t>;
template class Vfwcvt_f_xu_vMicro<float32_t>;
;


// VectorFloatWideningCvtFormat::vfwcvt_f_x_v(['\n                            auto fd = i_to_wf<vu>(Vs2_vu[i + offset]);\n                            Vd_vwu[i] = fd.v;\n                        ', 'OPFVV', 'SimdFloatCvtOp'],{})


template <typename ElemType>
Fault
Vfwcvt_f_x_vMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu [[maybe_unused]] = decltype(et::v);
    using ewt = typename double_width<et>::type;
    using vwu = decltype(ewt::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(1);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                            auto fd = i_to_wf<vu>(Vs2[i + offset]);
                            Vd[i] = fd.v;
                        }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vfwcvt_f_x_vMicro<float8_t>;
template class Vfwcvt_f_x_vMicro<float16_t>;
template class Vfwcvt_f_x_vMicro<float32_t>;
;


// VectorFloatWideningCvtFormat::vfwcvt_f_f_v(['\n                            auto fd = f_to_wf<et>(\n                                ftype<et>(Vs2_vu[i + offset]));\n                            Vd_vwu[i] = fd.v;\n                        ', 'OPFVV', 'SimdFloatCvtOp'],{})


template <typename ElemType>
Fault
Vfwcvt_f_f_vMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu [[maybe_unused]] = decltype(et::v);
    using ewt = typename double_width<et>::type;
    using vwu = decltype(ewt::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(1);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                            auto fd = f_to_wf<et>(
                                ftype<et>(Vs2[i + offset]));
                            Vd[i] = fd.v;
                        }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vfwcvt_f_f_vMicro<float8_t>;
template class Vfwcvt_f_f_vMicro<float16_t>;
template class Vfwcvt_f_f_vMicro<float32_t>;
;


// VectorFloatWideningCvtFormat::vfwcvt_rtz_xu_f_v(['\n                            Vd_vwu[i] = f_to_wui<et>(\n                                ftype<et>(Vs2_vu[i + offset]),\n                                softfloat_round_minMag);\n                        ', 'OPFVV', 'SimdFloatCvtOp'],{})


template <typename ElemType>
Fault
Vfwcvt_rtz_xu_f_vMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu [[maybe_unused]] = decltype(et::v);
    using ewt = typename double_width<et>::type;
    using vwu = decltype(ewt::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(1);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                            Vd[i] = f_to_wui<et>(
                                ftype<et>(Vs2[i + offset]),
                                softfloat_round_minMag);
                        }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vfwcvt_rtz_xu_f_vMicro<float8_t>;
template class Vfwcvt_rtz_xu_f_vMicro<float16_t>;
template class Vfwcvt_rtz_xu_f_vMicro<float32_t>;
;


// VectorFloatWideningCvtFormat::vfwcvt_rtz_x_f_v(['\n                            Vd_vwu[i] = f_to_wi<et>(\n                                ftype<et>(Vs2_vu[i + offset]),\n                                softfloat_round_minMag);\n                        ', 'OPFVV', 'SimdFloatCvtOp'],{})


template <typename ElemType>
Fault
Vfwcvt_rtz_x_f_vMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu [[maybe_unused]] = decltype(et::v);
    using ewt = typename double_width<et>::type;
    using vwu = decltype(ewt::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(1);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                            Vd[i] = f_to_wi<et>(
                                ftype<et>(Vs2[i + offset]),
                                softfloat_round_minMag);
                        }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vfwcvt_rtz_x_f_vMicro<float8_t>;
template class Vfwcvt_rtz_x_f_vMicro<float16_t>;
template class Vfwcvt_rtz_x_f_vMicro<float32_t>;
;


// VectorFloatNarrowingCvtFormat::vfncvt_xu_f_w(['\n                            Vd_vu[i + offset] = f_to_nui<vu>(\n                                ftype<ewt>(Vs2_vwu[i]),\n                                softfloat_roundingMode);\n                        ', 'OPFVV', 'SimdFloatCvtOp'],{})


template <typename ElemType>
Fault
Vfncvt_xu_f_wMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu [[maybe_unused]] = decltype(et::v);
    using ewt = typename double_width<et>::type;
    using vwu = decltype(ewt::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vwu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(1);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vs2 % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned VS2 group in Narrowing op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
        
            if ((VS2 < VD) &&
                (VD <= (VS2 + num_microops - 1))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is smaller than
                // the source EEW and the overlap is in the lowest-numbered
                // part of the source register group
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Narrowing op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                            Vd[i + offset] = f_to_nui<vu>(
                                ftype<ewt>(Vs2[i]),
                                softfloat_roundingMode);
                        }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vfncvt_xu_f_wMicro<float8_t>;
template class Vfncvt_xu_f_wMicro<float16_t>;
template class Vfncvt_xu_f_wMicro<float32_t>;
;


// VectorFloatNarrowingCvtFormat::vfncvt_x_f_w(['\n                            Vd_vu[i + offset] = f_to_ni<vu>(\n                                ftype<ewt>(Vs2_vwu[i]),\n                                softfloat_roundingMode);\n                        ', 'OPFVV', 'SimdFloatCvtOp'],{})


template <typename ElemType>
Fault
Vfncvt_x_f_wMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu [[maybe_unused]] = decltype(et::v);
    using ewt = typename double_width<et>::type;
    using vwu = decltype(ewt::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vwu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(1);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vs2 % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned VS2 group in Narrowing op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
        
            if ((VS2 < VD) &&
                (VD <= (VS2 + num_microops - 1))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is smaller than
                // the source EEW and the overlap is in the lowest-numbered
                // part of the source register group
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Narrowing op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                            Vd[i + offset] = f_to_ni<vu>(
                                ftype<ewt>(Vs2[i]),
                                softfloat_roundingMode);
                        }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vfncvt_x_f_wMicro<float8_t>;
template class Vfncvt_x_f_wMicro<float16_t>;
template class Vfncvt_x_f_wMicro<float32_t>;
;


// VectorFloatNarrowingCvtFormat::vfncvt_f_xu_w(['\n                            auto fd = ui_to_nf<et>(Vs2_vwu[i]);\n                            Vd_vu[i + offset] = fd.v;\n                        ', 'OPFVV', 'SimdFloatCvtOp'],{})


template <typename ElemType>
Fault
Vfncvt_f_xu_wMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu [[maybe_unused]] = decltype(et::v);
    using ewt = typename double_width<et>::type;
    using vwu = decltype(ewt::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vwu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(1);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vs2 % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned VS2 group in Narrowing op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
        
            if ((VS2 < VD) &&
                (VD <= (VS2 + num_microops - 1))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is smaller than
                // the source EEW and the overlap is in the lowest-numbered
                // part of the source register group
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Narrowing op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                            auto fd = ui_to_nf<et>(Vs2[i]);
                            Vd[i + offset] = fd.v;
                        }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vfncvt_f_xu_wMicro<float8_t>;
template class Vfncvt_f_xu_wMicro<float16_t>;
template class Vfncvt_f_xu_wMicro<float32_t>;
;


// VectorFloatNarrowingCvtFormat::vfncvt_f_x_w(['\n                            auto fd = i_to_nf<et>(Vs2_vwu[i]);\n                            Vd_vu[i + offset] = fd.v;\n                        ', 'OPFVV', 'SimdFloatCvtOp'],{})


template <typename ElemType>
Fault
Vfncvt_f_x_wMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu [[maybe_unused]] = decltype(et::v);
    using ewt = typename double_width<et>::type;
    using vwu = decltype(ewt::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vwu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(1);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vs2 % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned VS2 group in Narrowing op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
        
            if ((VS2 < VD) &&
                (VD <= (VS2 + num_microops - 1))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is smaller than
                // the source EEW and the overlap is in the lowest-numbered
                // part of the source register group
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Narrowing op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                            auto fd = i_to_nf<et>(Vs2[i]);
                            Vd[i + offset] = fd.v;
                        }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vfncvt_f_x_wMicro<float8_t>;
template class Vfncvt_f_x_wMicro<float16_t>;
template class Vfncvt_f_x_wMicro<float32_t>;
;


// VectorFloatNarrowingCvtFormat::vfncvt_f_f_w(['\n                            auto fd = f_to_nf<et>(ftype<ewt>(Vs2_vwu[i]));\n                            Vd_vu[i + offset] = fd.v;\n                        ', 'OPFVV', 'SimdFloatCvtOp'],{})


template <typename ElemType>
Fault
Vfncvt_f_f_wMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu [[maybe_unused]] = decltype(et::v);
    using ewt = typename double_width<et>::type;
    using vwu = decltype(ewt::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vwu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(1);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vs2 % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned VS2 group in Narrowing op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
        
            if ((VS2 < VD) &&
                (VD <= (VS2 + num_microops - 1))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is smaller than
                // the source EEW and the overlap is in the lowest-numbered
                // part of the source register group
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Narrowing op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                            auto fd = f_to_nf<et>(ftype<ewt>(Vs2[i]));
                            Vd[i + offset] = fd.v;
                        }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vfncvt_f_f_wMicro<float8_t>;
template class Vfncvt_f_f_wMicro<float16_t>;
template class Vfncvt_f_f_wMicro<float32_t>;
;


// VectorFloatNarrowingCvtFormat::vfncvt_rod_f_f_w(['\n                            softfloat_roundingMode = softfloat_round_odd;\n                            auto fd = f_to_nf<et>(ftype<ewt>(Vs2_vwu[i]));\n                            Vd_vu[i + offset] = fd.v;\n                        ', 'OPFVV', 'SimdFloatCvtOp'],{})


template <typename ElemType>
Fault
Vfncvt_rod_f_f_wMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu [[maybe_unused]] = decltype(et::v);
    using ewt = typename double_width<et>::type;
    using vwu = decltype(ewt::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vwu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(1);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vs2 % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned VS2 group in Narrowing op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
        
            if ((VS2 < VD) &&
                (VD <= (VS2 + num_microops - 1))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is smaller than
                // the source EEW and the overlap is in the lowest-numbered
                // part of the source register group
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Narrowing op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                            softfloat_roundingMode = softfloat_round_odd;
                            auto fd = f_to_nf<et>(ftype<ewt>(Vs2[i]));
                            Vd[i + offset] = fd.v;
                        }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vfncvt_rod_f_f_wMicro<float8_t>;
template class Vfncvt_rod_f_f_wMicro<float16_t>;
template class Vfncvt_rod_f_f_wMicro<float32_t>;
;


// VectorFloatNarrowingCvtFormat::vfncvt_rtz_xu_f_w(['\n                            Vd_vu[i + offset] = f_to_nui<vu>(\n                                ftype<ewt>(Vs2_vwu[i]),\n                                softfloat_round_minMag);\n                        ', 'OPFVV', 'SimdFloatCvtOp'],{})


template <typename ElemType>
Fault
Vfncvt_rtz_xu_f_wMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu [[maybe_unused]] = decltype(et::v);
    using ewt = typename double_width<et>::type;
    using vwu = decltype(ewt::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vwu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(1);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vs2 % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned VS2 group in Narrowing op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
        
            if ((VS2 < VD) &&
                (VD <= (VS2 + num_microops - 1))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is smaller than
                // the source EEW and the overlap is in the lowest-numbered
                // part of the source register group
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Narrowing op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                            Vd[i + offset] = f_to_nui<vu>(
                                ftype<ewt>(Vs2[i]),
                                softfloat_round_minMag);
                        }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vfncvt_rtz_xu_f_wMicro<float8_t>;
template class Vfncvt_rtz_xu_f_wMicro<float16_t>;
template class Vfncvt_rtz_xu_f_wMicro<float32_t>;
;


// VectorFloatNarrowingCvtFormat::vfncvt_rtz_x_f_w(['\n                            Vd_vu[i + offset] = f_to_ni<vu>(\n                                ftype<ewt>(Vs2_vwu[i]),\n                                softfloat_round_minMag);\n                        ', 'OPFVV', 'SimdFloatCvtOp'],{})


template <typename ElemType>
Fault
Vfncvt_rtz_x_f_wMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu [[maybe_unused]] = decltype(et::v);
    using ewt = typename double_width<et>::type;
    using vwu = decltype(ewt::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vwu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(1);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vs2 % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned VS2 group in Narrowing op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
        
            if ((VS2 < VD) &&
                (VD <= (VS2 + num_microops - 1))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is smaller than
                // the source EEW and the overlap is in the lowest-numbered
                // part of the source register group
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Narrowing op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                            Vd[i + offset] = f_to_ni<vu>(
                                ftype<ewt>(Vs2[i]),
                                softfloat_round_minMag);
                        }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vfncvt_rtz_x_f_wMicro<float8_t>;
template class Vfncvt_rtz_x_f_wMicro<float16_t>;
template class Vfncvt_rtz_x_f_wMicro<float32_t>;
;


// Unknown::unknown(([], {}))

// VectorFloatCvtFormat::vfsqrt_v(['\n                            auto fd = fsqrt<et>(ftype<et>(Vs2_vu[i]));\n                            Vd_vu[i] = fd.v;\n                        ', 'OPFVV', 'SimdFloatSqrtOp'],{})


template <typename ElemType>
Fault
Vfsqrt_vMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(1);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                            auto fd = fsqrt<et>(ftype<et>(Vs2[i]));
                            Vd[i] = fd.v;
                        }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vfsqrt_vMicro<float16_t>;
template class Vfsqrt_vMicro<float32_t>;
template class Vfsqrt_vMicro<float64_t>;
;


// VectorFloatCvtFormat::vfrsqrt7_v(['\n                            auto fd = frsqrte7<et>(ftype<et>(Vs2_vu[i]));\n                            Vd_vu[i] = fd.v;\n                        ', 'OPFVV', 'SimdFloatSqrtOp'],{})


template <typename ElemType>
Fault
Vfrsqrt7_vMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(1);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                            auto fd = frsqrte7<et>(ftype<et>(Vs2[i]));
                            Vd[i] = fd.v;
                        }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vfrsqrt7_vMicro<float16_t>;
template class Vfrsqrt7_vMicro<float32_t>;
template class Vfrsqrt7_vMicro<float64_t>;
;


// VectorFloatCvtFormat::vfrec7_v(['\n                            auto fd = frecip7<et>(ftype<et>(Vs2_vu[i]));\n                            Vd_vu[i] = fd.v;\n                        ', 'OPFVV', 'SimdFloatDivOp'],{})


template <typename ElemType>
Fault
Vfrec7_vMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(1);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                            auto fd = frecip7<et>(ftype<et>(Vs2[i]));
                            Vd[i] = fd.v;
                        }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vfrec7_vMicro<float16_t>;
template class Vfrec7_vMicro<float32_t>;
template class Vfrec7_vMicro<float64_t>;
;


// VectorFloatCvtFormat::vfclass_v(['\n                            auto fd = fclassify<et>(ftype<et>(Vs2_vu[i]));\n                            Vd_vu[i] = fd.v;\n                        ', 'OPFVV', 'SimdMiscOp'],{})


template <typename ElemType>
Fault
Vfclass_vMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(1);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                            auto fd = fclassify<et>(ftype<et>(Vs2[i]));
                            Vd[i] = fd.v;
                        }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vfclass_vMicro<float16_t>;
template class Vfclass_vMicro<float32_t>;
template class Vfclass_vMicro<float64_t>;
;


// Unknown::unknown(([], {}))

// VectorFloatMaskFormat::vmfeq_vv(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            feq<et>(ftype<et>(Vs2_vu[i]),\n                                    ftype<et>(Vs1_vu[i])));\n                    ', 'OPFVV', 'SimdFloatCmpOp'],{})


template <typename ElemType>
Fault
Vmfeq_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;

    const uint32_t bit_offset = vlenb / sizeof(ElemType);
    const uint32_t offset = bit_offset * microIdx;

    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,
                            feq<et>(ftype<et>(Vs2[i]),
                                    ftype<et>(Vs1[i])));
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vmfeq_vvMicro<float16_t>;
template class Vmfeq_vvMicro<float32_t>;
template class Vmfeq_vvMicro<float64_t>;
;


// VectorFloatMaskFormat::vmfle_vv(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            fle<et>(ftype<et>(Vs2_vu[i]),\n                                    ftype<et>(Vs1_vu[i])));\n                    ', 'OPFVV', 'SimdFloatCmpOp'],{})


template <typename ElemType>
Fault
Vmfle_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;

    const uint32_t bit_offset = vlenb / sizeof(ElemType);
    const uint32_t offset = bit_offset * microIdx;

    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,
                            fle<et>(ftype<et>(Vs2[i]),
                                    ftype<et>(Vs1[i])));
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vmfle_vvMicro<float16_t>;
template class Vmfle_vvMicro<float32_t>;
template class Vmfle_vvMicro<float64_t>;
;


// VectorFloatMaskFormat::vmflt_vv(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            flt<et>(ftype<et>(Vs2_vu[i]),\n                                    ftype<et>(Vs1_vu[i])));\n                    ', 'OPFVV', 'SimdFloatCmpOp'],{})


template <typename ElemType>
Fault
Vmflt_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;

    const uint32_t bit_offset = vlenb / sizeof(ElemType);
    const uint32_t offset = bit_offset * microIdx;

    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,
                            flt<et>(ftype<et>(Vs2[i]),
                                    ftype<et>(Vs1[i])));
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vmflt_vvMicro<float16_t>;
template class Vmflt_vvMicro<float32_t>;
template class Vmflt_vvMicro<float64_t>;
;


// VectorFloatMaskFormat::vmfne_vv(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            !feq<et>(ftype<et>(Vs2_vu[i]),\n                                    ftype<et>(Vs1_vu[i])));\n                    ', 'OPFVV', 'SimdFloatCmpOp'],{})


template <typename ElemType>
Fault
Vmfne_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;

    const uint32_t bit_offset = vlenb / sizeof(ElemType);
    const uint32_t offset = bit_offset * microIdx;

    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,
                            !feq<et>(ftype<et>(Vs2[i]),
                                    ftype<et>(Vs1[i])));
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vmfne_vvMicro<float16_t>;
template class Vmfne_vvMicro<float32_t>;
template class Vmfne_vvMicro<float64_t>;
;


// VectorFloatFormat::vfdiv_vv(['\n                        auto fd = fdiv<et>(ftype<et>(Vs2_vu[i]),\n                                           ftype<et>(Vs1_vu[i]));\n                        Vd_vu[i] = fd.v;\n                    ', 'OPFVV', 'SimdFloatDivOp'],{})


template <typename ElemType>
Fault
Vfdiv_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        auto fd = fdiv<et>(ftype<et>(Vs2[i]),
                                           ftype<et>(Vs1[i]));
                        Vd[i] = fd.v;
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vfdiv_vvMicro<float16_t>;
template class Vfdiv_vvMicro<float32_t>;
template class Vfdiv_vvMicro<float64_t>;
;


// VectorFloatFormat::vfmul_vv(['\n                        auto fd = fmul<et>(ftype<et>(Vs2_vu[i]),\n                                           ftype<et>(Vs1_vu[i]));\n                        Vd_vu[i] = fd.v;\n                    ', 'OPFVV', 'SimdFloatMultOp'],{})


template <typename ElemType>
Fault
Vfmul_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        auto fd = fmul<et>(ftype<et>(Vs2[i]),
                                           ftype<et>(Vs1[i]));
                        Vd[i] = fd.v;
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vfmul_vvMicro<float16_t>;
template class Vfmul_vvMicro<float32_t>;
template class Vfmul_vvMicro<float64_t>;
;


// VectorFloatFormat::vfmadd_vv(['\n                        auto fd = fmadd<et>(ftype<et>(Vs3_vu[i]),\n                                            ftype<et>(Vs1_vu[i]),\n                                            ftype<et>(Vs2_vu[i]));\n                        Vd_vu[i] = fd.v;\n                    ', 'OPFVV', 'SimdFloatMultAccOp'],{})


template <typename ElemType>
Fault
Vfmadd_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        auto fd = fmadd<et>(ftype<et>(Vs3[i]),
                                            ftype<et>(Vs1[i]),
                                            ftype<et>(Vs2[i]));
                        Vd[i] = fd.v;
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vfmadd_vvMicro<float16_t>;
template class Vfmadd_vvMicro<float32_t>;
template class Vfmadd_vvMicro<float64_t>;
;


// VectorFloatFormat::vfnmadd_vv(['\n                        auto fd = fmadd<et>(fneg(ftype<et>(Vs3_vu[i])),\n                                            ftype<et>(Vs1_vu[i]),\n                                            fneg(ftype<et>(Vs2_vu[i])));\n                        Vd_vu[i] = fd.v;\n                    ', 'OPFVV', 'SimdFloatMultAccOp'],{})


template <typename ElemType>
Fault
Vfnmadd_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        auto fd = fmadd<et>(fneg(ftype<et>(Vs3[i])),
                                            ftype<et>(Vs1[i]),
                                            fneg(ftype<et>(Vs2[i])));
                        Vd[i] = fd.v;
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vfnmadd_vvMicro<float16_t>;
template class Vfnmadd_vvMicro<float32_t>;
template class Vfnmadd_vvMicro<float64_t>;
;


// VectorFloatFormat::vfmsub_vv(['\n                        auto fd = fmadd<et>(ftype<et>(Vs3_vu[i]),\n                                            ftype<et>(Vs1_vu[i]),\n                                            fneg(ftype<et>(Vs2_vu[i])));\n                        Vd_vu[i] = fd.v;\n                    ', 'OPFVV', 'SimdFloatMultAccOp'],{})


template <typename ElemType>
Fault
Vfmsub_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        auto fd = fmadd<et>(ftype<et>(Vs3[i]),
                                            ftype<et>(Vs1[i]),
                                            fneg(ftype<et>(Vs2[i])));
                        Vd[i] = fd.v;
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vfmsub_vvMicro<float16_t>;
template class Vfmsub_vvMicro<float32_t>;
template class Vfmsub_vvMicro<float64_t>;
;


// VectorFloatFormat::vfnmsub_vv(['\n                        auto fd = fmadd<et>(fneg(ftype<et>(Vs3_vu[i])),\n                                            ftype<et>(Vs1_vu[i]),\n                                            ftype<et>(Vs2_vu[i]));\n                        Vd_vu[i] = fd.v;\n                    ', 'OPFVV', 'SimdFloatMultAccOp'],{})


template <typename ElemType>
Fault
Vfnmsub_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        auto fd = fmadd<et>(fneg(ftype<et>(Vs3[i])),
                                            ftype<et>(Vs1[i]),
                                            ftype<et>(Vs2[i]));
                        Vd[i] = fd.v;
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vfnmsub_vvMicro<float16_t>;
template class Vfnmsub_vvMicro<float32_t>;
template class Vfnmsub_vvMicro<float64_t>;
;


// VectorFloatFormat::vfmacc_vv(['\n                        auto fd = fmadd<et>(ftype<et>(Vs1_vu[i]),\n                                            ftype<et>(Vs2_vu[i]),\n                                            ftype<et>(Vs3_vu[i]));\n                        Vd_vu[i] = fd.v;\n                    ', 'OPFVV', 'SimdFloatMultAccOp'],{})


template <typename ElemType>
Fault
Vfmacc_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        auto fd = fmadd<et>(ftype<et>(Vs1[i]),
                                            ftype<et>(Vs2[i]),
                                            ftype<et>(Vs3[i]));
                        Vd[i] = fd.v;
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vfmacc_vvMicro<float16_t>;
template class Vfmacc_vvMicro<float32_t>;
template class Vfmacc_vvMicro<float64_t>;
;


// VectorFloatFormat::vfnmacc_vv(['\n                        auto fd = fmadd<et>(fneg(ftype<et>(Vs1_vu[i])),\n                                            ftype<et>(Vs2_vu[i]),\n                                            fneg(ftype<et>(Vs3_vu[i])));\n                        Vd_vu[i] = fd.v;\n                    ', 'OPFVV', 'SimdFloatMultAccOp'],{})


template <typename ElemType>
Fault
Vfnmacc_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        auto fd = fmadd<et>(fneg(ftype<et>(Vs1[i])),
                                            ftype<et>(Vs2[i]),
                                            fneg(ftype<et>(Vs3[i])));
                        Vd[i] = fd.v;
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vfnmacc_vvMicro<float16_t>;
template class Vfnmacc_vvMicro<float32_t>;
template class Vfnmacc_vvMicro<float64_t>;
;


// VectorFloatFormat::vfmsac_vv(['\n                        auto fd = fmadd<et>(ftype<et>(Vs1_vu[i]),\n                                            ftype<et>(Vs2_vu[i]),\n                                            fneg(ftype<et>(Vs3_vu[i])));\n                        Vd_vu[i] = fd.v;\n                    ', 'OPFVV', 'SimdFloatMultAccOp'],{})


template <typename ElemType>
Fault
Vfmsac_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        auto fd = fmadd<et>(ftype<et>(Vs1[i]),
                                            ftype<et>(Vs2[i]),
                                            fneg(ftype<et>(Vs3[i])));
                        Vd[i] = fd.v;
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vfmsac_vvMicro<float16_t>;
template class Vfmsac_vvMicro<float32_t>;
template class Vfmsac_vvMicro<float64_t>;
;


// VectorFloatFormat::vfnmsac_vv(['\n                        auto fd = fmadd<et>(fneg(ftype<et>(Vs1_vu[i])),\n                                            ftype<et>(Vs2_vu[i]),\n                                            ftype<et>(Vs3_vu[i]));\n                        Vd_vu[i] = fd.v;\n                    ', 'OPFVV', 'SimdFloatMultAccOp'],{})


template <typename ElemType>
Fault
Vfnmsac_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        auto fd = fmadd<et>(fneg(ftype<et>(Vs1[i])),
                                            ftype<et>(Vs2[i]),
                                            ftype<et>(Vs3[i]));
                        Vd[i] = fd.v;
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vfnmsac_vvMicro<float16_t>;
template class Vfnmsac_vvMicro<float32_t>;
template class Vfnmsac_vvMicro<float64_t>;
;


// VectorReduceFloatWideningFormat::vfwredusum_vs((['\n                        Vd_vwu[0] = reduce_loop(\n                            [](const vwu& src1, const vu& src2) {\n                                return fadd<ewt>(\n                                    ftype<ewt>(src1),\n                                    f_to_wf<et>(ftype<et>(src2))\n                                );\n                            }, Vs1_vwu, Vs2_vu);\n                    ', 'OPFVV', 'SimdFloatReduceAddOp'], {}))


template <typename ElemType>
Fault
Vfwredusum_vsMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    
        using et = ElemType;
        using vu [[maybe_unused]] = decltype(et::v);
        using ewt = typename double_width<et>::type;
        using vwu = decltype(ewt::v);
    ;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vwu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;

    auto reduce_loop =
        [&, this](const auto& f, const auto* _, const auto* vs2) {
            vwu tmp_val = Vs1[0];
            for (uint32_t i = 0; i < this->microVl; i++) {
                uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) *
                    this->microIdx;
                if (this->vm || elem_mask(v0, ei)) {
                    tmp_val = f(tmp_val, Vs2[i]).v;
                }
            }
            return tmp_val;
        };

    
                        Vd[0] = reduce_loop(
                            [](const vwu& src1, const vu& src2) {
                                return fadd<ewt>(
                                    ftype<ewt>(src1),
                                    f_to_wf<et>(ftype<et>(src2))
                                );
                            }, Vs1, Vs2);
                    ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vfwredusum_vsMicro<float16_t>;
template class Vfwredusum_vsMicro<float32_t>;
;


// VectorReduceFloatWideningFormat::vfwredosum_vs((['\n                        Vd_vwu[0] = reduce_loop(\n                            [](const vwu& src1, const vu& src2) {\n                                return fadd<ewt>(\n                                    ftype<ewt>(src1),\n                                    f_to_wf<et>(ftype<et>(src2))\n                                );\n                            }, Vs1_vwu, Vs2_vu);\n                    ', 'OPFVV', 'SimdFloatReduceAddOp'], {}))


template <typename ElemType>
Fault
Vfwredosum_vsMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    
        using et = ElemType;
        using vu [[maybe_unused]] = decltype(et::v);
        using ewt = typename double_width<et>::type;
        using vwu = decltype(ewt::v);
    ;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vwu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;

    auto reduce_loop =
        [&, this](const auto& f, const auto* _, const auto* vs2) {
            vwu tmp_val = Vs1[0];
            for (uint32_t i = 0; i < this->microVl; i++) {
                uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) *
                    this->microIdx;
                if (this->vm || elem_mask(v0, ei)) {
                    tmp_val = f(tmp_val, Vs2[i]).v;
                }
            }
            return tmp_val;
        };

    
                        Vd[0] = reduce_loop(
                            [](const vwu& src1, const vu& src2) {
                                return fadd<ewt>(
                                    ftype<ewt>(src1),
                                    f_to_wf<et>(ftype<et>(src2))
                                );
                            }, Vs1, Vs2);
                    ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vfwredosum_vsMicro<float16_t>;
template class Vfwredosum_vsMicro<float32_t>;
;


// VectorFloatWideningFormat::vfwadd_vv(['\n                        auto fd = fadd<ewt>(\n                            fwiden(ftype<et>(Vs2_vu[i + offset])),\n                            fwiden(ftype<et>(Vs1_vu[i + offset])));\n                        Vd_vwu[i] = fd.v;\n                    ', 'OPFVV', 'SimdFloatAddOp'],{})


template <typename ElemType>
Fault
Vfwadd_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu [[maybe_unused]] = decltype(et::v);
    using ewt = typename double_width<et>::type;
    using vwu = decltype(ewt::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vd % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned Vd group in Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            const int64_t vs2_emul = vlmul + 0;
            if (((vs2_emul < 0) && (VS2 == VD)) ||
                ((vs2_emul >= 0) &&
                 (VS2 < VD + num_microops - (1 << vs2_emul)) &&
                 (VD < VS2 + (1 << vs2_emul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            if (((vlmul < 0) && (VS1 == VD)) ||
                ((vlmul >= 0) &&
                 (VS1 < VD + num_microops - (1 << vlmul)) &&
                 (VD < VS1 + (1 << vlmul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS1 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        auto fd = fadd<ewt>(
                            fwiden(ftype<et>(Vs2[i + offset])),
                            fwiden(ftype<et>(Vs1[i + offset])));
                        Vd[i] = fd.v;
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vfwadd_vvMicro<float16_t>;
template class Vfwadd_vvMicro<float32_t>;
;


// VectorFloatWideningFormat::vfwsub_vv(['\n                        auto fd = fsub<ewt>(\n                            fwiden(ftype<et>(Vs2_vu[i + offset])),\n                            fwiden(ftype<et>(Vs1_vu[i + offset])));\n                        Vd_vwu[i] = fd.v;\n                    ', 'OPFVV', 'SimdFloatAddOp'],{})


template <typename ElemType>
Fault
Vfwsub_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu [[maybe_unused]] = decltype(et::v);
    using ewt = typename double_width<et>::type;
    using vwu = decltype(ewt::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vd % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned Vd group in Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            const int64_t vs2_emul = vlmul + 0;
            if (((vs2_emul < 0) && (VS2 == VD)) ||
                ((vs2_emul >= 0) &&
                 (VS2 < VD + num_microops - (1 << vs2_emul)) &&
                 (VD < VS2 + (1 << vs2_emul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            if (((vlmul < 0) && (VS1 == VD)) ||
                ((vlmul >= 0) &&
                 (VS1 < VD + num_microops - (1 << vlmul)) &&
                 (VD < VS1 + (1 << vlmul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS1 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        auto fd = fsub<ewt>(
                            fwiden(ftype<et>(Vs2[i + offset])),
                            fwiden(ftype<et>(Vs1[i + offset])));
                        Vd[i] = fd.v;
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vfwsub_vvMicro<float16_t>;
template class Vfwsub_vvMicro<float32_t>;
;


// VectorFloatWideningFormat::vfwadd_wv(['\n                        auto fd = fadd<ewt>(\n                            ftype<ewt>(Vs2_vwu[i]),\n                            fwiden(ftype<et>(Vs1_vu[i + offset])));\n                        Vd_vwu[i] = fd.v;\n                    ', 'OPFVV', 'SimdFloatAddOp'],{})


template <typename ElemType>
Fault
Vfwadd_wvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu [[maybe_unused]] = decltype(et::v);
    using ewt = typename double_width<et>::type;
    using vwu = decltype(ewt::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vwu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vd % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned Vd group in Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            if (((vlmul < 0) && (VS1 == VD)) ||
                ((vlmul >= 0) &&
                 (VS1 < VD + num_microops - (1 << vlmul)) &&
                 (VD < VS1 + (1 << vlmul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS1 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        auto fd = fadd<ewt>(
                            ftype<ewt>(Vs2[i]),
                            fwiden(ftype<et>(Vs1[i + offset])));
                        Vd[i] = fd.v;
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vfwadd_wvMicro<float16_t>;
template class Vfwadd_wvMicro<float32_t>;
;


// VectorFloatWideningFormat::vfwsub_wv(['\n                        auto fd = fsub<ewt>(\n                            ftype<ewt>(Vs2_vwu[i]),\n                            fwiden(ftype<et>(Vs1_vu[i + offset])));\n                        Vd_vwu[i] = fd.v;\n                    ', 'OPFVV', 'SimdFloatAddOp'],{})


template <typename ElemType>
Fault
Vfwsub_wvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu [[maybe_unused]] = decltype(et::v);
    using ewt = typename double_width<et>::type;
    using vwu = decltype(ewt::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vwu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vd % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned Vd group in Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            if (((vlmul < 0) && (VS1 == VD)) ||
                ((vlmul >= 0) &&
                 (VS1 < VD + num_microops - (1 << vlmul)) &&
                 (VD < VS1 + (1 << vlmul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS1 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        auto fd = fsub<ewt>(
                            ftype<ewt>(Vs2[i]),
                            fwiden(ftype<et>(Vs1[i + offset])));
                        Vd[i] = fd.v;
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vfwsub_wvMicro<float16_t>;
template class Vfwsub_wvMicro<float32_t>;
;


// VectorFloatWideningFormat::vfwmul_vv(['\n                        auto fd = fmul<ewt>(\n                            fwiden(ftype<et>(Vs2_vu[i + offset])),\n                            fwiden(ftype<et>(Vs1_vu[i + offset])));\n                        Vd_vwu[i] = fd.v;\n                    ', 'OPFVV', 'SimdFloatMultOp'],{})


template <typename ElemType>
Fault
Vfwmul_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu [[maybe_unused]] = decltype(et::v);
    using ewt = typename double_width<et>::type;
    using vwu = decltype(ewt::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vd % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned Vd group in Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            const int64_t vs2_emul = vlmul + 0;
            if (((vs2_emul < 0) && (VS2 == VD)) ||
                ((vs2_emul >= 0) &&
                 (VS2 < VD + num_microops - (1 << vs2_emul)) &&
                 (VD < VS2 + (1 << vs2_emul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            if (((vlmul < 0) && (VS1 == VD)) ||
                ((vlmul >= 0) &&
                 (VS1 < VD + num_microops - (1 << vlmul)) &&
                 (VD < VS1 + (1 << vlmul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS1 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        auto fd = fmul<ewt>(
                            fwiden(ftype<et>(Vs2[i + offset])),
                            fwiden(ftype<et>(Vs1[i + offset])));
                        Vd[i] = fd.v;
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vfwmul_vvMicro<float16_t>;
template class Vfwmul_vvMicro<float32_t>;
;


// VectorFloatWideningFormat::vfwmacc_vv(['\n                        auto fd = fmadd<ewt>(\n                            fwiden(ftype<et>(Vs1_vu[i + offset])),\n                            fwiden(ftype<et>(Vs2_vu[i + offset])),\n                            ftype<ewt>(Vs3_vwu[i]));\n                        Vd_vwu[i] = fd.v;\n                    ', 'OPFVV', 'SimdFloatMultAccOp'],{})


template <typename ElemType>
Fault
Vfwmacc_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu [[maybe_unused]] = decltype(et::v);
    using ewt = typename double_width<et>::type;
    using vwu = decltype(ewt::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vwu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vd % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned Vd group in Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            const int64_t vs2_emul = vlmul + 0;
            if (((vs2_emul < 0) && (VS2 == VD)) ||
                ((vs2_emul >= 0) &&
                 (VS2 < VD + num_microops - (1 << vs2_emul)) &&
                 (VD < VS2 + (1 << vs2_emul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            if (((vlmul < 0) && (VS1 == VD)) ||
                ((vlmul >= 0) &&
                 (VS1 < VD + num_microops - (1 << vlmul)) &&
                 (VD < VS1 + (1 << vlmul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS1 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        auto fd = fmadd<ewt>(
                            fwiden(ftype<et>(Vs1[i + offset])),
                            fwiden(ftype<et>(Vs2[i + offset])),
                            ftype<ewt>(Vs3[i]));
                        Vd[i] = fd.v;
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vfwmacc_vvMicro<float16_t>;
template class Vfwmacc_vvMicro<float32_t>;
;


// VectorFloatWideningFormat::vfwnmacc_vv(['\n                        auto fd = fmadd<ewt>(\n                            fwiden(fneg(ftype<et>(Vs1_vu[i + offset]))),\n                            fwiden(ftype<et>(Vs2_vu[i + offset])),\n                            fneg(ftype<ewt>(Vs3_vwu[i])));\n                        Vd_vwu[i] = fd.v;\n                    ', 'OPFVV', 'SimdFloatMultAccOp'],{})


template <typename ElemType>
Fault
Vfwnmacc_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu [[maybe_unused]] = decltype(et::v);
    using ewt = typename double_width<et>::type;
    using vwu = decltype(ewt::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vwu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vd % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned Vd group in Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            const int64_t vs2_emul = vlmul + 0;
            if (((vs2_emul < 0) && (VS2 == VD)) ||
                ((vs2_emul >= 0) &&
                 (VS2 < VD + num_microops - (1 << vs2_emul)) &&
                 (VD < VS2 + (1 << vs2_emul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            if (((vlmul < 0) && (VS1 == VD)) ||
                ((vlmul >= 0) &&
                 (VS1 < VD + num_microops - (1 << vlmul)) &&
                 (VD < VS1 + (1 << vlmul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS1 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        auto fd = fmadd<ewt>(
                            fwiden(fneg(ftype<et>(Vs1[i + offset]))),
                            fwiden(ftype<et>(Vs2[i + offset])),
                            fneg(ftype<ewt>(Vs3[i])));
                        Vd[i] = fd.v;
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vfwnmacc_vvMicro<float16_t>;
template class Vfwnmacc_vvMicro<float32_t>;
;


// VectorFloatWideningFormat::vfwmsac_vv(['\n                        auto fd = fmadd<ewt>(\n                            fwiden(ftype<et>(Vs1_vu[i + offset])),\n                            fwiden(ftype<et>(Vs2_vu[i + offset])),\n                            fneg(ftype<ewt>(Vs3_vwu[i])));\n                        Vd_vwu[i] = fd.v;\n                    ', 'OPFVV', 'SimdFloatMultAccOp'],{})


template <typename ElemType>
Fault
Vfwmsac_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu [[maybe_unused]] = decltype(et::v);
    using ewt = typename double_width<et>::type;
    using vwu = decltype(ewt::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vwu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vd % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned Vd group in Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            const int64_t vs2_emul = vlmul + 0;
            if (((vs2_emul < 0) && (VS2 == VD)) ||
                ((vs2_emul >= 0) &&
                 (VS2 < VD + num_microops - (1 << vs2_emul)) &&
                 (VD < VS2 + (1 << vs2_emul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            if (((vlmul < 0) && (VS1 == VD)) ||
                ((vlmul >= 0) &&
                 (VS1 < VD + num_microops - (1 << vlmul)) &&
                 (VD < VS1 + (1 << vlmul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS1 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        auto fd = fmadd<ewt>(
                            fwiden(ftype<et>(Vs1[i + offset])),
                            fwiden(ftype<et>(Vs2[i + offset])),
                            fneg(ftype<ewt>(Vs3[i])));
                        Vd[i] = fd.v;
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vfwmsac_vvMicro<float16_t>;
template class Vfwmsac_vvMicro<float32_t>;
;


// VectorFloatWideningFormat::vfwnmsac_vv(['\n                        auto fd = fmadd<ewt>(\n                            fwiden(fneg(ftype<et>(Vs1_vu[i + offset]))),\n                            fwiden(ftype<et>(Vs2_vu[i + offset])),\n                            ftype<ewt>(Vs3_vwu[i]));\n                        Vd_vwu[i] = fd.v;\n                    ', 'OPFVV', 'SimdFloatMultAccOp'],{})


template <typename ElemType>
Fault
Vfwnmsac_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu [[maybe_unused]] = decltype(et::v);
    using ewt = typename double_width<et>::type;
    using vwu = decltype(ewt::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vwu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vd % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned Vd group in Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            const int64_t vs2_emul = vlmul + 0;
            if (((vs2_emul < 0) && (VS2 == VD)) ||
                ((vs2_emul >= 0) &&
                 (VS2 < VD + num_microops - (1 << vs2_emul)) &&
                 (VD < VS2 + (1 << vs2_emul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            if (((vlmul < 0) && (VS1 == VD)) ||
                ((vlmul >= 0) &&
                 (VS1 < VD + num_microops - (1 << vlmul)) &&
                 (VD < VS1 + (1 << vlmul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS1 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        auto fd = fmadd<ewt>(
                            fwiden(fneg(ftype<et>(Vs1[i + offset]))),
                            fwiden(ftype<et>(Vs2[i + offset])),
                            ftype<ewt>(Vs3[i]));
                        Vd[i] = fd.v;
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vfwnmsac_vvMicro<float16_t>;
template class Vfwnmsac_vvMicro<float32_t>;
;


// Unknown::unknown(([], {}))

// VectorReduceIntFormat::vredsum_vs(['\n                        Vd_vi[0] =\n                            reduce_loop(std::plus<vi>(), Vs1_vi, Vs2_vi);\n                    ', 'OPMVV', 'SimdReduceAddOp'],{})


template <typename ElemType>
Fault
Vredsum_vsMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    
        using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
        using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    ;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }


    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;

    auto reduce_loop =
        [&, this](const auto& f, const auto* _, const auto* vs2) {
            ElemType microop_result = Vs1[0];
            for (uint32_t i = 0; i < this->microVl; i++) {
                uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) *
                    this->microIdx;
                if (this->vm || elem_mask(v0, ei)) {
                    microop_result = f(microop_result, Vs2[i]);
                }
            }
            return microop_result;
        };

    
                        Vd[0] =
                            reduce_loop(std::plus<vi>(), Vs1, Vs2);
                    ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vredsum_vsMicro<uint8_t>;
template class Vredsum_vsMicro<uint16_t>;
template class Vredsum_vsMicro<uint32_t>;
template class Vredsum_vsMicro<uint64_t>;
;


// VectorReduceIntFormat::vredand_vs(['\n                        Vd_vi[0] =\n                            reduce_loop(std::bit_and<vi>(), Vs1_vi, Vs2_vi);\n                    ', 'OPMVV', 'SimdReduceAluOp'],{})


template <typename ElemType>
Fault
Vredand_vsMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    
        using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
        using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    ;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }


    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;

    auto reduce_loop =
        [&, this](const auto& f, const auto* _, const auto* vs2) {
            ElemType microop_result = Vs1[0];
            for (uint32_t i = 0; i < this->microVl; i++) {
                uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) *
                    this->microIdx;
                if (this->vm || elem_mask(v0, ei)) {
                    microop_result = f(microop_result, Vs2[i]);
                }
            }
            return microop_result;
        };

    
                        Vd[0] =
                            reduce_loop(std::bit_and<vi>(), Vs1, Vs2);
                    ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vredand_vsMicro<uint8_t>;
template class Vredand_vsMicro<uint16_t>;
template class Vredand_vsMicro<uint32_t>;
template class Vredand_vsMicro<uint64_t>;
;


// VectorReduceIntFormat::vredor_vs(['\n                        Vd_vi[0] =\n                            reduce_loop(std::bit_or<vi>(), Vs1_vi, Vs2_vi);\n                    ', 'OPMVV', 'SimdReduceAluOp'],{})


template <typename ElemType>
Fault
Vredor_vsMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    
        using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
        using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    ;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }


    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;

    auto reduce_loop =
        [&, this](const auto& f, const auto* _, const auto* vs2) {
            ElemType microop_result = Vs1[0];
            for (uint32_t i = 0; i < this->microVl; i++) {
                uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) *
                    this->microIdx;
                if (this->vm || elem_mask(v0, ei)) {
                    microop_result = f(microop_result, Vs2[i]);
                }
            }
            return microop_result;
        };

    
                        Vd[0] =
                            reduce_loop(std::bit_or<vi>(), Vs1, Vs2);
                    ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vredor_vsMicro<uint8_t>;
template class Vredor_vsMicro<uint16_t>;
template class Vredor_vsMicro<uint32_t>;
template class Vredor_vsMicro<uint64_t>;
;


// VectorReduceIntFormat::vredxor_vs(['\n                        Vd_vi[0] =\n                            reduce_loop(std::bit_xor<vi>(), Vs1_vi, Vs2_vi);\n                    ', 'OPMVV', 'SimdReduceAluOp'],{})


template <typename ElemType>
Fault
Vredxor_vsMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    
        using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
        using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    ;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }


    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;

    auto reduce_loop =
        [&, this](const auto& f, const auto* _, const auto* vs2) {
            ElemType microop_result = Vs1[0];
            for (uint32_t i = 0; i < this->microVl; i++) {
                uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) *
                    this->microIdx;
                if (this->vm || elem_mask(v0, ei)) {
                    microop_result = f(microop_result, Vs2[i]);
                }
            }
            return microop_result;
        };

    
                        Vd[0] =
                            reduce_loop(std::bit_xor<vi>(), Vs1, Vs2);
                    ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vredxor_vsMicro<uint8_t>;
template class Vredxor_vsMicro<uint16_t>;
template class Vredxor_vsMicro<uint32_t>;
template class Vredxor_vsMicro<uint64_t>;
;


// VectorReduceIntFormat::vredminu_vs(['\n                        Vd_vu[0] =\n                            reduce_loop([](const vu& src1, const vu& src2) {\n                                return std::min<vu>(src1, src2);\n                            }, Vs1_vu, Vs2_vu);\n                    ', 'OPMVV', 'SimdReduceCmpOp'],{})


template <typename ElemType>
Fault
Vredminu_vsMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    
        using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
        using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    ;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }


    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;

    auto reduce_loop =
        [&, this](const auto& f, const auto* _, const auto* vs2) {
            ElemType microop_result = Vs1[0];
            for (uint32_t i = 0; i < this->microVl; i++) {
                uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) *
                    this->microIdx;
                if (this->vm || elem_mask(v0, ei)) {
                    microop_result = f(microop_result, Vs2[i]);
                }
            }
            return microop_result;
        };

    
                        Vd[0] =
                            reduce_loop([](const vu& src1, const vu& src2) {
                                return std::min<vu>(src1, src2);
                            }, Vs1, Vs2);
                    ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vredminu_vsMicro<uint8_t>;
template class Vredminu_vsMicro<uint16_t>;
template class Vredminu_vsMicro<uint32_t>;
template class Vredminu_vsMicro<uint64_t>;
;


// VectorReduceIntFormat::vredmin_vs(['\n                        Vd_vi[0] =\n                            reduce_loop([](const vi& src1, const vi& src2) {\n                                return std::min<vi>(src1, src2);\n                            }, Vs1_vi, Vs2_vi);\n                    ', 'OPMVV', 'SimdReduceCmpOp'],{})


template <typename ElemType>
Fault
Vredmin_vsMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    
        using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
        using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    ;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }


    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;

    auto reduce_loop =
        [&, this](const auto& f, const auto* _, const auto* vs2) {
            ElemType microop_result = Vs1[0];
            for (uint32_t i = 0; i < this->microVl; i++) {
                uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) *
                    this->microIdx;
                if (this->vm || elem_mask(v0, ei)) {
                    microop_result = f(microop_result, Vs2[i]);
                }
            }
            return microop_result;
        };

    
                        Vd[0] =
                            reduce_loop([](const vi& src1, const vi& src2) {
                                return std::min<vi>(src1, src2);
                            }, Vs1, Vs2);
                    ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vredmin_vsMicro<uint8_t>;
template class Vredmin_vsMicro<uint16_t>;
template class Vredmin_vsMicro<uint32_t>;
template class Vredmin_vsMicro<uint64_t>;
;


// VectorReduceIntFormat::vredmaxu_vs(['\n                        Vd_vu[0] =\n                            reduce_loop([](const vu& src1, const vu& src2) {\n                                return std::max<vu>(src1, src2);\n                            }, Vs1_vu, Vs2_vu);\n                    ', 'OPMVV', 'SimdReduceCmpOp'],{})


template <typename ElemType>
Fault
Vredmaxu_vsMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    
        using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
        using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    ;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }


    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;

    auto reduce_loop =
        [&, this](const auto& f, const auto* _, const auto* vs2) {
            ElemType microop_result = Vs1[0];
            for (uint32_t i = 0; i < this->microVl; i++) {
                uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) *
                    this->microIdx;
                if (this->vm || elem_mask(v0, ei)) {
                    microop_result = f(microop_result, Vs2[i]);
                }
            }
            return microop_result;
        };

    
                        Vd[0] =
                            reduce_loop([](const vu& src1, const vu& src2) {
                                return std::max<vu>(src1, src2);
                            }, Vs1, Vs2);
                    ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vredmaxu_vsMicro<uint8_t>;
template class Vredmaxu_vsMicro<uint16_t>;
template class Vredmaxu_vsMicro<uint32_t>;
template class Vredmaxu_vsMicro<uint64_t>;
;


// VectorReduceIntFormat::vredmax_vs(['\n                        Vd_vi[0] =\n                            reduce_loop([](const vi& src1, const vi& src2) {\n                                return std::max<vi>(src1, src2);\n                            }, Vs1_vi, Vs2_vi);\n                    ', 'OPMVV', 'SimdReduceCmpOp'],{})


template <typename ElemType>
Fault
Vredmax_vsMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    
        using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
        using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    ;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }


    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;

    auto reduce_loop =
        [&, this](const auto& f, const auto* _, const auto* vs2) {
            ElemType microop_result = Vs1[0];
            for (uint32_t i = 0; i < this->microVl; i++) {
                uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) *
                    this->microIdx;
                if (this->vm || elem_mask(v0, ei)) {
                    microop_result = f(microop_result, Vs2[i]);
                }
            }
            return microop_result;
        };

    
                        Vd[0] =
                            reduce_loop([](const vi& src1, const vi& src2) {
                                return std::max<vi>(src1, src2);
                            }, Vs1, Vs2);
                    ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vredmax_vsMicro<uint8_t>;
template class Vredmax_vsMicro<uint16_t>;
template class Vredmax_vsMicro<uint32_t>;
template class Vredmax_vsMicro<uint64_t>;
;


// VectorIntFormat::vaaddu_vv(['\n                        __uint128_t res = (__uint128_t)Vs2_vu[i] + Vs1_vu[i];\n                        res = int_rounding<__uint128_t>(res, 0 /* TODO */, 1);\n                        Vd_vu[i] = res >> 1;\n                    ', 'OPMVV', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vaaddu_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        __uint128_t res = (__uint128_t)Vs2[i] + Vs1[i];
                        res = int_rounding<__uint128_t>(res, 0 /* TODO */, 1);
                        Vd[i] = res >> 1;
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vaaddu_vvMicro<uint8_t>;
template class Vaaddu_vvMicro<uint16_t>;
template class Vaaddu_vvMicro<uint32_t>;
template class Vaaddu_vvMicro<uint64_t>;
;


// VectorIntFormat::vaadd_vv(['\n                        __uint128_t res = (__uint128_t)Vs2_vi[i] + Vs1_vi[i];\n                        res = int_rounding<__uint128_t>(res, 0 /* TODO */, 1);\n                        Vd_vi[i] = res >> 1;\n                    ', 'OPMVV', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vaadd_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        __uint128_t res = (__uint128_t)Vs2[i] + Vs1[i];
                        res = int_rounding<__uint128_t>(res, 0 /* TODO */, 1);
                        Vd[i] = res >> 1;
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vaadd_vvMicro<uint8_t>;
template class Vaadd_vvMicro<uint16_t>;
template class Vaadd_vvMicro<uint32_t>;
template class Vaadd_vvMicro<uint64_t>;
;


// VectorIntFormat::vasubu_vv(['\n                        __uint128_t res = (__uint128_t)Vs2_vu[i] - Vs1_vu[i];\n                        res = int_rounding<__uint128_t>(res, 0 /* TODO */, 1);\n                        Vd_vu[i] = res >> 1;\n                    ', 'OPMVV', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vasubu_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        __uint128_t res = (__uint128_t)Vs2[i] - Vs1[i];
                        res = int_rounding<__uint128_t>(res, 0 /* TODO */, 1);
                        Vd[i] = res >> 1;
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vasubu_vvMicro<uint8_t>;
template class Vasubu_vvMicro<uint16_t>;
template class Vasubu_vvMicro<uint32_t>;
template class Vasubu_vvMicro<uint64_t>;
;


// VectorIntFormat::vasub_vv(['\n                        __uint128_t res = (__uint128_t)Vs2_vi[i] - Vs1_vi[i];\n                        res = int_rounding<__uint128_t>(res, 0 /* TODO */, 1);\n                        Vd_vi[i] = res >> 1;\n                    ', 'OPMVV', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vasub_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        __uint128_t res = (__uint128_t)Vs2[i] - Vs1[i];
                        res = int_rounding<__uint128_t>(res, 0 /* TODO */, 1);
                        Vd[i] = res >> 1;
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vasub_vvMicro<uint8_t>;
template class Vasub_vvMicro<uint16_t>;
template class Vasub_vvMicro<uint32_t>;
template class Vasub_vvMicro<uint64_t>;
;


// VectorNonSplitFormat::vmv_x_s((['\n                            Rd_ud = Vs2_vi[0];\n                        ', 'OPMVV', 'SimdMiscOp'], {}))


template <typename ElemType>
Fault
Vmv_x_s<ElemType>::execute(ExecContext* xc,
                                    trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    uint64_t Rd = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vi>();
;
    ;
    
                            Rd = Vs2[0];
                        ;
    
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
    return NoFault;
}

template class Vmv_x_s<uint8_t>;
template class Vmv_x_s<uint16_t>;
template class Vmv_x_s<uint32_t>;
template class Vmv_x_s<uint64_t>;
;


// Unknown::unknown(([], {}))

// Vector1Vs1RdMaskFormat::vcpop_m((['\n                        uint64_t popcount = 0;\n                        for (uint32_t i = 0; i < (uint32_t)machInst.vl; i++) {\n                            bool vs2_lsb = elem_mask(Vs2_vu, i);\n                            if(this->vm){\n                                popcount += vs2_lsb;\n                            }else{\n                                bool do_mask = elem_mask(v0, i);\n                                popcount += (vs2_lsb && do_mask);\n                            }\n                        }\n                        Rd_vu = popcount;\n                    ', 'OPMVV', 'SimdAluOp'], {}))


template<typename ElemType>
Fault
Vcpop_m<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vu>();
;
    uint64_t Rd = 0;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    
                        uint64_t popcount = 0;
                        for (uint32_t i = 0; i < (uint32_t)machInst.vl; i++) {
                            bool vs2_lsb = elem_mask(Vs2, i);
                            if(this->vm){
                                popcount += vs2_lsb;
                            }else{
                                bool do_mask = elem_mask(v0, i);
                                popcount += (vs2_lsb && do_mask);
                            }
                        }
                        Rd = popcount;
                    ;
    
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
    return NoFault;
};

template class Vcpop_m<uint8_t>;
;


// Vector1Vs1RdMaskFormat::vfirst_m((['\n                        int64_t pos = -1;\n                        for (uint32_t i = 0; i < (uint32_t)machInst.vl; i++) {\n                            if(this->vm == 0){\n                                if(elem_mask(v0, i)==0){\n                                    continue;\n                                }\n                            }\n                            bool vs2_lsb = elem_mask(Vs2_vu, i);\n                            if (vs2_lsb) {\n                                pos = i;\n                                break;\n                            }\n                        }\n                        Rd_vu = pos;\n                    ', 'OPMVV', 'SimdMiscOp'], {}))


template<typename ElemType>
Fault
Vfirst_m<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vu>();
;
    uint64_t Rd = 0;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    
                        int64_t pos = -1;
                        for (uint32_t i = 0; i < (uint32_t)machInst.vl; i++) {
                            if(this->vm == 0){
                                if(elem_mask(v0, i)==0){
                                    continue;
                                }
                            }
                            bool vs2_lsb = elem_mask(Vs2, i);
                            if (vs2_lsb) {
                                pos = i;
                                break;
                            }
                        }
                        Rd = pos;
                    ;
    
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
    return NoFault;
};

template class Vfirst_m<uint8_t>;
;


// Unknown::unknown(([], {}))

// VectorIntExtFormat::vzext_vf8(['\n                            auto offset = (vlen / SEW) * index;\n\n                            Vd_vu[i] = Vs2_vextu[i + offset];\n                        ', 'OPMVV', 'SimdExtOp'],{})


template <typename ElemType>
Fault
Vzext_vf8Micro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    auto SEW = vtype_SEW(vtype);
    auto index = (microIdx % 8);

    switch (SEW / 8) {
      case 8: {
        using vext  [[maybe_unused]] = int8_t;
        using vextu [[maybe_unused]] = uint8_t;
        	/* Vars for Vs2*/	/* End vars for Vs2 */
;
        		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vextu>();
;
        [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
        
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
        COPY_OLD_VD(1);;
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                            auto offset = (vlen / SEW) * index;

                            Vd[i] = Vs2[i + offset];
                        }

            }
        ;
        
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
        break;
      }
      case 16: {
        using vext  [[maybe_unused]] = int16_t;
        using vextu [[maybe_unused]] = uint16_t;
        	/* Vars for Vs2*/	/* End vars for Vs2 */
;
        		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vextu>();
;
        [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
        
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
        COPY_OLD_VD(1);;
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                            auto offset = (vlen / SEW) * index;

                            Vd[i] = Vs2[i + offset];
                        }

            }
        ;
        
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
        break;
      }
      case 32: {
        using vext  [[maybe_unused]] = int32_t;
        using vextu [[maybe_unused]] = uint32_t;
        	/* Vars for Vs2*/	/* End vars for Vs2 */
;
        		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vextu>();
;
        [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
        
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
        COPY_OLD_VD(1);;
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                            auto offset = (vlen / SEW) * index;

                            Vd[i] = Vs2[i + offset];
                        }

            }
        ;
        
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
      break;
      }
      default: break;
    }

    return NoFault;
}

template <typename ElemType>
std::string
Vzext_vf8Micro<ElemType>::generateDisassembly(Addr pc,
    const loader::SymbolTable *symtab) const
{
    std::stringstream ss;
    ss << mnemonic << ' ' << registerName(destRegIdx(0)) << ", "
        << registerName(srcRegIdx(0));
    if (machInst.vm == 0) ss << ", v0.t";
    return ss.str();
}

template class Vzext_vf8Micro<uint8_t>;
template class Vzext_vf8Micro<uint16_t>;
template class Vzext_vf8Micro<uint32_t>;
template class Vzext_vf8Micro<uint64_t>;
;



template <typename ElemType>
std::string
Vzext_vf8<ElemType>::generateDisassembly(Addr pc,
    const loader::SymbolTable *symtab) const
{
    std::stringstream ss;
    ss << mnemonic << ' ' << registerName(destRegIdx(0)) << ", "
        << registerName(srcRegIdx(0));
    if (machInst.vm == 0) ss << ", v0.t";
    return ss.str();
}

template class Vzext_vf8<uint8_t>;
template class Vzext_vf8<uint16_t>;
template class Vzext_vf8<uint32_t>;
template class Vzext_vf8<uint64_t>;
;


// VectorIntExtFormat::vsext_vf8(['\n                            auto offset = (vlen / SEW) * index;\n\n                            Vd_vi[i] = Vs2_vext[i + offset];\n                        ', 'OPMVV', 'SimdExtOp'],{})


template <typename ElemType>
Fault
Vsext_vf8Micro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    auto SEW = vtype_SEW(vtype);
    auto index = (microIdx % 8);

    switch (SEW / 8) {
      case 8: {
        using vext  [[maybe_unused]] = int8_t;
        using vextu [[maybe_unused]] = uint8_t;
        	/* Vars for Vs2*/	/* End vars for Vs2 */
;
        		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vext>();
;
        [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
        
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
        COPY_OLD_VD(1);;
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                            auto offset = (vlen / SEW) * index;

                            Vd[i] = Vs2[i + offset];
                        }

            }
        ;
        
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
        break;
      }
      case 16: {
        using vext  [[maybe_unused]] = int16_t;
        using vextu [[maybe_unused]] = uint16_t;
        	/* Vars for Vs2*/	/* End vars for Vs2 */
;
        		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vext>();
;
        [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
        
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
        COPY_OLD_VD(1);;
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                            auto offset = (vlen / SEW) * index;

                            Vd[i] = Vs2[i + offset];
                        }

            }
        ;
        
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
        break;
      }
      case 32: {
        using vext  [[maybe_unused]] = int32_t;
        using vextu [[maybe_unused]] = uint32_t;
        	/* Vars for Vs2*/	/* End vars for Vs2 */
;
        		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vext>();
;
        [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
        
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
        COPY_OLD_VD(1);;
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                            auto offset = (vlen / SEW) * index;

                            Vd[i] = Vs2[i + offset];
                        }

            }
        ;
        
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
      break;
      }
      default: break;
    }

    return NoFault;
}

template <typename ElemType>
std::string
Vsext_vf8Micro<ElemType>::generateDisassembly(Addr pc,
    const loader::SymbolTable *symtab) const
{
    std::stringstream ss;
    ss << mnemonic << ' ' << registerName(destRegIdx(0)) << ", "
        << registerName(srcRegIdx(0));
    if (machInst.vm == 0) ss << ", v0.t";
    return ss.str();
}

template class Vsext_vf8Micro<uint8_t>;
template class Vsext_vf8Micro<uint16_t>;
template class Vsext_vf8Micro<uint32_t>;
template class Vsext_vf8Micro<uint64_t>;
;



template <typename ElemType>
std::string
Vsext_vf8<ElemType>::generateDisassembly(Addr pc,
    const loader::SymbolTable *symtab) const
{
    std::stringstream ss;
    ss << mnemonic << ' ' << registerName(destRegIdx(0)) << ", "
        << registerName(srcRegIdx(0));
    if (machInst.vm == 0) ss << ", v0.t";
    return ss.str();
}

template class Vsext_vf8<uint8_t>;
template class Vsext_vf8<uint16_t>;
template class Vsext_vf8<uint32_t>;
template class Vsext_vf8<uint64_t>;
;


// VectorIntExtFormat::vzext_vf4(['\n                            auto offset = (vlen / SEW) * index;\n\n                            Vd_vu[i] = Vs2_vextu[i + offset];\n                        ', 'OPMVV', 'SimdExtOp'],{})


template <typename ElemType>
Fault
Vzext_vf4Micro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    auto SEW = vtype_SEW(vtype);
    auto index = (microIdx % 4);

    switch (SEW / 4) {
      case 8: {
        using vext  [[maybe_unused]] = int8_t;
        using vextu [[maybe_unused]] = uint8_t;
        	/* Vars for Vs2*/	/* End vars for Vs2 */
;
        		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vextu>();
;
        [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
        
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
        COPY_OLD_VD(1);;
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                            auto offset = (vlen / SEW) * index;

                            Vd[i] = Vs2[i + offset];
                        }

            }
        ;
        
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
        break;
      }
      case 16: {
        using vext  [[maybe_unused]] = int16_t;
        using vextu [[maybe_unused]] = uint16_t;
        	/* Vars for Vs2*/	/* End vars for Vs2 */
;
        		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vextu>();
;
        [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
        
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
        COPY_OLD_VD(1);;
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                            auto offset = (vlen / SEW) * index;

                            Vd[i] = Vs2[i + offset];
                        }

            }
        ;
        
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
        break;
      }
      case 32: {
        using vext  [[maybe_unused]] = int32_t;
        using vextu [[maybe_unused]] = uint32_t;
        	/* Vars for Vs2*/	/* End vars for Vs2 */
;
        		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vextu>();
;
        [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
        
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
        COPY_OLD_VD(1);;
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                            auto offset = (vlen / SEW) * index;

                            Vd[i] = Vs2[i + offset];
                        }

            }
        ;
        
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
      break;
      }
      default: break;
    }

    return NoFault;
}

template <typename ElemType>
std::string
Vzext_vf4Micro<ElemType>::generateDisassembly(Addr pc,
    const loader::SymbolTable *symtab) const
{
    std::stringstream ss;
    ss << mnemonic << ' ' << registerName(destRegIdx(0)) << ", "
        << registerName(srcRegIdx(0));
    if (machInst.vm == 0) ss << ", v0.t";
    return ss.str();
}

template class Vzext_vf4Micro<uint8_t>;
template class Vzext_vf4Micro<uint16_t>;
template class Vzext_vf4Micro<uint32_t>;
template class Vzext_vf4Micro<uint64_t>;
;



template <typename ElemType>
std::string
Vzext_vf4<ElemType>::generateDisassembly(Addr pc,
    const loader::SymbolTable *symtab) const
{
    std::stringstream ss;
    ss << mnemonic << ' ' << registerName(destRegIdx(0)) << ", "
        << registerName(srcRegIdx(0));
    if (machInst.vm == 0) ss << ", v0.t";
    return ss.str();
}

template class Vzext_vf4<uint8_t>;
template class Vzext_vf4<uint16_t>;
template class Vzext_vf4<uint32_t>;
template class Vzext_vf4<uint64_t>;
;


// VectorIntExtFormat::vsext_vf4(['\n                            auto offset = (vlen / SEW) * index;\n\n                            Vd_vi[i] = Vs2_vext[i + offset];\n                        ', 'OPMVV', 'SimdExtOp'],{})


template <typename ElemType>
Fault
Vsext_vf4Micro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    auto SEW = vtype_SEW(vtype);
    auto index = (microIdx % 4);

    switch (SEW / 4) {
      case 8: {
        using vext  [[maybe_unused]] = int8_t;
        using vextu [[maybe_unused]] = uint8_t;
        	/* Vars for Vs2*/	/* End vars for Vs2 */
;
        		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vext>();
;
        [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
        
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
        COPY_OLD_VD(1);;
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                            auto offset = (vlen / SEW) * index;

                            Vd[i] = Vs2[i + offset];
                        }

            }
        ;
        
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
        break;
      }
      case 16: {
        using vext  [[maybe_unused]] = int16_t;
        using vextu [[maybe_unused]] = uint16_t;
        	/* Vars for Vs2*/	/* End vars for Vs2 */
;
        		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vext>();
;
        [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
        
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
        COPY_OLD_VD(1);;
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                            auto offset = (vlen / SEW) * index;

                            Vd[i] = Vs2[i + offset];
                        }

            }
        ;
        
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
        break;
      }
      case 32: {
        using vext  [[maybe_unused]] = int32_t;
        using vextu [[maybe_unused]] = uint32_t;
        	/* Vars for Vs2*/	/* End vars for Vs2 */
;
        		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vext>();
;
        [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
        
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
        COPY_OLD_VD(1);;
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                            auto offset = (vlen / SEW) * index;

                            Vd[i] = Vs2[i + offset];
                        }

            }
        ;
        
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
      break;
      }
      default: break;
    }

    return NoFault;
}

template <typename ElemType>
std::string
Vsext_vf4Micro<ElemType>::generateDisassembly(Addr pc,
    const loader::SymbolTable *symtab) const
{
    std::stringstream ss;
    ss << mnemonic << ' ' << registerName(destRegIdx(0)) << ", "
        << registerName(srcRegIdx(0));
    if (machInst.vm == 0) ss << ", v0.t";
    return ss.str();
}

template class Vsext_vf4Micro<uint8_t>;
template class Vsext_vf4Micro<uint16_t>;
template class Vsext_vf4Micro<uint32_t>;
template class Vsext_vf4Micro<uint64_t>;
;



template <typename ElemType>
std::string
Vsext_vf4<ElemType>::generateDisassembly(Addr pc,
    const loader::SymbolTable *symtab) const
{
    std::stringstream ss;
    ss << mnemonic << ' ' << registerName(destRegIdx(0)) << ", "
        << registerName(srcRegIdx(0));
    if (machInst.vm == 0) ss << ", v0.t";
    return ss.str();
}

template class Vsext_vf4<uint8_t>;
template class Vsext_vf4<uint16_t>;
template class Vsext_vf4<uint32_t>;
template class Vsext_vf4<uint64_t>;
;


// VectorIntExtFormat::vzext_vf2(['\n                            auto offset = (vlen / SEW) * index;\n\n                            Vd_vu[i] = Vs2_vextu[i + offset];\n                        ', 'OPMVV', 'SimdExtOp'],{})


template <typename ElemType>
Fault
Vzext_vf2Micro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    auto SEW = vtype_SEW(vtype);
    auto index = (microIdx % 2);

    switch (SEW / 2) {
      case 8: {
        using vext  [[maybe_unused]] = int8_t;
        using vextu [[maybe_unused]] = uint8_t;
        	/* Vars for Vs2*/	/* End vars for Vs2 */
;
        		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vextu>();
;
        [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
        
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
        COPY_OLD_VD(1);;
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                            auto offset = (vlen / SEW) * index;

                            Vd[i] = Vs2[i + offset];
                        }

            }
        ;
        
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
        break;
      }
      case 16: {
        using vext  [[maybe_unused]] = int16_t;
        using vextu [[maybe_unused]] = uint16_t;
        	/* Vars for Vs2*/	/* End vars for Vs2 */
;
        		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vextu>();
;
        [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
        
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
        COPY_OLD_VD(1);;
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                            auto offset = (vlen / SEW) * index;

                            Vd[i] = Vs2[i + offset];
                        }

            }
        ;
        
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
        break;
      }
      case 32: {
        using vext  [[maybe_unused]] = int32_t;
        using vextu [[maybe_unused]] = uint32_t;
        	/* Vars for Vs2*/	/* End vars for Vs2 */
;
        		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vextu>();
;
        [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
        
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
        COPY_OLD_VD(1);;
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                            auto offset = (vlen / SEW) * index;

                            Vd[i] = Vs2[i + offset];
                        }

            }
        ;
        
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
      break;
      }
      default: break;
    }

    return NoFault;
}

template <typename ElemType>
std::string
Vzext_vf2Micro<ElemType>::generateDisassembly(Addr pc,
    const loader::SymbolTable *symtab) const
{
    std::stringstream ss;
    ss << mnemonic << ' ' << registerName(destRegIdx(0)) << ", "
        << registerName(srcRegIdx(0));
    if (machInst.vm == 0) ss << ", v0.t";
    return ss.str();
}

template class Vzext_vf2Micro<uint8_t>;
template class Vzext_vf2Micro<uint16_t>;
template class Vzext_vf2Micro<uint32_t>;
template class Vzext_vf2Micro<uint64_t>;
;



template <typename ElemType>
std::string
Vzext_vf2<ElemType>::generateDisassembly(Addr pc,
    const loader::SymbolTable *symtab) const
{
    std::stringstream ss;
    ss << mnemonic << ' ' << registerName(destRegIdx(0)) << ", "
        << registerName(srcRegIdx(0));
    if (machInst.vm == 0) ss << ", v0.t";
    return ss.str();
}

template class Vzext_vf2<uint8_t>;
template class Vzext_vf2<uint16_t>;
template class Vzext_vf2<uint32_t>;
template class Vzext_vf2<uint64_t>;
;


// VectorIntExtFormat::vsext_vf2(['\n                            auto offset = (vlen / SEW) * index;\n\n                            Vd_vi[i] = Vs2_vext[i + offset];\n                        ', 'OPMVV', 'SimdExtOp'],{})


template <typename ElemType>
Fault
Vsext_vf2Micro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    auto SEW = vtype_SEW(vtype);
    auto index = (microIdx % 2);

    switch (SEW / 2) {
      case 8: {
        using vext  [[maybe_unused]] = int8_t;
        using vextu [[maybe_unused]] = uint8_t;
        	/* Vars for Vs2*/	/* End vars for Vs2 */
;
        		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vext>();
;
        [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
        
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
        COPY_OLD_VD(1);;
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                            auto offset = (vlen / SEW) * index;

                            Vd[i] = Vs2[i + offset];
                        }

            }
        ;
        
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
        break;
      }
      case 16: {
        using vext  [[maybe_unused]] = int16_t;
        using vextu [[maybe_unused]] = uint16_t;
        	/* Vars for Vs2*/	/* End vars for Vs2 */
;
        		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vext>();
;
        [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
        
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
        COPY_OLD_VD(1);;
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                            auto offset = (vlen / SEW) * index;

                            Vd[i] = Vs2[i + offset];
                        }

            }
        ;
        
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
        break;
      }
      case 32: {
        using vext  [[maybe_unused]] = int32_t;
        using vextu [[maybe_unused]] = uint32_t;
        	/* Vars for Vs2*/	/* End vars for Vs2 */
;
        		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vext>();
;
        [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
        
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
        COPY_OLD_VD(1);;
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                            auto offset = (vlen / SEW) * index;

                            Vd[i] = Vs2[i + offset];
                        }

            }
        ;
        
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
      break;
      }
      default: break;
    }

    return NoFault;
}

template <typename ElemType>
std::string
Vsext_vf2Micro<ElemType>::generateDisassembly(Addr pc,
    const loader::SymbolTable *symtab) const
{
    std::stringstream ss;
    ss << mnemonic << ' ' << registerName(destRegIdx(0)) << ", "
        << registerName(srcRegIdx(0));
    if (machInst.vm == 0) ss << ", v0.t";
    return ss.str();
}

template class Vsext_vf2Micro<uint8_t>;
template class Vsext_vf2Micro<uint16_t>;
template class Vsext_vf2Micro<uint32_t>;
template class Vsext_vf2Micro<uint64_t>;
;



template <typename ElemType>
std::string
Vsext_vf2<ElemType>::generateDisassembly(Addr pc,
    const loader::SymbolTable *symtab) const
{
    std::stringstream ss;
    ss << mnemonic << ' ' << registerName(destRegIdx(0)) << ", "
        << registerName(srcRegIdx(0));
    if (machInst.vm == 0) ss << ", v0.t";
    return ss.str();
}

template class Vsext_vf2<uint8_t>;
template class Vsext_vf2<uint16_t>;
template class Vsext_vf2<uint32_t>;
template class Vsext_vf2<uint64_t>;
;


// Unknown::unknown(([], {}))

// Vector1Vs1VdMaskFormat::vmsbf_m((['\n                        bool has_one = false;\n                        for (uint32_t i = 0; i < (uint32_t)machInst.vl; i++) {\n                            bool vs2_lsb = elem_mask(Vs2_vu, i);\n                            if (this->vm || elem_mask(v0, i)){\n                                uint64_t res = 0;\n                                if (!has_one && !vs2_lsb) {\n                                    res = 1;\n                                } else if (!has_one && vs2_lsb) {\n                                    has_one = true;\n                                }\n                                Vd_ub[i/8] = ASSIGN_VD_BIT(i, res);\n                            }\n                        }\n                    ', 'OPMVV', 'SimdAluOp'], {}))


template<typename ElemType>
Fault
Vmsbf_m<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu = uint8_t;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    
                        bool has_one = false;
                        for (uint32_t i = 0; i < (uint32_t)machInst.vl; i++) {
                            bool vs2_lsb = elem_mask(Vs2, i);
                            if (this->vm || elem_mask(v0, i)){
                                uint64_t res = 0;
                                if (!has_one && !vs2_lsb) {
                                    res = 1;
                                } else if (!has_one && vs2_lsb) {
                                    has_one = true;
                                }
                                Vd[i/8] = ASSIGN_VD_BIT(i, res);
                            }
                        }
                    ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
};

template class Vmsbf_m<uint8_t>;
;


// Vector1Vs1VdMaskFormat::vmsof_m((['\n                        bool has_one = false;\n                        for (uint32_t i = 0; i < (uint32_t)machInst.vl; i++) {\n                            bool vs2_lsb = elem_mask(Vs2_vu, i);\n                            if (this->vm || elem_mask(v0, i)){\n                                uint64_t res = 0;\n                                if (!has_one && vs2_lsb) {\n                                    has_one = true;\n                                    res = 1;\n                                }\n                                Vd_ub[i/8] = ASSIGN_VD_BIT(i, res);\n                            }\n                        }\n                    ', 'OPMVV', 'SimdAluOp'], {}))


template<typename ElemType>
Fault
Vmsof_m<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu = uint8_t;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    
                        bool has_one = false;
                        for (uint32_t i = 0; i < (uint32_t)machInst.vl; i++) {
                            bool vs2_lsb = elem_mask(Vs2, i);
                            if (this->vm || elem_mask(v0, i)){
                                uint64_t res = 0;
                                if (!has_one && vs2_lsb) {
                                    has_one = true;
                                    res = 1;
                                }
                                Vd[i/8] = ASSIGN_VD_BIT(i, res);
                            }
                        }
                    ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
};

template class Vmsof_m<uint8_t>;
;


// Vector1Vs1VdMaskFormat::vmsif_m((['\n                        bool has_one = false;\n                        for (uint32_t i = 0; i < (uint32_t)machInst.vl; i++) {\n                            bool vs2_lsb = elem_mask(Vs2_vu, i);\n                            if (this->vm || elem_mask(v0, i)){\n                                uint64_t res = 0;\n                                if (!has_one && !vs2_lsb) {\n                                    res = 1;\n                                } else if (!has_one && vs2_lsb) {\n                                    has_one = true;\n                                    res = 1;\n                                }\n                                Vd_ub[i/8] = ASSIGN_VD_BIT(i, res);\n                            }\n                        }\n                    ', 'OPMVV', 'SimdAluOp'], {}))


template<typename ElemType>
Fault
Vmsif_m<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu = uint8_t;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    
                        bool has_one = false;
                        for (uint32_t i = 0; i < (uint32_t)machInst.vl; i++) {
                            bool vs2_lsb = elem_mask(Vs2, i);
                            if (this->vm || elem_mask(v0, i)){
                                uint64_t res = 0;
                                if (!has_one && !vs2_lsb) {
                                    res = 1;
                                } else if (!has_one && vs2_lsb) {
                                    has_one = true;
                                    res = 1;
                                }
                                Vd[i/8] = ASSIGN_VD_BIT(i, res);
                            }
                        }
                    ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
};

template class Vmsif_m<uint8_t>;
;


// ViotaFormat::viota_m((['\n                        if (this->vm || elem_mask(v0, ei)) {\n                            Vd_vu[i] = *cnt;\n                            if (elem_mask(Vs2_vu, ei)) {\n                                *cnt = *cnt+1;\n                            }\n                        }\n                    ', 'OPMVV', 'SimdAluOp'], {}))


template <typename ElemType>
Fault
Viota_mMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    if (isFirstMicroop())
        *cnt = 0;
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(1);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            
                        if (this->vm || elem_mask(v0, ei)) {
                            Vd[i] = *cnt;
                            if (elem_mask(Vs2, ei)) {
                                *cnt = *cnt+1;
                            }
                        }
                    
            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Viota_mMicro<uint8_t>;
template class Viota_mMicro<uint16_t>;
template class Viota_mMicro<uint32_t>;
template class Viota_mMicro<uint64_t>;
;


// VectorIntFormat::vid_v((['\n                        Vd_vu[i] = ei;\n                    ', 'OPMVV', 'SimdMiscOp'], {}))


template <typename ElemType>
Fault
Vid_vMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    ;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = ei;
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vid_vMicro<uint8_t>;
template class Vid_vMicro<uint16_t>;
template class Vid_vMicro<uint32_t>;
template class Vid_vMicro<uint64_t>;
;


// Unknown::unknown(([], {}))

// VectorMaskFormat::vmandn_mm(['\n                        Vd_ub[i/8] = ASSIGN_VD_BIT(i,\n                            elem_mask(Vs2_vu, i) & !elem_mask(Vs1_vu, i));\n                    ', 'OPMVV', 'SimdAluOp'],{})


template<typename ElemType>
Fault
Vmandn_mm<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu = uint8_t;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);


    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    // mask tails are always treated as agnostic: writting 1s
    tmp_d0.set(0xff);

    
            for (uint32_t i = 0; i < (uint32_t)machInst.vl; i++) {
                
                        Vd[i/8] = ASSIGN_VD_BIT(i,
                            elem_mask(Vs2, i) & !elem_mask(Vs1, i));
                    
            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
};

template class Vmandn_mm<uint8_t>;
;


// VectorMaskFormat::vmand_mm(['\n                        Vd_ub[i/8] = ASSIGN_VD_BIT(i,\n                            elem_mask(Vs2_vu, i) & elem_mask(Vs1_vu, i));\n                    ', 'OPMVV', 'SimdAluOp'],{})


template<typename ElemType>
Fault
Vmand_mm<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu = uint8_t;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);


    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    // mask tails are always treated as agnostic: writting 1s
    tmp_d0.set(0xff);

    
            for (uint32_t i = 0; i < (uint32_t)machInst.vl; i++) {
                
                        Vd[i/8] = ASSIGN_VD_BIT(i,
                            elem_mask(Vs2, i) & elem_mask(Vs1, i));
                    
            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
};

template class Vmand_mm<uint8_t>;
;


// VectorMaskFormat::vmor_mm(['\n                        Vd_ub[i/8] = ASSIGN_VD_BIT(i,\n                            elem_mask(Vs2_vu, i) | elem_mask(Vs1_vu, i));\n                    ', 'OPMVV', 'SimdAluOp'],{})


template<typename ElemType>
Fault
Vmor_mm<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu = uint8_t;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);


    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    // mask tails are always treated as agnostic: writting 1s
    tmp_d0.set(0xff);

    
            for (uint32_t i = 0; i < (uint32_t)machInst.vl; i++) {
                
                        Vd[i/8] = ASSIGN_VD_BIT(i,
                            elem_mask(Vs2, i) | elem_mask(Vs1, i));
                    
            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
};

template class Vmor_mm<uint8_t>;
;


// VectorMaskFormat::vmxor_mm(['\n                        Vd_ub[i/8] = ASSIGN_VD_BIT(i,\n                            elem_mask(Vs2_vu, i) ^ elem_mask(Vs1_vu, i));\n                    ', 'OPMVV', 'SimdAluOp'],{})


template<typename ElemType>
Fault
Vmxor_mm<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu = uint8_t;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);


    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    // mask tails are always treated as agnostic: writting 1s
    tmp_d0.set(0xff);

    
            for (uint32_t i = 0; i < (uint32_t)machInst.vl; i++) {
                
                        Vd[i/8] = ASSIGN_VD_BIT(i,
                            elem_mask(Vs2, i) ^ elem_mask(Vs1, i));
                    
            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
};

template class Vmxor_mm<uint8_t>;
;


// VectorMaskFormat::vmorn_mm(['\n                        Vd_ub[i/8] = ASSIGN_VD_BIT(i,\n                            elem_mask(Vs2_vu, i) | !elem_mask(Vs1_vu, i));\n                    ', 'OPMVV', 'SimdAluOp'],{})


template<typename ElemType>
Fault
Vmorn_mm<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu = uint8_t;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);


    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    // mask tails are always treated as agnostic: writting 1s
    tmp_d0.set(0xff);

    
            for (uint32_t i = 0; i < (uint32_t)machInst.vl; i++) {
                
                        Vd[i/8] = ASSIGN_VD_BIT(i,
                            elem_mask(Vs2, i) | !elem_mask(Vs1, i));
                    
            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
};

template class Vmorn_mm<uint8_t>;
;


// VectorMaskFormat::vmnand_mm(['\n                        Vd_ub[i/8] = ASSIGN_VD_BIT(i,\n                            !(elem_mask(Vs2_vu, i) & elem_mask(Vs1_vu, i)));\n                    ', 'OPMVV', 'SimdAluOp'],{})


template<typename ElemType>
Fault
Vmnand_mm<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu = uint8_t;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);


    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    // mask tails are always treated as agnostic: writting 1s
    tmp_d0.set(0xff);

    
            for (uint32_t i = 0; i < (uint32_t)machInst.vl; i++) {
                
                        Vd[i/8] = ASSIGN_VD_BIT(i,
                            !(elem_mask(Vs2, i) & elem_mask(Vs1, i)));
                    
            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
};

template class Vmnand_mm<uint8_t>;
;


// VectorMaskFormat::vmnor_mm(['\n                        Vd_ub[i/8] = ASSIGN_VD_BIT(i,\n                            !(elem_mask(Vs2_vu, i) | elem_mask(Vs1_vu, i)));\n                    ', 'OPMVV', 'SimdAluOp'],{})


template<typename ElemType>
Fault
Vmnor_mm<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu = uint8_t;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);


    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    // mask tails are always treated as agnostic: writting 1s
    tmp_d0.set(0xff);

    
            for (uint32_t i = 0; i < (uint32_t)machInst.vl; i++) {
                
                        Vd[i/8] = ASSIGN_VD_BIT(i,
                            !(elem_mask(Vs2, i) | elem_mask(Vs1, i)));
                    
            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
};

template class Vmnor_mm<uint8_t>;
;


// VectorMaskFormat::vmxnor_mm(['\n                        Vd_ub[i/8] = ASSIGN_VD_BIT(i,\n                            !(elem_mask(Vs2_vu, i) ^ elem_mask(Vs1_vu, i)));\n                    ', 'OPMVV', 'SimdAluOp'],{})


template<typename ElemType>
Fault
Vmxnor_mm<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu = uint8_t;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);


    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    // mask tails are always treated as agnostic: writting 1s
    tmp_d0.set(0xff);

    
            for (uint32_t i = 0; i < (uint32_t)machInst.vl; i++) {
                
                        Vd[i/8] = ASSIGN_VD_BIT(i,
                            !(elem_mask(Vs2, i) ^ elem_mask(Vs1, i)));
                    
            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
};

template class Vmxnor_mm<uint8_t>;
;


// VectorIntFormat::vdivu_vv(['\n                        Vd_vu[i] = divu<vu>(Vs2_vu[i], Vs1_vu[i]);\n                    ', 'OPMVV', 'SimdDivOp'],{})


template <typename ElemType>
Fault
Vdivu_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = divu<vu>(Vs2[i], Vs1[i]);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vdivu_vvMicro<uint8_t>;
template class Vdivu_vvMicro<uint16_t>;
template class Vdivu_vvMicro<uint32_t>;
template class Vdivu_vvMicro<uint64_t>;
;


// VectorIntFormat::vdiv_vv(['\n                        Vd_vi[i] = div<vi>(Vs2_vi[i], Vs1_vi[i]);\n                    ', 'OPMVV', 'SimdDivOp'],{})


template <typename ElemType>
Fault
Vdiv_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = div<vi>(Vs2[i], Vs1[i]);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vdiv_vvMicro<uint8_t>;
template class Vdiv_vvMicro<uint16_t>;
template class Vdiv_vvMicro<uint32_t>;
template class Vdiv_vvMicro<uint64_t>;
;


// VectorIntFormat::vremu_vv(['\n                        Vd_vu[i] = remu<vu>(Vs2_vu[i], Vs1_vu[i]);\n                    ', 'OPMVV', 'SimdDivOp'],{})


template <typename ElemType>
Fault
Vremu_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = remu<vu>(Vs2[i], Vs1[i]);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vremu_vvMicro<uint8_t>;
template class Vremu_vvMicro<uint16_t>;
template class Vremu_vvMicro<uint32_t>;
template class Vremu_vvMicro<uint64_t>;
;


// VectorIntFormat::vrem_vv(['\n                        Vd_vi[i] = rem<vi>(Vs2_vi[i], Vs1_vi[i]);\n                    ', 'OPMVV', 'SimdDivOp'],{})


template <typename ElemType>
Fault
Vrem_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = rem<vi>(Vs2[i], Vs1[i]);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vrem_vvMicro<uint8_t>;
template class Vrem_vvMicro<uint16_t>;
template class Vrem_vvMicro<uint32_t>;
template class Vrem_vvMicro<uint64_t>;
;


// VectorIntFormat::vmulhu_vv(['\n                        Vd_vu[i] = mulhu<vu>(Vs2_vu[i], Vs1_vu[i]);\n                    ', 'OPMVV', 'SimdMultOp'],{})


template <typename ElemType>
Fault
Vmulhu_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = mulhu<vu>(Vs2[i], Vs1[i]);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vmulhu_vvMicro<uint8_t>;
template class Vmulhu_vvMicro<uint16_t>;
template class Vmulhu_vvMicro<uint32_t>;
template class Vmulhu_vvMicro<uint64_t>;
;


// VectorIntFormat::vmul_vv(['\n                        Vd_vi[i] = Vs2_vi[i] * Vs1_vi[i];\n                    ', 'OPMVV', 'SimdMultOp'],{})


template <typename ElemType>
Fault
Vmul_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = Vs2[i] * Vs1[i];
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vmul_vvMicro<uint8_t>;
template class Vmul_vvMicro<uint16_t>;
template class Vmul_vvMicro<uint32_t>;
template class Vmul_vvMicro<uint64_t>;
;


// VectorIntFormat::vmulhsu_vv(['\n                        Vd_vi[i] = mulhsu<vi>(Vs2_vi[i], Vs1_vu[i]);\n                    ', 'OPMVV', 'SimdMultOp'],{})


template <typename ElemType>
Fault
Vmulhsu_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = mulhsu<vi>(Vs2[i], Vs1[i]);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vmulhsu_vvMicro<uint8_t>;
template class Vmulhsu_vvMicro<uint16_t>;
template class Vmulhsu_vvMicro<uint32_t>;
template class Vmulhsu_vvMicro<uint64_t>;
;


// VectorIntFormat::vmulh_vv(['\n                        Vd_vi[i] = mulh<vi>(Vs2_vi[i], Vs1_vi[i]);\n                    ', 'OPMVV', 'SimdMultOp'],{})


template <typename ElemType>
Fault
Vmulh_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = mulh<vi>(Vs2[i], Vs1[i]);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vmulh_vvMicro<uint8_t>;
template class Vmulh_vvMicro<uint16_t>;
template class Vmulh_vvMicro<uint32_t>;
template class Vmulh_vvMicro<uint64_t>;
;


// VectorIntFormat::vmadd_vv(['\n                        Vd_vi[i] = Vs3_vi[i] * Vs1_vi[i] + Vs2_vi[i];\n                    ', 'OPMVV', 'SimdMultAccOp'],{})


template <typename ElemType>
Fault
Vmadd_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = Vs3[i] * Vs1[i] + Vs2[i];
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vmadd_vvMicro<uint8_t>;
template class Vmadd_vvMicro<uint16_t>;
template class Vmadd_vvMicro<uint32_t>;
template class Vmadd_vvMicro<uint64_t>;
;


// VectorIntFormat::vnmsub_vv(['\n                        Vd_vi[i] = -(Vs3_vi[i] * Vs1_vi[i]) + Vs2_vi[i];\n                    ', 'OPMVV', 'SimdMultAccOp'],{})


template <typename ElemType>
Fault
Vnmsub_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = -(Vs3[i] * Vs1[i]) + Vs2[i];
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vnmsub_vvMicro<uint8_t>;
template class Vnmsub_vvMicro<uint16_t>;
template class Vnmsub_vvMicro<uint32_t>;
template class Vnmsub_vvMicro<uint64_t>;
;


// VectorIntFormat::vmacc_vv(['\n                        Vd_vi[i] = Vs2_vi[i] * Vs1_vi[i] + Vs3_vi[i];\n                    ', 'OPMVV', 'SimdMultAccOp'],{})


template <typename ElemType>
Fault
Vmacc_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = Vs2[i] * Vs1[i] + Vs3[i];
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vmacc_vvMicro<uint8_t>;
template class Vmacc_vvMicro<uint16_t>;
template class Vmacc_vvMicro<uint32_t>;
template class Vmacc_vvMicro<uint64_t>;
;


// VectorIntFormat::vnmsac_vv(['\n                        Vd_vi[i] = -(Vs2_vi[i] * Vs1_vi[i]) + Vs3_vi[i];\n                    ', 'OPMVV', 'SimdMultAccOp'],{})


template <typename ElemType>
Fault
Vnmsac_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = -(Vs2[i] * Vs1[i]) + Vs3[i];
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vnmsac_vvMicro<uint8_t>;
template class Vnmsac_vvMicro<uint16_t>;
template class Vnmsac_vvMicro<uint32_t>;
template class Vnmsac_vvMicro<uint64_t>;
;


// VectorIntWideningFormat::vwaddu_vv(['\n                        Vd_vwu[i] = vwu(Vs2_vu[i + offset])\n                                + vwu(Vs1_vu[i + offset]);\n                    ', 'OPMVV', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vwaddu_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    using vwu [[maybe_unused]] = typename double_width<vu>::type;
    using vwi [[maybe_unused]] = typename double_width<vi>::type;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vd % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned Vd group in Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            const int64_t vs2_emul = vlmul + 0;
            if (((vs2_emul < 0) && (VS2 == VD)) ||
                ((vs2_emul >= 0) &&
                 (VS2 < VD + num_microops - (1 << vs2_emul)) &&
                 (VD < VS2 + (1 << vs2_emul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            if (((vlmul < 0) && (VS1 == VD)) ||
                ((vlmul >= 0) &&
                 (VS1 < VD + num_microops - (1 << vlmul)) &&
                 (VD < VS1 + (1 << vlmul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS1 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = vwu(Vs2[i + offset])
                                + vwu(Vs1[i + offset]);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vwaddu_vvMicro<uint8_t>;
template class Vwaddu_vvMicro<uint16_t>;
template class Vwaddu_vvMicro<uint32_t>;
;


// VectorIntWideningFormat::vwadd_vv(['\n                        Vd_vwi[i] = vwi(Vs2_vi[i + offset])\n                                + vwi(Vs1_vi[i + offset]);\n                    ', 'OPMVV', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vwadd_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    using vwu [[maybe_unused]] = typename double_width<vu>::type;
    using vwi [[maybe_unused]] = typename double_width<vi>::type;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vd % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned Vd group in Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            const int64_t vs2_emul = vlmul + 0;
            if (((vs2_emul < 0) && (VS2 == VD)) ||
                ((vs2_emul >= 0) &&
                 (VS2 < VD + num_microops - (1 << vs2_emul)) &&
                 (VD < VS2 + (1 << vs2_emul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            if (((vlmul < 0) && (VS1 == VD)) ||
                ((vlmul >= 0) &&
                 (VS1 < VD + num_microops - (1 << vlmul)) &&
                 (VD < VS1 + (1 << vlmul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS1 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = vwi(Vs2[i + offset])
                                + vwi(Vs1[i + offset]);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vwadd_vvMicro<uint8_t>;
template class Vwadd_vvMicro<uint16_t>;
template class Vwadd_vvMicro<uint32_t>;
;


// VectorIntWideningFormat::vwsubu_vv(['\n                        Vd_vwu[i] = vwu(Vs2_vu[i + offset])\n                                - vwu(Vs1_vu[i + offset]);\n                    ', 'OPMVV', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vwsubu_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    using vwu [[maybe_unused]] = typename double_width<vu>::type;
    using vwi [[maybe_unused]] = typename double_width<vi>::type;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vd % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned Vd group in Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            const int64_t vs2_emul = vlmul + 0;
            if (((vs2_emul < 0) && (VS2 == VD)) ||
                ((vs2_emul >= 0) &&
                 (VS2 < VD + num_microops - (1 << vs2_emul)) &&
                 (VD < VS2 + (1 << vs2_emul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            if (((vlmul < 0) && (VS1 == VD)) ||
                ((vlmul >= 0) &&
                 (VS1 < VD + num_microops - (1 << vlmul)) &&
                 (VD < VS1 + (1 << vlmul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS1 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = vwu(Vs2[i + offset])
                                - vwu(Vs1[i + offset]);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vwsubu_vvMicro<uint8_t>;
template class Vwsubu_vvMicro<uint16_t>;
template class Vwsubu_vvMicro<uint32_t>;
;


// VectorIntWideningFormat::vwsub_vv(['\n                        Vd_vwi[i] = vwi(Vs2_vi[i + offset])\n                                - vwi(Vs1_vi[i + offset]);\n                    ', 'OPMVV', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vwsub_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    using vwu [[maybe_unused]] = typename double_width<vu>::type;
    using vwi [[maybe_unused]] = typename double_width<vi>::type;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vd % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned Vd group in Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            const int64_t vs2_emul = vlmul + 0;
            if (((vs2_emul < 0) && (VS2 == VD)) ||
                ((vs2_emul >= 0) &&
                 (VS2 < VD + num_microops - (1 << vs2_emul)) &&
                 (VD < VS2 + (1 << vs2_emul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            if (((vlmul < 0) && (VS1 == VD)) ||
                ((vlmul >= 0) &&
                 (VS1 < VD + num_microops - (1 << vlmul)) &&
                 (VD < VS1 + (1 << vlmul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS1 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = vwi(Vs2[i + offset])
                                - vwi(Vs1[i + offset]);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vwsub_vvMicro<uint8_t>;
template class Vwsub_vvMicro<uint16_t>;
template class Vwsub_vvMicro<uint32_t>;
;


// VectorIntWideningFormat::vwaddu_wv(['\n                        Vd_vwu[i] = Vs2_vwu[i] + vwu(Vs1_vu[i + offset]);\n                    ', 'OPMVV', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vwaddu_wvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    using vwu [[maybe_unused]] = typename double_width<vu>::type;
    using vwi [[maybe_unused]] = typename double_width<vi>::type;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vwu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vd % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned Vd group in Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            if (((vlmul < 0) && (VS1 == VD)) ||
                ((vlmul >= 0) &&
                 (VS1 < VD + num_microops - (1 << vlmul)) &&
                 (VD < VS1 + (1 << vlmul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS1 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = Vs2[i] + vwu(Vs1[i + offset]);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vwaddu_wvMicro<uint8_t>;
template class Vwaddu_wvMicro<uint16_t>;
template class Vwaddu_wvMicro<uint32_t>;
;


// VectorIntWideningFormat::vwadd_wv(['\n                        Vd_vwi[i] = Vs2_vwi[i] + vwi(Vs1_vi[i + offset]);\n                    ', 'OPMVV', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vwadd_wvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    using vwu [[maybe_unused]] = typename double_width<vu>::type;
    using vwi [[maybe_unused]] = typename double_width<vi>::type;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vwi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vd % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned Vd group in Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            if (((vlmul < 0) && (VS1 == VD)) ||
                ((vlmul >= 0) &&
                 (VS1 < VD + num_microops - (1 << vlmul)) &&
                 (VD < VS1 + (1 << vlmul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS1 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = Vs2[i] + vwi(Vs1[i + offset]);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vwadd_wvMicro<uint8_t>;
template class Vwadd_wvMicro<uint16_t>;
template class Vwadd_wvMicro<uint32_t>;
;


// VectorIntWideningFormat::vwsubu_wv(['\n                        Vd_vwu[i] = Vs2_vwu[i] - vwu(Vs1_vu[i + offset]);\n                    ', 'OPMVV', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vwsubu_wvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    using vwu [[maybe_unused]] = typename double_width<vu>::type;
    using vwi [[maybe_unused]] = typename double_width<vi>::type;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vwu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vd % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned Vd group in Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            if (((vlmul < 0) && (VS1 == VD)) ||
                ((vlmul >= 0) &&
                 (VS1 < VD + num_microops - (1 << vlmul)) &&
                 (VD < VS1 + (1 << vlmul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS1 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = Vs2[i] - vwu(Vs1[i + offset]);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vwsubu_wvMicro<uint8_t>;
template class Vwsubu_wvMicro<uint16_t>;
template class Vwsubu_wvMicro<uint32_t>;
;


// VectorIntWideningFormat::vwsub_wv(['\n                        Vd_vwi[i] = Vs2_vwi[i] - vwi(Vs1_vi[i + offset]);\n                    ', 'OPMVV', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vwsub_wvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    using vwu [[maybe_unused]] = typename double_width<vu>::type;
    using vwi [[maybe_unused]] = typename double_width<vi>::type;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vwi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vd % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned Vd group in Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            if (((vlmul < 0) && (VS1 == VD)) ||
                ((vlmul >= 0) &&
                 (VS1 < VD + num_microops - (1 << vlmul)) &&
                 (VD < VS1 + (1 << vlmul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS1 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = Vs2[i] - vwi(Vs1[i + offset]);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vwsub_wvMicro<uint8_t>;
template class Vwsub_wvMicro<uint16_t>;
template class Vwsub_wvMicro<uint32_t>;
;


// VectorIntWideningFormat::vwmulu_vv(['\n                        Vd_vwu[i] = vwu(Vs2_vu[i + offset])\n                                * vwu(Vs1_vu[i + offset]);\n                    ', 'OPMVV', 'SimdMultOp'],{})


template <typename ElemType>
Fault
Vwmulu_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    using vwu [[maybe_unused]] = typename double_width<vu>::type;
    using vwi [[maybe_unused]] = typename double_width<vi>::type;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vd % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned Vd group in Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            const int64_t vs2_emul = vlmul + 0;
            if (((vs2_emul < 0) && (VS2 == VD)) ||
                ((vs2_emul >= 0) &&
                 (VS2 < VD + num_microops - (1 << vs2_emul)) &&
                 (VD < VS2 + (1 << vs2_emul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            if (((vlmul < 0) && (VS1 == VD)) ||
                ((vlmul >= 0) &&
                 (VS1 < VD + num_microops - (1 << vlmul)) &&
                 (VD < VS1 + (1 << vlmul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS1 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = vwu(Vs2[i + offset])
                                * vwu(Vs1[i + offset]);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vwmulu_vvMicro<uint8_t>;
template class Vwmulu_vvMicro<uint16_t>;
template class Vwmulu_vvMicro<uint32_t>;
;


// VectorIntWideningFormat::vwmulsu_vv(['\n                        Vd_vwi[i] = vwi(Vs2_vi[i + offset])\n                                * vwu(Vs1_vu[i + offset]);\n                    ', 'OPMVV', 'SimdMultOp'],{})


template <typename ElemType>
Fault
Vwmulsu_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    using vwu [[maybe_unused]] = typename double_width<vu>::type;
    using vwi [[maybe_unused]] = typename double_width<vi>::type;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vd % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned Vd group in Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            const int64_t vs2_emul = vlmul + 0;
            if (((vs2_emul < 0) && (VS2 == VD)) ||
                ((vs2_emul >= 0) &&
                 (VS2 < VD + num_microops - (1 << vs2_emul)) &&
                 (VD < VS2 + (1 << vs2_emul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            if (((vlmul < 0) && (VS1 == VD)) ||
                ((vlmul >= 0) &&
                 (VS1 < VD + num_microops - (1 << vlmul)) &&
                 (VD < VS1 + (1 << vlmul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS1 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = vwi(Vs2[i + offset])
                                * vwu(Vs1[i + offset]);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vwmulsu_vvMicro<uint8_t>;
template class Vwmulsu_vvMicro<uint16_t>;
template class Vwmulsu_vvMicro<uint32_t>;
;


// VectorIntWideningFormat::vwmul_vv(['\n                        Vd_vwi[i] = vwi(Vs2_vi[i + offset])\n                                * vwi(Vs1_vi[i + offset]);\n                    ', 'OPMVV', 'SimdMultOp'],{})


template <typename ElemType>
Fault
Vwmul_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    using vwu [[maybe_unused]] = typename double_width<vu>::type;
    using vwi [[maybe_unused]] = typename double_width<vi>::type;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vd % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned Vd group in Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            const int64_t vs2_emul = vlmul + 0;
            if (((vs2_emul < 0) && (VS2 == VD)) ||
                ((vs2_emul >= 0) &&
                 (VS2 < VD + num_microops - (1 << vs2_emul)) &&
                 (VD < VS2 + (1 << vs2_emul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            if (((vlmul < 0) && (VS1 == VD)) ||
                ((vlmul >= 0) &&
                 (VS1 < VD + num_microops - (1 << vlmul)) &&
                 (VD < VS1 + (1 << vlmul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS1 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = vwi(Vs2[i + offset])
                                * vwi(Vs1[i + offset]);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vwmul_vvMicro<uint8_t>;
template class Vwmul_vvMicro<uint16_t>;
template class Vwmul_vvMicro<uint32_t>;
;


// VectorIntWideningFormat::vwmaccu_vv(['\n                        Vd_vwu[i] = vwu(Vs1_vu[i + offset])\n                                * vwu(Vs2_vu[i + offset])\n                                + Vs3_vwu[i];\n                    ', 'OPMVV', 'SimdMultAccOp'],{})


template <typename ElemType>
Fault
Vwmaccu_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    using vwu [[maybe_unused]] = typename double_width<vu>::type;
    using vwi [[maybe_unused]] = typename double_width<vi>::type;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vwu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vd % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned Vd group in Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            const int64_t vs2_emul = vlmul + 0;
            if (((vs2_emul < 0) && (VS2 == VD)) ||
                ((vs2_emul >= 0) &&
                 (VS2 < VD + num_microops - (1 << vs2_emul)) &&
                 (VD < VS2 + (1 << vs2_emul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            if (((vlmul < 0) && (VS1 == VD)) ||
                ((vlmul >= 0) &&
                 (VS1 < VD + num_microops - (1 << vlmul)) &&
                 (VD < VS1 + (1 << vlmul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS1 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = vwu(Vs1[i + offset])
                                * vwu(Vs2[i + offset])
                                + Vs3[i];
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vwmaccu_vvMicro<uint8_t>;
template class Vwmaccu_vvMicro<uint16_t>;
template class Vwmaccu_vvMicro<uint32_t>;
;


// VectorIntWideningFormat::vwmacc_vv(['\n                        Vd_vwi[i] = vwi(Vs1_vi[i + offset])\n                                * vwi(Vs2_vi[i + offset])\n                                + Vs3_vwi[i];\n                    ', 'OPMVV', 'SimdMultAccOp'],{})


template <typename ElemType>
Fault
Vwmacc_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    using vwu [[maybe_unused]] = typename double_width<vu>::type;
    using vwi [[maybe_unused]] = typename double_width<vi>::type;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vwi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vd % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned Vd group in Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            const int64_t vs2_emul = vlmul + 0;
            if (((vs2_emul < 0) && (VS2 == VD)) ||
                ((vs2_emul >= 0) &&
                 (VS2 < VD + num_microops - (1 << vs2_emul)) &&
                 (VD < VS2 + (1 << vs2_emul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            if (((vlmul < 0) && (VS1 == VD)) ||
                ((vlmul >= 0) &&
                 (VS1 < VD + num_microops - (1 << vlmul)) &&
                 (VD < VS1 + (1 << vlmul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS1 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = vwi(Vs1[i + offset])
                                * vwi(Vs2[i + offset])
                                + Vs3[i];
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vwmacc_vvMicro<uint8_t>;
template class Vwmacc_vvMicro<uint16_t>;
template class Vwmacc_vvMicro<uint32_t>;
;


// VectorIntWideningFormat::vwmaccsu_vv(['\n                        Vd_vwi[i] = vwi(Vs1_vi[i + offset])\n                                * vwu(Vs2_vu[i + offset])\n                                + Vs3_vwi[i];\n                    ', 'OPMVV', 'SimdMultAccOp'],{})


template <typename ElemType>
Fault
Vwmaccsu_vvMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    using vwu [[maybe_unused]] = typename double_width<vu>::type;
    using vwi [[maybe_unused]] = typename double_width<vi>::type;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    	/* Vars for Vs1*/	/* End vars for Vs1 */
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs1 = tmp_s0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vwi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vd % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned Vd group in Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            const int64_t vs2_emul = vlmul + 0;
            if (((vs2_emul < 0) && (VS2 == VD)) ||
                ((vs2_emul >= 0) &&
                 (VS2 < VD + num_microops - (1 << vs2_emul)) &&
                 (VD < VS2 + (1 << vs2_emul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            if (((vlmul < 0) && (VS1 == VD)) ||
                ((vlmul >= 0) &&
                 (VS1 < VD + num_microops - (1 << vlmul)) &&
                 (VD < VS1 + (1 << vlmul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS1 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = vwi(Vs1[i + offset])
                                * vwu(Vs2[i + offset])
                                + Vs3[i];
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vwmaccsu_vvMicro<uint8_t>;
template class Vwmaccsu_vvMicro<uint16_t>;
template class Vwmaccsu_vvMicro<uint32_t>;
;


// Unknown::unknown(([], {}))

// VectorIntFormat::vadd_vi(['\n                        Vd_vi[i] = Vs2_vi[i] + (vi)sext<5>(SIMM5);\n                    ', 'OPIVI', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vadd_viMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(1);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = Vs2[i] + (vi)sext<5>(SIMM5);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vadd_viMicro<uint8_t>;
template class Vadd_viMicro<uint16_t>;
template class Vadd_viMicro<uint32_t>;
template class Vadd_viMicro<uint64_t>;
;


// VectorIntFormat::vrsub_vi(['\n                        Vd_vi[i] = (vi)sext<5>(SIMM5) - Vs2_vi[i];\n                    ', 'OPIVI', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vrsub_viMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(1);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = (vi)sext<5>(SIMM5) - Vs2[i];
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vrsub_viMicro<uint8_t>;
template class Vrsub_viMicro<uint16_t>;
template class Vrsub_viMicro<uint32_t>;
template class Vrsub_viMicro<uint64_t>;
;


// VectorIntFormat::vand_vi(['\n                        Vd_vi[i] = Vs2_vi[i] & (vi)sext<5>(SIMM5);\n                    ', 'OPIVI', 'SimdAluOp'],{})


template <typename ElemType>
Fault
Vand_viMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(1);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = Vs2[i] & (vi)sext<5>(SIMM5);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vand_viMicro<uint8_t>;
template class Vand_viMicro<uint16_t>;
template class Vand_viMicro<uint32_t>;
template class Vand_viMicro<uint64_t>;
;


// VectorIntFormat::vor_vi(['\n                        Vd_vi[i] = Vs2_vi[i] | (vi)sext<5>(SIMM5);\n                    ', 'OPIVI', 'SimdAluOp'],{})


template <typename ElemType>
Fault
Vor_viMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(1);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = Vs2[i] | (vi)sext<5>(SIMM5);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vor_viMicro<uint8_t>;
template class Vor_viMicro<uint16_t>;
template class Vor_viMicro<uint32_t>;
template class Vor_viMicro<uint64_t>;
;


// VectorIntFormat::vxor_vi(['\n                        Vd_vi[i] = Vs2_vi[i] ^ (vi)sext<5>(SIMM5);\n                    ', 'OPIVI', 'SimdAluOp'],{})


template <typename ElemType>
Fault
Vxor_viMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(1);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = Vs2[i] ^ (vi)sext<5>(SIMM5);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vxor_viMicro<uint8_t>;
template class Vxor_viMicro<uint16_t>;
template class Vxor_viMicro<uint32_t>;
template class Vxor_viMicro<uint64_t>;
;


// VectorGatherFormat::vrgather_vi((['\n                    for (uint32_t i = 0; i < microVl; i++) {\n                        uint32_t ei = i + vs1_idx * vs1_elems + vs1_bias;\n                        uint64_t zextImm = rvZext(SIMM5);\n                        if (this->vm || elem_mask(v0, ei)) {\n                            const uint64_t idx = zextImm - vs2_elems * vs2_idx;\n                            if (zextImm >= vlmax)\n                                Vd_vu[i] = 0;\n                            else if (idx < vs2_elems)\n                                Vd_vu[i] = Vs2_vu[idx];\n                        }\n                    }\n                ', 'OPIVI', 'SimdMiscOp'], {}))


template <typename ElemType, typename IndexType>
Fault
Vrgather_viMicro<ElemType, IndexType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    const uint32_t vlmax = vtype_VLMAX(vtype,vlen);
    constexpr uint32_t vd_eewb = sizeof(ElemType);
    constexpr uint32_t vs1_eewb = sizeof(IndexType);
    constexpr uint32_t vs2_eewb = sizeof(ElemType);
    constexpr uint32_t vs1_split_num = (vd_eewb + vs1_eewb - 1) / vs1_eewb;
    constexpr uint32_t vd_split_num = (vs1_eewb + vd_eewb - 1) / vd_eewb;
    [[maybe_unused]] const uint32_t vd_elems = vlenb / vd_eewb;
    [[maybe_unused]] const uint32_t vs1_elems = vlenb / vs1_eewb;
    [[maybe_unused]] const uint32_t vs2_elems = vlenb / vs2_eewb;
    [[maybe_unused]] const int8_t lmul = vtype_vlmul(vtype);
    [[maybe_unused]] const uint8_t vs2_vregs = lmul < 0 ? 1 : 1 << lmul;
    [[maybe_unused]] const uint32_t vs2_idx = microIdx % vs2_vregs;
    [[maybe_unused]] const uint32_t vs1_idx =
        microIdx / vs2_vregs / vs1_split_num;
    [[maybe_unused]] const uint32_t vd_idx =
        microIdx / vs2_vregs / vd_split_num;
    [[maybe_unused]] const uint32_t vs1_bias =
        vs1_elems * (vd_idx % vs1_split_num) / vs1_split_num;
    [[maybe_unused]] const uint32_t vd_bias =
        vd_elems * (vs1_idx % vd_split_num) / vd_split_num;


    
                    for (uint32_t i = 0; i < microVl; i++) {
                        uint32_t ei = i + vs1_idx * vs1_elems + vs1_bias;
                        uint64_t zextImm = rvZext(SIMM5);
                        if (this->vm || elem_mask(v0, ei)) {
                            const uint64_t idx = zextImm - vs2_elems * vs2_idx;
                            if (zextImm >= vlmax)
                                Vd[i] = 0;
                            else if (idx < vs2_elems)
                                Vd[i] = Vs2[idx];
                        }
                    }
                ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vrgather_viMicro<uint8_t, uint8_t>;
template class Vrgather_viMicro<uint16_t, uint16_t>;
template class Vrgather_viMicro<uint32_t, uint32_t>;
template class Vrgather_viMicro<uint64_t, uint64_t>;
;


// VectorSlideUpFormat::vslideup_vi((['\n                    const int offset = (int)(uint64_t)(SIMM5);\n                    const int microVlmax = vtype_VLMAX(machInst.vtype8,\n                        vlen, true);\n                    const int vregOffset = vdIdx - vs2Idx;\n                    const int offsetInVreg = offset - vregOffset * microVlmax;\n                    if (std::abs(offsetInVreg) < uint32_t(microVlmax)) {\n                        const int upperBound = (offsetInVreg >= 0)\n                            ? microVlmax - offsetInVreg\n                            : microVlmax + offsetInVreg;\n                        const int vdOffset = (offsetInVreg >= 0)\n                            ? offsetInVreg\n                            : 0;\n                        const int vs2Offset = (offsetInVreg >= 0)\n                            ? 0\n                            : -offsetInVreg;\n                        const int elemOffset = vdOffset + vdIdx * microVlmax;\n                        for (int i = 0;\n                            i < upperBound && i + vdOffset < microVl;\n                            i++) {\n                            if (this->vm || elem_mask(v0, i + elemOffset)) {\n                                Vd_vu[i + vdOffset] = Vs2_vu[i + vs2Offset];\n                            }\n                        }\n                    }\n                ', 'OPIVI', 'SimdMiscOp'], {}))


template<typename ElemType>
Fault
Vslideup_viMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    [[maybe_unused]]const uint32_t vlmax = vtype_VLMAX(vtype, vlen);

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    
                    const int offset = (int)(uint64_t)(SIMM5);
                    const int microVlmax = vtype_VLMAX(machInst.vtype8,
                        vlen, true);
                    const int vregOffset = vdIdx - vs2Idx;
                    const int offsetInVreg = offset - vregOffset * microVlmax;
                    if (std::abs(offsetInVreg) < uint32_t(microVlmax)) {
                        const int upperBound = (offsetInVreg >= 0)
                            ? microVlmax - offsetInVreg
                            : microVlmax + offsetInVreg;
                        const int vdOffset = (offsetInVreg >= 0)
                            ? offsetInVreg
                            : 0;
                        const int vs2Offset = (offsetInVreg >= 0)
                            ? 0
                            : -offsetInVreg;
                        const int elemOffset = vdOffset + vdIdx * microVlmax;
                        for (int i = 0;
                            i < upperBound && i + vdOffset < microVl;
                            i++) {
                            if (this->vm || elem_mask(v0, i + elemOffset)) {
                                Vd[i + vdOffset] = Vs2[i + vs2Offset];
                            }
                        }
                    }
                ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
};

template class Vslideup_viMicro<uint8_t>;
template class Vslideup_viMicro<uint16_t>;
template class Vslideup_viMicro<uint32_t>;
template class Vslideup_viMicro<uint64_t>;
;


// VectorSlideDownFormat::vslidedown_vi((['\n                    const int offset = (int)(uint64_t)(SIMM5);\n                    const int microVlmax = vtype_VLMAX(machInst.vtype8,\n                        vlen, true);\n                    const int vregOffset = vs2Idx - vdIdx;\n                    const int offsetInVreg = offset - vregOffset * microVlmax;\n                    const int numVs2s = vtype_regs_per_group(vtype);\n                    if (std::abs(offsetInVreg) < uint32_t(microVlmax)) {\n                        const bool needZeroTail = numVs2s == vs2Idx + 1;\n                        const int upperBound = (offsetInVreg >= 0)\n                            ? microVlmax - offsetInVreg\n                            : microVlmax + offsetInVreg;\n                        const int vdOffset = (offsetInVreg >= 0)\n                            ? 0\n                            : -offsetInVreg;\n                        const int vs2Offset = (offsetInVreg >= 0)\n                            ? offsetInVreg\n                            : 0;\n                        const int elemIdxBase = vdIdx * microVlmax;\n                        vreg_t resVreg;\n                        auto res = resVreg.as<vu>();\n                        for (int i = 0;\n                            i < upperBound && i + vdOffset < microVl;\n                            i++) {\n                            res[i + vdOffset] = Vs2_vu[i + vs2Offset];\n                        }\n                        if (needZeroTail) {\n                            for (int i = upperBound + vdOffset;\n                                i < microVlmax; i++) {\n                                res[i] = 0;\n                            }\n                        }\n                        for (int i = vdOffset; i < microVl ; i++) {\n                            if (vm || elem_mask(v0, i + elemIdxBase)) {\n                                Vd_vu[i] = res[i];\n                            }\n                        }\n                    }\n                ', 'OPIVI', 'SimdMiscOp'], {}))


template<typename ElemType>
Fault
Vslidedown_viMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    [[maybe_unused]]const uint32_t vlmax = vtype_VLMAX(vtype, vlen);

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    
                    const int offset = (int)(uint64_t)(SIMM5);
                    const int microVlmax = vtype_VLMAX(machInst.vtype8,
                        vlen, true);
                    const int vregOffset = vs2Idx - vdIdx;
                    const int offsetInVreg = offset - vregOffset * microVlmax;
                    const int numVs2s = vtype_regs_per_group(vtype);
                    if (std::abs(offsetInVreg) < uint32_t(microVlmax)) {
                        const bool needZeroTail = numVs2s == vs2Idx + 1;
                        const int upperBound = (offsetInVreg >= 0)
                            ? microVlmax - offsetInVreg
                            : microVlmax + offsetInVreg;
                        const int vdOffset = (offsetInVreg >= 0)
                            ? 0
                            : -offsetInVreg;
                        const int vs2Offset = (offsetInVreg >= 0)
                            ? offsetInVreg
                            : 0;
                        const int elemIdxBase = vdIdx * microVlmax;
                        vreg_t resVreg;
                        auto res = resVreg.as<vu>();
                        for (int i = 0;
                            i < upperBound && i + vdOffset < microVl;
                            i++) {
                            res[i + vdOffset] = Vs2[i + vs2Offset];
                        }
                        if (needZeroTail) {
                            for (int i = upperBound + vdOffset;
                                i < microVlmax; i++) {
                                res[i] = 0;
                            }
                        }
                        for (int i = vdOffset; i < microVl ; i++) {
                            if (vm || elem_mask(v0, i + elemIdxBase)) {
                                Vd[i] = res[i];
                            }
                        }
                    }
                ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
};

template class Vslidedown_viMicro<uint8_t>;
template class Vslidedown_viMicro<uint16_t>;
template class Vslidedown_viMicro<uint32_t>;
template class Vslidedown_viMicro<uint64_t>;
;


// VectorIntFormat::vadc_vim(['\n                            Vd_vi[i] = Vs2_vi[i] +\n                                (vi)sext<5>(SIMM5) + elem_mask(v0, ei);\n                        ', 'OPIVI', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vadc_vimMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(1);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            
                            Vd[i] = Vs2[i] +
                                (vi)sext<5>(SIMM5) + elem_mask(v0, ei);
                        
            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vadc_vimMicro<uint8_t>;
template class Vadc_vimMicro<uint16_t>;
template class Vadc_vimMicro<uint32_t>;
template class Vadc_vimMicro<uint64_t>;
;


// Unknown::unknown(([], {}))

// VectorIntFormat::vmerge_vim(['\n                            Vd_vi[i] = elem_mask(v0, ei)\n                                    ? (vi)sext<5>(SIMM5)\n                                    : Vs2_vi[i];\n                        ', 'OPIVI', 'SimdMiscOp'],{})


template <typename ElemType>
Fault
Vmerge_vimMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(1);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            
                            Vd[i] = elem_mask(v0, ei)
                                    ? (vi)sext<5>(SIMM5)
                                    : Vs2[i];
                        
            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vmerge_vimMicro<uint8_t>;
template class Vmerge_vimMicro<uint16_t>;
template class Vmerge_vimMicro<uint32_t>;
template class Vmerge_vimMicro<uint64_t>;
;


// VectorIntFormat::vmv_v_i(['\n                            Vd_vi[i] = (vi)sext<5>(SIMM5);\n                        ', 'OPIVI', 'SimdMiscOp'],{})


template <typename ElemType>
Fault
Vmv_v_iMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    ;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    ;
    COPY_OLD_VD(1);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
                            Vd[i] = (vi)sext<5>(SIMM5);
                        
            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vmv_v_iMicro<uint8_t>;
template class Vmv_v_iMicro<uint16_t>;
template class Vmv_v_iMicro<uint32_t>;
template class Vmv_v_iMicro<uint64_t>;
;


// Unknown::unknown(([], {}))

// VectorIntVxsatFormat::vsaddu_vi(['\n                        Vd_vu[i] = sat_addu<vu>(Vs2_vu[i], (vu)sext<5>(SIMM5),\n                            vxsatptr);\n                    ', 'OPIVI', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vsaddu_viMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(1);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = sat_addu<vu>(Vs2[i], (vu)sext<5>(SIMM5),
                            vxsatptr);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vsaddu_viMicro<uint8_t>;
template class Vsaddu_viMicro<uint16_t>;
template class Vsaddu_viMicro<uint32_t>;
template class Vsaddu_viMicro<uint64_t>;
;


// VectorIntVxsatFormat::vsadd_vi(['\n                        Vd_vi[i] = sat_add<vi>(Vs2_vi[i], (vi)sext<5>(SIMM5),\n                            vxsatptr);\n                    ', 'OPIVI', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vsadd_viMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(1);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = sat_add<vi>(Vs2[i], (vi)sext<5>(SIMM5),
                            vxsatptr);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vsadd_viMicro<uint8_t>;
template class Vsadd_viMicro<uint16_t>;
template class Vsadd_viMicro<uint32_t>;
template class Vsadd_viMicro<uint64_t>;
;


// VectorIntFormat::vsll_vi(['\n                        Vd_vu[i] = Vs2_vu[i] << ((vu)SIMM5 & (sew - 1) & 0x1f);\n                    ', 'OPIVI', 'SimdShiftOp'],{})


template <typename ElemType>
Fault
Vsll_viMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(1);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = Vs2[i] << ((vu)SIMM5 & (sew - 1) & 0x1f);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vsll_viMicro<uint8_t>;
template class Vsll_viMicro<uint16_t>;
template class Vsll_viMicro<uint32_t>;
template class Vsll_viMicro<uint64_t>;
;


// VectorIntFormat::vsrl_vi(['\n                        Vd_vu[i] = Vs2_vu[i] >> ((vu)SIMM5 & (sew - 1) & 0x1f);\n                    ', 'OPIVI', 'SimdShiftOp'],{})


template <typename ElemType>
Fault
Vsrl_viMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(1);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = Vs2[i] >> ((vu)SIMM5 & (sew - 1) & 0x1f);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vsrl_viMicro<uint8_t>;
template class Vsrl_viMicro<uint16_t>;
template class Vsrl_viMicro<uint32_t>;
template class Vsrl_viMicro<uint64_t>;
;


// VectorIntFormat::vssrl_vi(['\n                        int sh = SIMM5 & (vtype_SEW(vtype) - 1);\n                        __uint128_t res = Vs2_vu[i];\n\n                        res = int_rounding<__uint128_t>(\n                            res, 0 /* TODO */, sh) >> sh;\n\n                        Vd_vu[i] = res;\n                    ', 'OPIVI', 'SimdShiftOp'],{})


template <typename ElemType>
Fault
Vssrl_viMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(1);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        int sh = SIMM5 & (vtype_SEW(vtype) - 1);
                        __uint128_t res = Vs2[i];

                        res = int_rounding<__uint128_t>(
                            res, 0 /* TODO */, sh) >> sh;

                        Vd[i] = res;
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vssrl_viMicro<uint8_t>;
template class Vssrl_viMicro<uint16_t>;
template class Vssrl_viMicro<uint32_t>;
template class Vssrl_viMicro<uint64_t>;
;


// VectorIntFormat::vsra_vi(['\n                        Vd_vi[i] = Vs2_vi[i] >> ((vu)SIMM5 & (sew - 1) & 0x1f);\n                    ', 'OPIVI', 'SimdShiftOp'],{})


template <typename ElemType>
Fault
Vsra_viMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(1);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = Vs2[i] >> ((vu)SIMM5 & (sew - 1) & 0x1f);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vsra_viMicro<uint8_t>;
template class Vsra_viMicro<uint16_t>;
template class Vsra_viMicro<uint32_t>;
template class Vsra_viMicro<uint64_t>;
;


// VectorIntFormat::vssra_vi(['\n                        int sh = SIMM5 & (sew - 1);\n                        __int128_t val = Vs2_vi[i];\n\n                        val = int_rounding<__int128_t>(val,\n                            xc->readMiscReg(MISCREG_VXRM), sh);\n                        Vd_vi[i] = val >> sh;\n                    ', 'OPIVI', 'SimdShiftOp'],{})


template <typename ElemType>
Fault
Vssra_viMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(1);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        int sh = SIMM5 & (sew - 1);
                        __int128_t val = Vs2[i];

                        val = int_rounding<__int128_t>(val,
                            xc->readMiscReg(MISCREG_VXRM), sh);
                        Vd[i] = val >> sh;
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vssra_viMicro<uint8_t>;
template class Vssra_viMicro<uint16_t>;
template class Vssra_viMicro<uint32_t>;
template class Vssra_viMicro<uint64_t>;
;


// VMvWholeFormat::vmv1r_v(['\n                            Vd_ud[i] = Vs2_ud[i];\n                        ', 'OPIVI', 'SimdMiscOp'],{})


Fault
Vmv1r_vMicro::execute(ExecContext* xc, trace::InstRecord* traceData) const
{
    // TODO: Check register alignment.
    // TODO: If vd is equal to vs2 the instruction is an architectural NOP.
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);

    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint64_t>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<uint64_t>();
;
    for (size_t i = 0; i < (vlen / 64); i++) {
        
                            Vd[i] = Vs2[i];
                        ;
    }
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// VMvWholeFormat::vmv2r_v(['\n                            Vd_ud[i] = Vs2_ud[i];\n                        ', 'OPIVI', 'SimdMiscOp'],{})


Fault
Vmv2r_vMicro::execute(ExecContext* xc, trace::InstRecord* traceData) const
{
    // TODO: Check register alignment.
    // TODO: If vd is equal to vs2 the instruction is an architectural NOP.
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);

    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint64_t>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<uint64_t>();
;
    for (size_t i = 0; i < (vlen / 64); i++) {
        
                            Vd[i] = Vs2[i];
                        ;
    }
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// VMvWholeFormat::vmv4r_v(['\n                            Vd_ud[i] = Vs2_ud[i];\n                        ', 'OPIVI', 'SimdMiscOp'],{})


Fault
Vmv4r_vMicro::execute(ExecContext* xc, trace::InstRecord* traceData) const
{
    // TODO: Check register alignment.
    // TODO: If vd is equal to vs2 the instruction is an architectural NOP.
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);

    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint64_t>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<uint64_t>();
;
    for (size_t i = 0; i < (vlen / 64); i++) {
        
                            Vd[i] = Vs2[i];
                        ;
    }
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// VMvWholeFormat::vmv8r_v(['\n                            Vd_ud[i] = Vs2_ud[i];\n                        ', 'OPIVI', 'SimdMiscOp'],{})


Fault
Vmv8r_vMicro::execute(ExecContext* xc, trace::InstRecord* traceData) const
{
    // TODO: Check register alignment.
    // TODO: If vd is equal to vs2 the instruction is an architectural NOP.
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);

    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint64_t>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<uint64_t>();
;
    for (size_t i = 0; i < (vlen / 64); i++) {
        
                            Vd[i] = Vs2[i];
                        ;
    }
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}


// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// VectorIntMaskFormat::vmadc_vim(['\n                            Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                                carry_out(Vs2_vi[i], (vi)sext<5>(SIMM5),\n                                    elem_mask(v0, ei)));\n                        ', 'OPIVI', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vmadc_vimMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;

    const uint32_t bit_offset = vlenb / sizeof(ElemType);
    const uint32_t offset = bit_offset * microIdx;

    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            
                            Vd[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,
                                carry_out(Vs2[i], (vi)sext<5>(SIMM5),
                                    elem_mask(v0, ei)));
                        
            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vmadc_vimMicro<uint8_t>;
template class Vmadc_vimMicro<uint16_t>;
template class Vmadc_vimMicro<uint32_t>;
template class Vmadc_vimMicro<uint64_t>;
;


// VectorIntMaskFormat::vmadc_vi(['\n                            Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                                carry_out(Vs2_vi[i], (vi)sext<5>(SIMM5)));\n                        ', 'OPIVI', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vmadc_viMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    ;

    const uint32_t bit_offset = vlenb / sizeof(ElemType);
    const uint32_t offset = bit_offset * microIdx;

    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
                            Vd[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,
                                carry_out(Vs2[i], (vi)sext<5>(SIMM5)));
                        
            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vmadc_viMicro<uint8_t>;
template class Vmadc_viMicro<uint16_t>;
template class Vmadc_viMicro<uint32_t>;
template class Vmadc_viMicro<uint64_t>;
;


// Unknown::unknown(([], {}))

// VectorIntMaskFormat::vmseq_vi(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            (Vs2_vi[i] == (vi)sext<5>(SIMM5)));\n                    ', 'OPIVI', 'SimdCmpOp'],{})


template <typename ElemType>
Fault
Vmseq_viMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;

    const uint32_t bit_offset = vlenb / sizeof(ElemType);
    const uint32_t offset = bit_offset * microIdx;

    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,
                            (Vs2[i] == (vi)sext<5>(SIMM5)));
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vmseq_viMicro<uint8_t>;
template class Vmseq_viMicro<uint16_t>;
template class Vmseq_viMicro<uint32_t>;
template class Vmseq_viMicro<uint64_t>;
;


// VectorIntMaskFormat::vmsne_vi(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            (Vs2_vi[i] != (vi)sext<5>(SIMM5)));\n                    ', 'OPIVI', 'SimdCmpOp'],{})


template <typename ElemType>
Fault
Vmsne_viMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;

    const uint32_t bit_offset = vlenb / sizeof(ElemType);
    const uint32_t offset = bit_offset * microIdx;

    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,
                            (Vs2[i] != (vi)sext<5>(SIMM5)));
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vmsne_viMicro<uint8_t>;
template class Vmsne_viMicro<uint16_t>;
template class Vmsne_viMicro<uint32_t>;
template class Vmsne_viMicro<uint64_t>;
;


// VectorIntMaskFormat::vmsleu_vi(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            (Vs2_vu[i] <= (vu)sext<5>(SIMM5)));\n                    ', 'OPIVI', 'SimdCmpOp'],{})


template <typename ElemType>
Fault
Vmsleu_viMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;

    const uint32_t bit_offset = vlenb / sizeof(ElemType);
    const uint32_t offset = bit_offset * microIdx;

    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,
                            (Vs2[i] <= (vu)sext<5>(SIMM5)));
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vmsleu_viMicro<uint8_t>;
template class Vmsleu_viMicro<uint16_t>;
template class Vmsleu_viMicro<uint32_t>;
template class Vmsleu_viMicro<uint64_t>;
;


// VectorIntMaskFormat::vmsle_vi(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            (Vs2_vi[i] <= (vi)sext<5>(SIMM5)));\n                    ', 'OPIVI', 'SimdCmpOp'],{})


template <typename ElemType>
Fault
Vmsle_viMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;

    const uint32_t bit_offset = vlenb / sizeof(ElemType);
    const uint32_t offset = bit_offset * microIdx;

    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,
                            (Vs2[i] <= (vi)sext<5>(SIMM5)));
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vmsle_viMicro<uint8_t>;
template class Vmsle_viMicro<uint16_t>;
template class Vmsle_viMicro<uint32_t>;
template class Vmsle_viMicro<uint64_t>;
;


// VectorIntMaskFormat::vmsgtu_vi(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            (Vs2_vu[i] > (vu)sext<5>(SIMM5)));\n                    ', 'OPIVI', 'SimdCmpOp'],{})


template <typename ElemType>
Fault
Vmsgtu_viMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;

    const uint32_t bit_offset = vlenb / sizeof(ElemType);
    const uint32_t offset = bit_offset * microIdx;

    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,
                            (Vs2[i] > (vu)sext<5>(SIMM5)));
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vmsgtu_viMicro<uint8_t>;
template class Vmsgtu_viMicro<uint16_t>;
template class Vmsgtu_viMicro<uint32_t>;
template class Vmsgtu_viMicro<uint64_t>;
;


// VectorIntMaskFormat::vmsgt_vi(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            (Vs2_vi[i] > (vi)sext<5>(SIMM5)));\n                    ', 'OPIVI', 'SimdCmpOp'],{})


template <typename ElemType>
Fault
Vmsgt_viMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;

    const uint32_t bit_offset = vlenb / sizeof(ElemType);
    const uint32_t offset = bit_offset * microIdx;

    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,
                            (Vs2[i] > (vi)sext<5>(SIMM5)));
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vmsgt_viMicro<uint8_t>;
template class Vmsgt_viMicro<uint16_t>;
template class Vmsgt_viMicro<uint32_t>;
template class Vmsgt_viMicro<uint64_t>;
;


// VectorIntNarrowingFormat::vnsrl_wi(['\n                        Vd_vu[i + offset] = (vu)(Vs2_vwu[i] >>\n                                            ((vwu)SIMM5 & (sew * 2 - 1)));\n                    ', 'OPIVI', 'SimdShiftOp'],{})


template <typename ElemType>
Fault
Vnsrl_wiMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    using vwu [[maybe_unused]] = typename double_width<vu>::type;
    using vwi [[maybe_unused]] = typename double_width<vi>::type;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vwu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(1);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vs2 % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned VS2 group in Narrowing op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
        
            if ((VS2 < VD) &&
                (VD <= (VS2 + num_microops - 1))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is smaller than
                // the source EEW and the overlap is in the lowest-numbered
                // part of the source register group
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Narrowing op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i + offset] = (vu)(Vs2[i] >>
                                            ((vwu)SIMM5 & (sew * 2 - 1)));
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vnsrl_wiMicro<uint8_t>;
template class Vnsrl_wiMicro<uint16_t>;
template class Vnsrl_wiMicro<uint32_t>;
;


// VectorIntNarrowingFormat::vnsra_wi(['\n                        Vd_vi[i + offset] = (vi)(Vs2_vwi[i] >>\n                                            ((vwu)SIMM5 & (sew * 2 - 1)));\n                    ', 'OPIVI', 'SimdShiftOp'],{})


template <typename ElemType>
Fault
Vnsra_wiMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    using vwu [[maybe_unused]] = typename double_width<vu>::type;
    using vwi [[maybe_unused]] = typename double_width<vi>::type;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vwi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(1);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vs2 % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned VS2 group in Narrowing op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
        
            if ((VS2 < VD) &&
                (VD <= (VS2 + num_microops - 1))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is smaller than
                // the source EEW and the overlap is in the lowest-numbered
                // part of the source register group
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Narrowing op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i + offset] = (vi)(Vs2[i] >>
                                            ((vwu)SIMM5 & (sew * 2 - 1)));
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vnsra_wiMicro<uint8_t>;
template class Vnsra_wiMicro<uint16_t>;
template class Vnsra_wiMicro<uint32_t>;
;


// VectorIntNarrowingFormat::vnclipu_wi(['\n                        vu max = std::numeric_limits<vu>::max();\n                        uint64_t sign_mask =\n                            std::numeric_limits<uint64_t>::max() << sew;\n                        __uint128_t res = Vs2_vwu[i];\n                        unsigned shift = VS1 & ((sew * 2) - 1);\n\n                        res = int_rounding<__uint128_t>(\n                            res, 0 /* TODO */, shift) >> shift;\n\n                        if (res & sign_mask) {\n                            // TODO: vxsat\n                            res = max;\n                        }\n\n                        Vd_vu[i + offset] = (vu)res;\n                    ', 'OPIVI', 'SimdCvtOp'],{})


template <typename ElemType>
Fault
Vnclipu_wiMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    using vwu [[maybe_unused]] = typename double_width<vu>::type;
    using vwi [[maybe_unused]] = typename double_width<vi>::type;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vwu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(1);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vs2 % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned VS2 group in Narrowing op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
        
            if ((VS2 < VD) &&
                (VD <= (VS2 + num_microops - 1))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is smaller than
                // the source EEW and the overlap is in the lowest-numbered
                // part of the source register group
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Narrowing op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        vu max = std::numeric_limits<vu>::max();
                        uint64_t sign_mask =
                            std::numeric_limits<uint64_t>::max() << sew;
                        __uint128_t res = Vs2[i];
                        unsigned shift = VS1 & ((sew * 2) - 1);

                        res = int_rounding<__uint128_t>(
                            res, 0 /* TODO */, shift) >> shift;

                        if (res & sign_mask) {
                            // TODO: vxsat
                            res = max;
                        }

                        Vd[i + offset] = (vu)res;
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vnclipu_wiMicro<uint8_t>;
template class Vnclipu_wiMicro<uint16_t>;
template class Vnclipu_wiMicro<uint32_t>;
;


// VectorIntNarrowingFormat::vnclip_wi(['\n                        vi max = std::numeric_limits<vi>::max();\n                        vi min = std::numeric_limits<vi>::min();\n                        __int128_t res = Vs2_vwi[i];\n                        unsigned shift = VS1 & ((sew * 2) - 1);\n\n                        res = int_rounding<__int128_t>(\n                            res, 0 /* TODO */, shift) >> shift;\n\n                        if (res < min) {\n                            res = min;\n                            // TODO: vxsat\n                        } else if (res > max) {\n                            res = max;\n                            // TODO: vxsat\n                        }\n\n                        Vd_vi[i + offset] = (vi)res;\n                    ', 'OPIVI', 'SimdCvtOp'],{})


template <typename ElemType>
Fault
Vnclip_wiMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    using vwu [[maybe_unused]] = typename double_width<vu>::type;
    using vwi [[maybe_unused]] = typename double_width<vi>::type;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s0;
		xc->getRegOperand(this, 0,
		    &tmp_s0);
		auto Vs2 = tmp_s0.as<vwi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(1);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vs2 % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned VS2 group in Narrowing op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
        
            if ((VS2 < VD) &&
                (VD <= (VS2 + num_microops - 1))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is smaller than
                // the source EEW and the overlap is in the lowest-numbered
                // part of the source register group
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Narrowing op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        vi max = std::numeric_limits<vi>::max();
                        vi min = std::numeric_limits<vi>::min();
                        __int128_t res = Vs2[i];
                        unsigned shift = VS1 & ((sew * 2) - 1);

                        res = int_rounding<__int128_t>(
                            res, 0 /* TODO */, shift) >> shift;

                        if (res < min) {
                            res = min;
                            // TODO: vxsat
                        } else if (res > max) {
                            res = max;
                            // TODO: vxsat
                        }

                        Vd[i + offset] = (vi)res;
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vnclip_wiMicro<uint8_t>;
template class Vnclip_wiMicro<uint16_t>;
template class Vnclip_wiMicro<uint32_t>;
;


// Unknown::unknown(([], {}))

// VectorIntFormat::vadd_vx(['\n                        Vd_vu[i] = Vs2_vu[i] + Rs1_vu;\n                    ', 'OPIVX', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vadd_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vu Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = Vs2[i] + Rs1;
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vadd_vxMicro<uint8_t>;
template class Vadd_vxMicro<uint16_t>;
template class Vadd_vxMicro<uint32_t>;
template class Vadd_vxMicro<uint64_t>;
;


// VectorIntFormat::vsub_vx(['\n                        Vd_vu[i] = Vs2_vu[i] - Rs1_vu;\n                    ', 'OPIVX', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vsub_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vu Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = Vs2[i] - Rs1;
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vsub_vxMicro<uint8_t>;
template class Vsub_vxMicro<uint16_t>;
template class Vsub_vxMicro<uint32_t>;
template class Vsub_vxMicro<uint64_t>;
;


// VectorIntFormat::vrsub_vx(['\n                        Vd_vu[i] = Rs1_vu - Vs2_vu[i];\n                    ', 'OPIVX', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vrsub_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vu Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = Rs1 - Vs2[i];
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vrsub_vxMicro<uint8_t>;
template class Vrsub_vxMicro<uint16_t>;
template class Vrsub_vxMicro<uint32_t>;
template class Vrsub_vxMicro<uint64_t>;
;


// VectorIntFormat::vminu_vx(['\n                        Vd_vu[i] = std::min(Vs2_vu[i], Rs1_vu);\n                    ', 'OPIVX', 'SimdCmpOp'],{})


template <typename ElemType>
Fault
Vminu_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vu Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = std::min(Vs2[i], Rs1);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vminu_vxMicro<uint8_t>;
template class Vminu_vxMicro<uint16_t>;
template class Vminu_vxMicro<uint32_t>;
template class Vminu_vxMicro<uint64_t>;
;


// VectorIntFormat::vmin_vx(['\n                        Vd_vi[i] = std::min(Vs2_vi[i], Rs1_vi);\n                    ', 'OPIVX', 'SimdCmpOp'],{})


template <typename ElemType>
Fault
Vmin_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vi Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = std::min(Vs2[i], Rs1);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vmin_vxMicro<uint8_t>;
template class Vmin_vxMicro<uint16_t>;
template class Vmin_vxMicro<uint32_t>;
template class Vmin_vxMicro<uint64_t>;
;


// VectorIntFormat::vmaxu_vx(['\n                        Vd_vu[i] = std::max(Vs2_vu[i], Rs1_vu);\n                    ', 'OPIVX', 'SimdCmpOp'],{})


template <typename ElemType>
Fault
Vmaxu_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vu Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = std::max(Vs2[i], Rs1);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vmaxu_vxMicro<uint8_t>;
template class Vmaxu_vxMicro<uint16_t>;
template class Vmaxu_vxMicro<uint32_t>;
template class Vmaxu_vxMicro<uint64_t>;
;


// VectorIntFormat::vmax_vx(['\n                        Vd_vi[i] = std::max(Vs2_vi[i], Rs1_vi);\n                    ', 'OPIVX', 'SimdCmpOp'],{})


template <typename ElemType>
Fault
Vmax_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vi Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = std::max(Vs2[i], Rs1);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vmax_vxMicro<uint8_t>;
template class Vmax_vxMicro<uint16_t>;
template class Vmax_vxMicro<uint32_t>;
template class Vmax_vxMicro<uint64_t>;
;


// VectorIntFormat::vand_vx(['\n                        Vd_vu[i] = Vs2_vu[i] & Rs1_vu;\n                    ', 'OPIVX', 'SimdAluOp'],{})


template <typename ElemType>
Fault
Vand_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vu Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = Vs2[i] & Rs1;
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vand_vxMicro<uint8_t>;
template class Vand_vxMicro<uint16_t>;
template class Vand_vxMicro<uint32_t>;
template class Vand_vxMicro<uint64_t>;
;


// VectorIntFormat::vor_vx(['\n                        Vd_vu[i] = Vs2_vu[i] | Rs1_vu;\n                    ', 'OPIVX', 'SimdAluOp'],{})


template <typename ElemType>
Fault
Vor_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vu Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = Vs2[i] | Rs1;
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vor_vxMicro<uint8_t>;
template class Vor_vxMicro<uint16_t>;
template class Vor_vxMicro<uint32_t>;
template class Vor_vxMicro<uint64_t>;
;


// VectorIntFormat::vxor_vx(['\n                        Vd_vu[i] = Vs2_vu[i] ^ Rs1_vu;\n                    ', 'OPIVX', 'SimdAluOp'],{})


template <typename ElemType>
Fault
Vxor_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vu Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = Vs2[i] ^ Rs1;
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vxor_vxMicro<uint8_t>;
template class Vxor_vxMicro<uint16_t>;
template class Vxor_vxMicro<uint32_t>;
template class Vxor_vxMicro<uint64_t>;
;


// VectorSlideUpFormat::vslideup_vx((['\n                    const int offset = (int)Rs1_vu;\n                    const int microVlmax = vtype_VLMAX(machInst.vtype8,\n                        vlen, true);\n                    const int vregOffset = vdIdx - vs2Idx;\n                    const int offsetInVreg = offset - vregOffset * microVlmax;\n                    if (std::abs(offsetInVreg) < uint32_t(microVlmax)) {\n                        const int upperBound = (offsetInVreg >= 0)\n                            ? microVlmax - offsetInVreg\n                            : microVlmax + offsetInVreg;\n                        const int vdOffset = (offsetInVreg >= 0)\n                            ? offsetInVreg\n                            : 0;\n                        const int vs2Offset = (offsetInVreg >= 0)\n                            ? 0\n                            : -offsetInVreg;\n                        const int elemOffset = vdOffset + vdIdx * microVlmax;\n                        for (int i = 0;\n                            i < upperBound && i + vdOffset < microVl;\n                            i++) {\n                            if (this->vm || elem_mask(v0, i + elemOffset)) {\n                                Vd_vu[i + vdOffset] = Vs2_vu[i + vs2Offset];\n                            }\n                        }\n                    }\n                ', 'OPIVX', 'SimdMiscOp'], {}))


template<typename ElemType>
Fault
Vslideup_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vu Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    [[maybe_unused]]const uint32_t vlmax = vtype_VLMAX(vtype, vlen);

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    
                    const int offset = (int)Rs1;
                    const int microVlmax = vtype_VLMAX(machInst.vtype8,
                        vlen, true);
                    const int vregOffset = vdIdx - vs2Idx;
                    const int offsetInVreg = offset - vregOffset * microVlmax;
                    if (std::abs(offsetInVreg) < uint32_t(microVlmax)) {
                        const int upperBound = (offsetInVreg >= 0)
                            ? microVlmax - offsetInVreg
                            : microVlmax + offsetInVreg;
                        const int vdOffset = (offsetInVreg >= 0)
                            ? offsetInVreg
                            : 0;
                        const int vs2Offset = (offsetInVreg >= 0)
                            ? 0
                            : -offsetInVreg;
                        const int elemOffset = vdOffset + vdIdx * microVlmax;
                        for (int i = 0;
                            i < upperBound && i + vdOffset < microVl;
                            i++) {
                            if (this->vm || elem_mask(v0, i + elemOffset)) {
                                Vd[i + vdOffset] = Vs2[i + vs2Offset];
                            }
                        }
                    }
                ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
};

template class Vslideup_vxMicro<uint8_t>;
template class Vslideup_vxMicro<uint16_t>;
template class Vslideup_vxMicro<uint32_t>;
template class Vslideup_vxMicro<uint64_t>;
;


// VectorSlideDownFormat::vslidedown_vx((['\n                    const int offset = (int)Rs1_vu;\n                    const int microVlmax = vtype_VLMAX(machInst.vtype8,\n                        vlen, true);\n                    const int vregOffset = vs2Idx - vdIdx;\n                    const int offsetInVreg = offset - vregOffset * microVlmax;\n                    const int numVs2s = vtype_regs_per_group(vtype);\n                    if (std::abs(offsetInVreg) < uint32_t(microVlmax)) {\n                        const bool needZeroTail = numVs2s == vs2Idx + 1;\n                        const int upperBound = (offsetInVreg >= 0)\n                            ? microVlmax - offsetInVreg\n                            : microVlmax + offsetInVreg;\n                        const int vdOffset = (offsetInVreg >= 0)\n                            ? 0\n                            : -offsetInVreg;\n                        const int vs2Offset = (offsetInVreg >= 0)\n                            ? offsetInVreg\n                            : 0;\n                        const int elemIdxBase = vdIdx * microVlmax;\n                        vreg_t resVreg;\n                        auto res = resVreg.as<vu>();\n                        for (int i = 0;\n                            i < upperBound && i + vdOffset < microVl;\n                            i++) {\n                            res[i + vdOffset] = Vs2_vu[i + vs2Offset];\n                        }\n                        if (needZeroTail) {\n                            for (int i = upperBound + vdOffset;\n                                i < microVlmax; i++) {\n                                res[i] = 0;\n                            }\n                        }\n                        for (int i = vdOffset; i < microVl ; i++) {\n                            if (vm || elem_mask(v0, i + elemIdxBase)) {\n                                Vd_vu[i] = res[i];\n                            }\n                        }\n                    }\n                ', 'OPIVX', 'SimdMiscOp'], {}))


template<typename ElemType>
Fault
Vslidedown_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vu Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    [[maybe_unused]]const uint32_t vlmax = vtype_VLMAX(vtype, vlen);

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    
                    const int offset = (int)Rs1;
                    const int microVlmax = vtype_VLMAX(machInst.vtype8,
                        vlen, true);
                    const int vregOffset = vs2Idx - vdIdx;
                    const int offsetInVreg = offset - vregOffset * microVlmax;
                    const int numVs2s = vtype_regs_per_group(vtype);
                    if (std::abs(offsetInVreg) < uint32_t(microVlmax)) {
                        const bool needZeroTail = numVs2s == vs2Idx + 1;
                        const int upperBound = (offsetInVreg >= 0)
                            ? microVlmax - offsetInVreg
                            : microVlmax + offsetInVreg;
                        const int vdOffset = (offsetInVreg >= 0)
                            ? 0
                            : -offsetInVreg;
                        const int vs2Offset = (offsetInVreg >= 0)
                            ? offsetInVreg
                            : 0;
                        const int elemIdxBase = vdIdx * microVlmax;
                        vreg_t resVreg;
                        auto res = resVreg.as<vu>();
                        for (int i = 0;
                            i < upperBound && i + vdOffset < microVl;
                            i++) {
                            res[i + vdOffset] = Vs2[i + vs2Offset];
                        }
                        if (needZeroTail) {
                            for (int i = upperBound + vdOffset;
                                i < microVlmax; i++) {
                                res[i] = 0;
                            }
                        }
                        for (int i = vdOffset; i < microVl ; i++) {
                            if (vm || elem_mask(v0, i + elemIdxBase)) {
                                Vd[i] = res[i];
                            }
                        }
                    }
                ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
};

template class Vslidedown_vxMicro<uint8_t>;
template class Vslidedown_vxMicro<uint16_t>;
template class Vslidedown_vxMicro<uint32_t>;
template class Vslidedown_vxMicro<uint64_t>;
;


// VectorGatherFormat::vrgather_vx((['\n                    for (uint32_t i = 0; i < microVl; i++) {\n                        uint32_t ei = i + vs1_idx * vs1_elems + vs1_bias;\n                        uint64_t zextRs1 = rvZext(Rs1);\n                        if (this->vm || elem_mask(v0, ei)) {\n                            const uint64_t idx = zextRs1 - vs2_elems * vs2_idx;\n                            if (zextRs1 >= vlmax)\n                                Vd_vu[i] = 0;\n                            else if (idx < vs2_elems)\n                                Vd_vu[i] = Vs2_vu[idx];\n                        }\n                    }\n                ', 'OPIVX', 'SimdMiscOp'], {}))


template <typename ElemType, typename IndexType>
Fault
Vrgather_vxMicro<ElemType, IndexType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    uint64_t Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    const uint32_t vlmax = vtype_VLMAX(vtype,vlen);
    constexpr uint32_t vd_eewb = sizeof(ElemType);
    constexpr uint32_t vs1_eewb = sizeof(IndexType);
    constexpr uint32_t vs2_eewb = sizeof(ElemType);
    constexpr uint32_t vs1_split_num = (vd_eewb + vs1_eewb - 1) / vs1_eewb;
    constexpr uint32_t vd_split_num = (vs1_eewb + vd_eewb - 1) / vd_eewb;
    [[maybe_unused]] const uint32_t vd_elems = vlenb / vd_eewb;
    [[maybe_unused]] const uint32_t vs1_elems = vlenb / vs1_eewb;
    [[maybe_unused]] const uint32_t vs2_elems = vlenb / vs2_eewb;
    [[maybe_unused]] const int8_t lmul = vtype_vlmul(vtype);
    [[maybe_unused]] const uint8_t vs2_vregs = lmul < 0 ? 1 : 1 << lmul;
    [[maybe_unused]] const uint32_t vs2_idx = microIdx % vs2_vregs;
    [[maybe_unused]] const uint32_t vs1_idx =
        microIdx / vs2_vregs / vs1_split_num;
    [[maybe_unused]] const uint32_t vd_idx =
        microIdx / vs2_vregs / vd_split_num;
    [[maybe_unused]] const uint32_t vs1_bias =
        vs1_elems * (vd_idx % vs1_split_num) / vs1_split_num;
    [[maybe_unused]] const uint32_t vd_bias =
        vd_elems * (vs1_idx % vd_split_num) / vd_split_num;


    
                    for (uint32_t i = 0; i < microVl; i++) {
                        uint32_t ei = i + vs1_idx * vs1_elems + vs1_bias;
                        uint64_t zextRs1 = rvZext(Rs1);
                        if (this->vm || elem_mask(v0, ei)) {
                            const uint64_t idx = zextRs1 - vs2_elems * vs2_idx;
                            if (zextRs1 >= vlmax)
                                Vd[i] = 0;
                            else if (idx < vs2_elems)
                                Vd[i] = Vs2[idx];
                        }
                    }
                ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vrgather_vxMicro<uint8_t, uint8_t>;
template class Vrgather_vxMicro<uint16_t, uint16_t>;
template class Vrgather_vxMicro<uint32_t, uint32_t>;
template class Vrgather_vxMicro<uint64_t, uint64_t>;
;


// VectorIntFormat::vadc_vxm(['\n                            Vd_vi[i] = Vs2_vi[i] + Rs1_vi + elem_mask(v0, ei);\n                        ', 'OPIVX', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vadc_vxmMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vi Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            
                            Vd[i] = Vs2[i] + Rs1 + elem_mask(v0, ei);
                        
            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vadc_vxmMicro<uint8_t>;
template class Vadc_vxmMicro<uint16_t>;
template class Vadc_vxmMicro<uint32_t>;
template class Vadc_vxmMicro<uint64_t>;
;


// Unknown::unknown(([], {}))

// VectorIntFormat::vsbc_vxm(['\n                            Vd_vi[i] = Vs2_vi[i] - Rs1_vi - elem_mask(v0, ei);\n                        ', 'OPIVX', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vsbc_vxmMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vi Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            
                            Vd[i] = Vs2[i] - Rs1 - elem_mask(v0, ei);
                        
            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vsbc_vxmMicro<uint8_t>;
template class Vsbc_vxmMicro<uint16_t>;
template class Vsbc_vxmMicro<uint32_t>;
template class Vsbc_vxmMicro<uint64_t>;
;


// Unknown::unknown(([], {}))

// VectorIntFormat::vmerge_vxm(['\n                            Vd_vu[i] = elem_mask(v0, ei) ? Rs1_vu : Vs2_vu[i];\n                        ', 'OPIVX', 'SimdMiscOp'],{})


template <typename ElemType>
Fault
Vmerge_vxmMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vu Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            
                            Vd[i] = elem_mask(v0, ei) ? Rs1 : Vs2[i];
                        
            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vmerge_vxmMicro<uint8_t>;
template class Vmerge_vxmMicro<uint16_t>;
template class Vmerge_vxmMicro<uint32_t>;
template class Vmerge_vxmMicro<uint64_t>;
;


// VectorIntFormat::vmv_v_x(['\n                                Vd_vu[i] = Rs1_vu;\n                            ', 'OPIVX', 'SimdMiscOp'],{})


template <typename ElemType>
Fault
Vmv_v_xMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vu Rs1 = 0;
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Rs1 = xc->getRegOperand(this, 0);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
                                Vd[i] = Rs1;
                            
            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vmv_v_xMicro<uint8_t>;
template class Vmv_v_xMicro<uint16_t>;
template class Vmv_v_xMicro<uint32_t>;
template class Vmv_v_xMicro<uint64_t>;
;


// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// VectorIntVxsatFormat::vsaddu_vx(['\n                        Vd_vu[i] = sat_addu<vu>(Vs2_vu[i], Rs1_vu,\n                            vxsatptr);\n                    ', 'OPIVX', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vsaddu_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vu Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = sat_addu<vu>(Vs2[i], Rs1,
                            vxsatptr);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vsaddu_vxMicro<uint8_t>;
template class Vsaddu_vxMicro<uint16_t>;
template class Vsaddu_vxMicro<uint32_t>;
template class Vsaddu_vxMicro<uint64_t>;
;


// VectorIntVxsatFormat::vsadd_vx(['\n                        Vd_vu[i] = sat_add<vi>(Vs2_vu[i], Rs1_vu,\n                            vxsatptr);\n                    ', 'OPIVX', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vsadd_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vu Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = sat_add<vi>(Vs2[i], Rs1,
                            vxsatptr);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vsadd_vxMicro<uint8_t>;
template class Vsadd_vxMicro<uint16_t>;
template class Vsadd_vxMicro<uint32_t>;
template class Vsadd_vxMicro<uint64_t>;
;


// VectorIntVxsatFormat::vssubu_vx(['\n                        Vd_vu[i] = sat_subu<vu>(Vs2_vu[i], Rs1_vu,\n                            vxsatptr);\n                    ', 'OPIVX', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vssubu_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vu Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = sat_subu<vu>(Vs2[i], Rs1,
                            vxsatptr);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vssubu_vxMicro<uint8_t>;
template class Vssubu_vxMicro<uint16_t>;
template class Vssubu_vxMicro<uint32_t>;
template class Vssubu_vxMicro<uint64_t>;
;


// VectorIntVxsatFormat::vssub_vx(['\n                        Vd_vu[i] = sat_sub<vi>(Vs2_vu[i], Rs1_vu,\n                            vxsatptr);\n                    ', 'OPIVX', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vssub_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vu Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = sat_sub<vi>(Vs2[i], Rs1,
                            vxsatptr);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vssub_vxMicro<uint8_t>;
template class Vssub_vxMicro<uint16_t>;
template class Vssub_vxMicro<uint32_t>;
template class Vssub_vxMicro<uint64_t>;
;


// VectorIntVxsatFormat::vsmul_vx(['\n                        vi max = std::numeric_limits<vi>::max();\n                        vi min = std::numeric_limits<vi>::min();\n                        bool overflow = Rs1_vi == Vs2_vi[i] && Rs1_vi == min;\n                        __int128_t result =\n                            (__int128_t)Rs1_vi * (__int128_t)Vs2_vi[i];\n                        result = int_rounding<__uint128_t>(\n                            result, 0 /* TODO */, sew - 1);\n                        result = result >> (sew - 1);\n                        if (overflow) {\n                            result = max;\n                            *vxsatptr = true;\n                        }\n\n                        Vd_vi[i] = (vi)result;\n                    ', 'OPIVX', 'SimdMultOp'],{})


template <typename ElemType>
Fault
Vsmul_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vi Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        vi max = std::numeric_limits<vi>::max();
                        vi min = std::numeric_limits<vi>::min();
                        bool overflow = Rs1 == Vs2[i] && Rs1 == min;
                        __int128_t result =
                            (__int128_t)Rs1 * (__int128_t)Vs2[i];
                        result = int_rounding<__uint128_t>(
                            result, 0 /* TODO */, sew - 1);
                        result = result >> (sew - 1);
                        if (overflow) {
                            result = max;
                            *vxsatptr = true;
                        }

                        Vd[i] = (vi)result;
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vsmul_vxMicro<uint8_t>;
template class Vsmul_vxMicro<uint16_t>;
template class Vsmul_vxMicro<uint32_t>;
template class Vsmul_vxMicro<uint64_t>;
;


// VectorIntFormat::vsll_vx(['\n                        Vd_vu[i] = Vs2_vu[i] << (Rs1_vu & (sew - 1));\n                    ', 'OPIVX', 'SimdShiftOp'],{})


template <typename ElemType>
Fault
Vsll_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vu Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = Vs2[i] << (Rs1 & (sew - 1));
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vsll_vxMicro<uint8_t>;
template class Vsll_vxMicro<uint16_t>;
template class Vsll_vxMicro<uint32_t>;
template class Vsll_vxMicro<uint64_t>;
;


// VectorIntFormat::vsrl_vx(['\n                        Vd_vu[i] = Vs2_vu[i] >> (Rs1_vu & (sew - 1));\n                    ', 'OPIVX', 'SimdShiftOp'],{})


template <typename ElemType>
Fault
Vsrl_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vu Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = Vs2[i] >> (Rs1 & (sew - 1));
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vsrl_vxMicro<uint8_t>;
template class Vsrl_vxMicro<uint16_t>;
template class Vsrl_vxMicro<uint32_t>;
template class Vsrl_vxMicro<uint64_t>;
;


// VectorIntFormat::vsra_vx(['\n                        Vd_vi[i] = Vs2_vi[i] >> (Rs1_vu & (sew - 1));\n                    ', 'OPIVX', 'SimdShiftOp'],{})


template <typename ElemType>
Fault
Vsra_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vu Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = Vs2[i] >> (Rs1 & (sew - 1));
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vsra_vxMicro<uint8_t>;
template class Vsra_vxMicro<uint16_t>;
template class Vsra_vxMicro<uint32_t>;
template class Vsra_vxMicro<uint64_t>;
;


// VectorIntFormat::vssrl_vx(['\n                        int sh = Rs1_vu & (sew - 1);\n                        __uint128_t val = Vs2_vu[i];\n\n                        val = int_rounding<__uint128_t>(val,\n                            xc->readMiscReg(MISCREG_VXRM), sh);\n                        Vd_vu[i] = val >> sh;\n                    ', 'OPIVX', 'SimdShiftOp'],{})


template <typename ElemType>
Fault
Vssrl_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vu Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        int sh = Rs1 & (sew - 1);
                        __uint128_t val = Vs2[i];

                        val = int_rounding<__uint128_t>(val,
                            xc->readMiscReg(MISCREG_VXRM), sh);
                        Vd[i] = val >> sh;
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vssrl_vxMicro<uint8_t>;
template class Vssrl_vxMicro<uint16_t>;
template class Vssrl_vxMicro<uint32_t>;
template class Vssrl_vxMicro<uint64_t>;
;


// VectorIntFormat::vssra_vx(['\n                        int sh = Rs1_vu & (sew - 1);\n                        __int128_t val = Vs2_vi[i];\n\n                        val = int_rounding<__int128_t>(val,\n                            xc->readMiscReg(MISCREG_VXRM), sh);\n                        Vd_vi[i] = val >> sh;\n                    ', 'OPIVX', 'SimdShiftOp'],{})


template <typename ElemType>
Fault
Vssra_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vu Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        int sh = Rs1 & (sew - 1);
                        __int128_t val = Vs2[i];

                        val = int_rounding<__int128_t>(val,
                            xc->readMiscReg(MISCREG_VXRM), sh);
                        Vd[i] = val >> sh;
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vssra_vxMicro<uint8_t>;
template class Vssra_vxMicro<uint16_t>;
template class Vssra_vxMicro<uint32_t>;
template class Vssra_vxMicro<uint64_t>;
;


// VectorIntNarrowingFormat::vnsrl_wx(['\n                        Vd_vu[i + offset] = (vu)(Vs2_vwu[i] >>\n                                            ((vwu)Rs1_vu & (sew * 2 - 1)));\n                    ', 'OPIVX', 'SimdShiftOp'],{})


template <typename ElemType>
Fault
Vnsrl_wxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    using vwu [[maybe_unused]] = typename double_width<vu>::type;
    using vwi [[maybe_unused]] = typename double_width<vi>::type;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    vu Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vwu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vs2 % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned VS2 group in Narrowing op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
        
            if ((VS2 < VD) &&
                (VD <= (VS2 + num_microops - 1))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is smaller than
                // the source EEW and the overlap is in the lowest-numbered
                // part of the source register group
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Narrowing op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i + offset] = (vu)(Vs2[i] >>
                                            ((vwu)Rs1 & (sew * 2 - 1)));
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vnsrl_wxMicro<uint8_t>;
template class Vnsrl_wxMicro<uint16_t>;
template class Vnsrl_wxMicro<uint32_t>;
;


// VectorIntNarrowingFormat::vnsra_wx(['\n                        Vd_vi[i + offset] = (vi)(Vs2_vwi[i] >>\n                                            ((vwu)Rs1_vu & (sew * 2 - 1)));\n                    ', 'OPIVX', 'SimdShiftOp'],{})


template <typename ElemType>
Fault
Vnsra_wxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    using vwu [[maybe_unused]] = typename double_width<vu>::type;
    using vwi [[maybe_unused]] = typename double_width<vi>::type;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    vu Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vwi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vs2 % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned VS2 group in Narrowing op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
        
            if ((VS2 < VD) &&
                (VD <= (VS2 + num_microops - 1))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is smaller than
                // the source EEW and the overlap is in the lowest-numbered
                // part of the source register group
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Narrowing op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i + offset] = (vi)(Vs2[i] >>
                                            ((vwu)Rs1 & (sew * 2 - 1)));
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vnsra_wxMicro<uint8_t>;
template class Vnsra_wxMicro<uint16_t>;
template class Vnsra_wxMicro<uint32_t>;
;


// VectorIntNarrowingFormat::vnclipu_wx(['\n                        vu max = std::numeric_limits<vu>::max();\n                        uint64_t sign_mask =\n                            std::numeric_limits<uint64_t>::max() << sew;\n                        __uint128_t res = Vs2_vwu[i];\n                        unsigned shift = Rs1_vu & ((sew * 2) - 1);\n\n                        res = int_rounding<__uint128_t>(\n                            res, 0 /* TODO */, shift) >> shift;\n\n                        if (res & sign_mask) {\n                            // TODO: vxsat\n                            res = max;\n                        }\n\n                        Vd_vu[i + offset] = (vu)res;\n                    ', 'OPIVX', 'SimdCvtOp'],{})


template <typename ElemType>
Fault
Vnclipu_wxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    using vwu [[maybe_unused]] = typename double_width<vu>::type;
    using vwi [[maybe_unused]] = typename double_width<vi>::type;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    vu Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vwu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vs2 % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned VS2 group in Narrowing op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
        
            if ((VS2 < VD) &&
                (VD <= (VS2 + num_microops - 1))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is smaller than
                // the source EEW and the overlap is in the lowest-numbered
                // part of the source register group
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Narrowing op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        vu max = std::numeric_limits<vu>::max();
                        uint64_t sign_mask =
                            std::numeric_limits<uint64_t>::max() << sew;
                        __uint128_t res = Vs2[i];
                        unsigned shift = Rs1 & ((sew * 2) - 1);

                        res = int_rounding<__uint128_t>(
                            res, 0 /* TODO */, shift) >> shift;

                        if (res & sign_mask) {
                            // TODO: vxsat
                            res = max;
                        }

                        Vd[i + offset] = (vu)res;
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vnclipu_wxMicro<uint8_t>;
template class Vnclipu_wxMicro<uint16_t>;
template class Vnclipu_wxMicro<uint32_t>;
;


// VectorIntNarrowingFormat::vnclip_wx(['\n                        vi max = std::numeric_limits<vi>::max();\n                        vi min = std::numeric_limits<vi>::min();\n                        __int128_t res = Vs2_vwi[i];\n                        unsigned shift = Rs1_vi & ((sew * 2) - 1);\n\n                        res = int_rounding<__int128_t>(\n                            res, 0 /* TODO */, shift) >> shift;\n\n                        if (res < min) {\n                            res = min;\n                            // TODO: vxsat\n                        } else if (res > max) {\n                            res = max;\n                            // TODO: vxsat\n                        }\n\n                        Vd_vi[i + offset] = (vi)res;\n                    ', 'OPIVX', 'SimdCvtOp'],{})


template <typename ElemType>
Fault
Vnclip_wxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    using vwu [[maybe_unused]] = typename double_width<vu>::type;
    using vwi [[maybe_unused]] = typename double_width<vi>::type;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    vi Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vwi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vs2 % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned VS2 group in Narrowing op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
        
            if ((VS2 < VD) &&
                (VD <= (VS2 + num_microops - 1))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is smaller than
                // the source EEW and the overlap is in the lowest-numbered
                // part of the source register group
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Narrowing op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        vi max = std::numeric_limits<vi>::max();
                        vi min = std::numeric_limits<vi>::min();
                        __int128_t res = Vs2[i];
                        unsigned shift = Rs1 & ((sew * 2) - 1);

                        res = int_rounding<__int128_t>(
                            res, 0 /* TODO */, shift) >> shift;

                        if (res < min) {
                            res = min;
                            // TODO: vxsat
                        } else if (res > max) {
                            res = max;
                            // TODO: vxsat
                        }

                        Vd[i + offset] = (vi)res;
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vnclip_wxMicro<uint8_t>;
template class Vnclip_wxMicro<uint16_t>;
template class Vnclip_wxMicro<uint32_t>;
;


// VectorIntMaskFormat::vmadc_vxm(['\n                            Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                                carry_out(Vs2_vi[i], Rs1_vi,\n                                    elem_mask(v0, ei)));\n                        ', 'OPIVX', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vmadc_vxmMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vi Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;

    const uint32_t bit_offset = vlenb / sizeof(ElemType);
    const uint32_t offset = bit_offset * microIdx;

    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            
                            Vd[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,
                                carry_out(Vs2[i], Rs1,
                                    elem_mask(v0, ei)));
                        
            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vmadc_vxmMicro<uint8_t>;
template class Vmadc_vxmMicro<uint16_t>;
template class Vmadc_vxmMicro<uint32_t>;
template class Vmadc_vxmMicro<uint64_t>;
;


// VectorIntMaskFormat::vmadc_vx(['\n                            Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                                carry_out(Vs2_vi[i], Rs1_vi));\n                        ', 'OPIVX', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vmadc_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vi Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    ;

    const uint32_t bit_offset = vlenb / sizeof(ElemType);
    const uint32_t offset = bit_offset * microIdx;

    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
                            Vd[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,
                                carry_out(Vs2[i], Rs1));
                        
            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vmadc_vxMicro<uint8_t>;
template class Vmadc_vxMicro<uint16_t>;
template class Vmadc_vxMicro<uint32_t>;
template class Vmadc_vxMicro<uint64_t>;
;


// Unknown::unknown(([], {}))

// VectorIntMaskFormat::vmsbc_vxm(['\n                            Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                                borrow_out(Vs2_vi[i], Rs1_vi,\n                                    elem_mask(v0, ei)));\n                        ', 'OPIVX', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vmsbc_vxmMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vi Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;

    const uint32_t bit_offset = vlenb / sizeof(ElemType);
    const uint32_t offset = bit_offset * microIdx;

    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            
                            Vd[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,
                                borrow_out(Vs2[i], Rs1,
                                    elem_mask(v0, ei)));
                        
            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vmsbc_vxmMicro<uint8_t>;
template class Vmsbc_vxmMicro<uint16_t>;
template class Vmsbc_vxmMicro<uint32_t>;
template class Vmsbc_vxmMicro<uint64_t>;
;


// VectorIntMaskFormat::vmsbc_vx(['\n                            Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                                borrow_out(Vs2_vi[i], Rs1_vi));\n                        ', 'OPIVX', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vmsbc_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vi Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    ;

    const uint32_t bit_offset = vlenb / sizeof(ElemType);
    const uint32_t offset = bit_offset * microIdx;

    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
                            Vd[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,
                                borrow_out(Vs2[i], Rs1));
                        
            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vmsbc_vxMicro<uint8_t>;
template class Vmsbc_vxMicro<uint16_t>;
template class Vmsbc_vxMicro<uint32_t>;
template class Vmsbc_vxMicro<uint64_t>;
;


// Unknown::unknown(([], {}))

// VectorIntMaskFormat::vmseq_vx(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            (Vs2_vu[i] == Rs1_vu));\n                    ', 'OPIVX', 'SimdCmpOp'],{})


template <typename ElemType>
Fault
Vmseq_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vu Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;

    const uint32_t bit_offset = vlenb / sizeof(ElemType);
    const uint32_t offset = bit_offset * microIdx;

    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,
                            (Vs2[i] == Rs1));
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vmseq_vxMicro<uint8_t>;
template class Vmseq_vxMicro<uint16_t>;
template class Vmseq_vxMicro<uint32_t>;
template class Vmseq_vxMicro<uint64_t>;
;


// VectorIntMaskFormat::vmsne_vx(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            (Vs2_vu[i] != Rs1_vu));\n                    ', 'OPIVX', 'SimdCmpOp'],{})


template <typename ElemType>
Fault
Vmsne_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vu Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;

    const uint32_t bit_offset = vlenb / sizeof(ElemType);
    const uint32_t offset = bit_offset * microIdx;

    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,
                            (Vs2[i] != Rs1));
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vmsne_vxMicro<uint8_t>;
template class Vmsne_vxMicro<uint16_t>;
template class Vmsne_vxMicro<uint32_t>;
template class Vmsne_vxMicro<uint64_t>;
;


// VectorIntMaskFormat::vmsltu_vx(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            (Vs2_vu[i] < Rs1_vu));\n                    ', 'OPIVX', 'SimdCmpOp'],{})


template <typename ElemType>
Fault
Vmsltu_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vu Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;

    const uint32_t bit_offset = vlenb / sizeof(ElemType);
    const uint32_t offset = bit_offset * microIdx;

    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,
                            (Vs2[i] < Rs1));
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vmsltu_vxMicro<uint8_t>;
template class Vmsltu_vxMicro<uint16_t>;
template class Vmsltu_vxMicro<uint32_t>;
template class Vmsltu_vxMicro<uint64_t>;
;


// VectorIntMaskFormat::vmslt_vx(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            (Vs2_vi[i] < Rs1_vi));\n                    ', 'OPIVX', 'SimdCmpOp'],{})


template <typename ElemType>
Fault
Vmslt_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vi Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;

    const uint32_t bit_offset = vlenb / sizeof(ElemType);
    const uint32_t offset = bit_offset * microIdx;

    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,
                            (Vs2[i] < Rs1));
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vmslt_vxMicro<uint8_t>;
template class Vmslt_vxMicro<uint16_t>;
template class Vmslt_vxMicro<uint32_t>;
template class Vmslt_vxMicro<uint64_t>;
;


// VectorIntMaskFormat::vmsleu_vx(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            (Vs2_vu[i] <= Rs1_vu));\n                    ', 'OPIVX', 'SimdCmpOp'],{})


template <typename ElemType>
Fault
Vmsleu_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vu Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;

    const uint32_t bit_offset = vlenb / sizeof(ElemType);
    const uint32_t offset = bit_offset * microIdx;

    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,
                            (Vs2[i] <= Rs1));
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vmsleu_vxMicro<uint8_t>;
template class Vmsleu_vxMicro<uint16_t>;
template class Vmsleu_vxMicro<uint32_t>;
template class Vmsleu_vxMicro<uint64_t>;
;


// VectorIntMaskFormat::vmsle_vx(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            (Vs2_vi[i] <= Rs1_vi));\n                    ', 'OPIVX', 'SimdCmpOp'],{})


template <typename ElemType>
Fault
Vmsle_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vi Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;

    const uint32_t bit_offset = vlenb / sizeof(ElemType);
    const uint32_t offset = bit_offset * microIdx;

    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,
                            (Vs2[i] <= Rs1));
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vmsle_vxMicro<uint8_t>;
template class Vmsle_vxMicro<uint16_t>;
template class Vmsle_vxMicro<uint32_t>;
template class Vmsle_vxMicro<uint64_t>;
;


// VectorIntMaskFormat::vmsgtu_vx(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            (Vs2_vu[i] > Rs1_vu));\n                    ', 'OPIVX', 'SimdCmpOp'],{})


template <typename ElemType>
Fault
Vmsgtu_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vu Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;

    const uint32_t bit_offset = vlenb / sizeof(ElemType);
    const uint32_t offset = bit_offset * microIdx;

    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,
                            (Vs2[i] > Rs1));
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vmsgtu_vxMicro<uint8_t>;
template class Vmsgtu_vxMicro<uint16_t>;
template class Vmsgtu_vxMicro<uint32_t>;
template class Vmsgtu_vxMicro<uint64_t>;
;


// VectorIntMaskFormat::vmsgt_vx(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            (Vs2_vi[i] > Rs1_vi));\n                    ', 'OPIVX', 'SimdCmpOp'],{})


template <typename ElemType>
Fault
Vmsgt_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vi Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;

    const uint32_t bit_offset = vlenb / sizeof(ElemType);
    const uint32_t offset = bit_offset * microIdx;

    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,
                            (Vs2[i] > Rs1));
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vmsgt_vxMicro<uint8_t>;
template class Vmsgt_vxMicro<uint16_t>;
template class Vmsgt_vxMicro<uint32_t>;
template class Vmsgt_vxMicro<uint64_t>;
;


// Unknown::unknown(([], {}))

// VectorFloatFormat::vfadd_vf(['\n                        auto fd = fadd<et>(ftype<et>(Vs2_vu[i]),\n                                           ftype_freg<et>(freg(Fs1_bits)));\n                        Vd_vu[i] = fd.v;\n                    ', 'OPFVF', 'SimdFloatAddOp'],{})


template <typename ElemType>
Fault
Vfadd_vfMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    uint64_t Fs1_bits = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Fs1_bits = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        auto fd = fadd<et>(ftype<et>(Vs2[i]),
                                           ftype_freg<et>(freg(Fs1_bits)));
                        Vd[i] = fd.v;
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vfadd_vfMicro<float16_t>;
template class Vfadd_vfMicro<float32_t>;
template class Vfadd_vfMicro<float64_t>;
;


// VectorFloatFormat::vfsub_vf(['\n                        auto fd = fsub<et>(ftype<et>(Vs2_vu[i]),\n                                           ftype_freg<et>(freg(Fs1_bits)));\n                        Vd_vu[i] = fd.v;\n                    ', 'OPFVF', 'SimdFloatAddOp'],{})


template <typename ElemType>
Fault
Vfsub_vfMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    uint64_t Fs1_bits = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Fs1_bits = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        auto fd = fsub<et>(ftype<et>(Vs2[i]),
                                           ftype_freg<et>(freg(Fs1_bits)));
                        Vd[i] = fd.v;
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vfsub_vfMicro<float16_t>;
template class Vfsub_vfMicro<float32_t>;
template class Vfsub_vfMicro<float64_t>;
;


// VectorFloatFormat::vfmin_vf(['\n                        auto fd = fmin<et>(ftype<et>(Vs2_vu[i]),\n                                           ftype_freg<et>(freg(Fs1_bits)));\n                        Vd_vu[i] = fd.v;\n                    ', 'OPFVF', 'SimdFloatCmpOp'],{})


template <typename ElemType>
Fault
Vfmin_vfMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    uint64_t Fs1_bits = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Fs1_bits = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        auto fd = fmin<et>(ftype<et>(Vs2[i]),
                                           ftype_freg<et>(freg(Fs1_bits)));
                        Vd[i] = fd.v;
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vfmin_vfMicro<float16_t>;
template class Vfmin_vfMicro<float32_t>;
template class Vfmin_vfMicro<float64_t>;
;


// VectorFloatFormat::vfmax_vf(['\n                        auto fd = fmax<et>(ftype<et>(Vs2_vu[i]),\n                                           ftype_freg<et>(freg(Fs1_bits)));\n                            Vd_vu[i] = fd.v;\n                    ', 'OPFVF', 'SimdFloatCmpOp'],{})


template <typename ElemType>
Fault
Vfmax_vfMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    uint64_t Fs1_bits = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Fs1_bits = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        auto fd = fmax<et>(ftype<et>(Vs2[i]),
                                           ftype_freg<et>(freg(Fs1_bits)));
                            Vd[i] = fd.v;
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vfmax_vfMicro<float16_t>;
template class Vfmax_vfMicro<float32_t>;
template class Vfmax_vfMicro<float64_t>;
;


// VectorFloatFormat::vfsgnj_vf(['\n                        Vd_vu[i] = fsgnj<et>(ftype<et>(Vs2_vu[i]),\n                                             ftype_freg<et>(freg(Fs1_bits)),\n                                             false, false).v;\n                    ', 'OPFVF', 'SimdFloatExtOp'],{})


template <typename ElemType>
Fault
Vfsgnj_vfMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    uint64_t Fs1_bits = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Fs1_bits = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = fsgnj<et>(ftype<et>(Vs2[i]),
                                             ftype_freg<et>(freg(Fs1_bits)),
                                             false, false).v;
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vfsgnj_vfMicro<float16_t>;
template class Vfsgnj_vfMicro<float32_t>;
template class Vfsgnj_vfMicro<float64_t>;
;


// VectorFloatFormat::vfsgnjn_vf(['\n                        Vd_vu[i] = fsgnj<et>(ftype<et>(Vs2_vu[i]),\n                                             ftype_freg<et>(freg(Fs1_bits)),\n                                             true, false).v;\n                    ', 'OPFVF', 'SimdFloatExtOp'],{})


template <typename ElemType>
Fault
Vfsgnjn_vfMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    uint64_t Fs1_bits = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Fs1_bits = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = fsgnj<et>(ftype<et>(Vs2[i]),
                                             ftype_freg<et>(freg(Fs1_bits)),
                                             true, false).v;
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vfsgnjn_vfMicro<float16_t>;
template class Vfsgnjn_vfMicro<float32_t>;
template class Vfsgnjn_vfMicro<float64_t>;
;


// VectorFloatFormat::vfsgnjx_vf(['\n                        Vd_vu[i] = fsgnj<et>(ftype<et>(Vs2_vu[i]),\n                                             ftype_freg<et>(freg(Fs1_bits)),\n                                             false, true).v;\n                    ', 'OPFVF', 'SimdFloatExtOp'],{})


template <typename ElemType>
Fault
Vfsgnjx_vfMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    uint64_t Fs1_bits = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Fs1_bits = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = fsgnj<et>(ftype<et>(Vs2[i]),
                                             ftype_freg<et>(freg(Fs1_bits)),
                                             false, true).v;
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vfsgnjx_vfMicro<float16_t>;
template class Vfsgnjx_vfMicro<float32_t>;
template class Vfsgnjx_vfMicro<float64_t>;
;


// VectorFloatSlideUpFormat::vfslide1up_vf((['\n                    const int offset = 1;\n                    const int microVlmax = vtype_VLMAX(machInst.vtype8,\n                        vlen, true);\n                    const int vregOffset = vdIdx - vs2Idx;\n                    const int offsetInVreg = offset - vregOffset * microVlmax;\n                    if (std::abs(offsetInVreg) < uint32_t(microVlmax)) {\n                        const int upperBound = (offsetInVreg >= 0)\n                            ? microVlmax - offsetInVreg\n                            : microVlmax + offsetInVreg;\n                        const int vdOffset = (offsetInVreg >= 0)\n                            ? offsetInVreg\n                            : 0;\n                        const int vs2Offset = (offsetInVreg >= 0)\n                            ? 0\n                            : -offsetInVreg;\n                        const int elemOffset = vdOffset + vdIdx * microVlmax;\n                        for (int i = 0;\n                            i < upperBound && i + vdOffset < microVl;\n                            i++) {\n                            if (this->vm || elem_mask(v0, i + elemOffset)) {\n                                Vd_vu[i + vdOffset] = Vs2_vu[i + vs2Offset];\n                            }\n                        }\n                        // TODO: dirty code\n                        if (vdIdx == 0 && vs2Idx == 0 &&\n                                (this->vm || elem_mask(v0, 0))) {\n                            tmp_d0.as<vu>()[0] = Rs1_vu;\n                        }\n                    }\n                ', 'OPFVF', 'SimdMiscOp'], {}))


template<typename ElemType>
Fault
Vfslide1up_vfMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vu Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    [[maybe_unused]]const uint32_t vlmax = vtype_VLMAX(vtype, vlen);

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    
                    const int offset = 1;
                    const int microVlmax = vtype_VLMAX(machInst.vtype8,
                        vlen, true);
                    const int vregOffset = vdIdx - vs2Idx;
                    const int offsetInVreg = offset - vregOffset * microVlmax;
                    if (std::abs(offsetInVreg) < uint32_t(microVlmax)) {
                        const int upperBound = (offsetInVreg >= 0)
                            ? microVlmax - offsetInVreg
                            : microVlmax + offsetInVreg;
                        const int vdOffset = (offsetInVreg >= 0)
                            ? offsetInVreg
                            : 0;
                        const int vs2Offset = (offsetInVreg >= 0)
                            ? 0
                            : -offsetInVreg;
                        const int elemOffset = vdOffset + vdIdx * microVlmax;
                        for (int i = 0;
                            i < upperBound && i + vdOffset < microVl;
                            i++) {
                            if (this->vm || elem_mask(v0, i + elemOffset)) {
                                Vd[i + vdOffset] = Vs2[i + vs2Offset];
                            }
                        }
                        // TODO: dirty code
                        if (vdIdx == 0 && vs2Idx == 0 &&
                                (this->vm || elem_mask(v0, 0))) {
                            tmp_d0.as<vu>()[0] = Rs1;
                        }
                    }
                ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
};

template class Vfslide1up_vfMicro<float16_t>;
template class Vfslide1up_vfMicro<float32_t>;
template class Vfslide1up_vfMicro<float64_t>;
;


// VectorFloatSlideDownFormat::vfslide1down_vf((['\n                    const int offset = 1;\n                    const int microVlmax = vtype_VLMAX(machInst.vtype8,\n                        vlen, true);\n                    const int vregOffset = vs2Idx - vdIdx;\n                    const int offsetInVreg = offset - vregOffset * microVlmax;\n                    const int numVs2s = vtype_regs_per_group(vtype);\n                    if (std::abs(offsetInVreg) < uint32_t(microVlmax)) {\n                        const bool needZeroTail = numVs2s == vs2Idx + 1;\n                        const int upperBound = (offsetInVreg >= 0)\n                            ? microVlmax - offsetInVreg\n                            : microVlmax + offsetInVreg;\n                        const int vdOffset = (offsetInVreg >= 0)\n                            ? 0\n                            : -offsetInVreg;\n                        const int vs2Offset = (offsetInVreg >= 0)\n                            ? offsetInVreg\n                            : 0;\n                        const int elemIdxBase = vdIdx * microVlmax;\n                        vreg_t resVreg;\n                        auto res = resVreg.as<vu>();\n                        for (int i = 0;\n                            i < upperBound && i + vdOffset < microVl;\n                            i++) {\n                            res[i + vdOffset] = Vs2_vu[i + vs2Offset];\n                        }\n                        if (needZeroTail) {\n                            for (int i = upperBound + vdOffset;\n                                i < microVlmax; i++) {\n                                res[i] = 0;\n                            }\n                        }\n                        for (int i = vdOffset; i < microVl ; i++) {\n                            if (vm || elem_mask(v0, i + elemIdxBase)) {\n                                Vd_vu[i] = (i + elemIdxBase != machInst.vl - 1)\n                                    ? res[i]\n                                    : Rs1_vu;\n                            }\n                        }\n                    }\n                ', 'OPFVF', 'SimdMiscOp'], {}))


template<typename ElemType>
Fault
Vfslide1down_vfMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vu Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    [[maybe_unused]]const uint32_t vlmax = vtype_VLMAX(vtype, vlen);

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    
                    const int offset = 1;
                    const int microVlmax = vtype_VLMAX(machInst.vtype8,
                        vlen, true);
                    const int vregOffset = vs2Idx - vdIdx;
                    const int offsetInVreg = offset - vregOffset * microVlmax;
                    const int numVs2s = vtype_regs_per_group(vtype);
                    if (std::abs(offsetInVreg) < uint32_t(microVlmax)) {
                        const bool needZeroTail = numVs2s == vs2Idx + 1;
                        const int upperBound = (offsetInVreg >= 0)
                            ? microVlmax - offsetInVreg
                            : microVlmax + offsetInVreg;
                        const int vdOffset = (offsetInVreg >= 0)
                            ? 0
                            : -offsetInVreg;
                        const int vs2Offset = (offsetInVreg >= 0)
                            ? offsetInVreg
                            : 0;
                        const int elemIdxBase = vdIdx * microVlmax;
                        vreg_t resVreg;
                        auto res = resVreg.as<vu>();
                        for (int i = 0;
                            i < upperBound && i + vdOffset < microVl;
                            i++) {
                            res[i + vdOffset] = Vs2[i + vs2Offset];
                        }
                        if (needZeroTail) {
                            for (int i = upperBound + vdOffset;
                                i < microVlmax; i++) {
                                res[i] = 0;
                            }
                        }
                        for (int i = vdOffset; i < microVl ; i++) {
                            if (vm || elem_mask(v0, i + elemIdxBase)) {
                                Vd[i] = (i + elemIdxBase != machInst.vl - 1)
                                    ? res[i]
                                    : Rs1;
                            }
                        }
                    }
                ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
};

template class Vfslide1down_vfMicro<float16_t>;
template class Vfslide1down_vfMicro<float32_t>;
template class Vfslide1down_vfMicro<float64_t>;
;


// VectorNonSplitFormat::vfmv_s_f((['\n                            if (this->vl) {\n                                auto fd = ftype_freg<et>(freg(Fs1_bits));\n                                Vd_vu[0] = fd.v;\n                            }\n                        ', 'OPFVV', 'SimdMiscOp'], {}))


template <typename ElemType>
Fault
Vfmv_s_f<ElemType>::execute(ExecContext* xc,
                                    trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    uint64_t Fs1_bits = 0;
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Fs1_bits = xc->getRegOperand(this, 0);
;
    ;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
                            if (this->vl) {
                                auto fd = ftype_freg<et>(freg(Fs1_bits));
                                Vd[0] = fd.v;
                            }
                        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vfmv_s_f<float16_t>;
template class Vfmv_s_f<float32_t>;
template class Vfmv_s_f<float64_t>;
;


// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// VectorFloatFormat::vfmerge_vfm(['\n                            Vd_vu[i] = elem_mask(v0, ei)\n                                    ? ftype_freg<et>(freg(Fs1_bits)).v\n                                    : Vs2_vu[i];\n                        ', 'OPFVF', 'SimdMiscOp'],{})


template <typename ElemType>
Fault
Vfmerge_vfmMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    uint64_t Fs1_bits = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Fs1_bits = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            
                            Vd[i] = elem_mask(v0, ei)
                                    ? ftype_freg<et>(freg(Fs1_bits)).v
                                    : Vs2[i];
                        
            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vfmerge_vfmMicro<float16_t>;
template class Vfmerge_vfmMicro<float32_t>;
template class Vfmerge_vfmMicro<float64_t>;
;


// VectorFloatFormat::vfmv_v_f(['\n                            auto fd = ftype_freg<et>(freg(Fs1_bits));\n                            Vd_vu[i] = fd.v;\n                        ', 'OPFVF', 'SimdMiscOp'],{})


template <typename ElemType>
Fault
Vfmv_v_fMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    uint64_t Fs1_bits = 0;
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Fs1_bits = xc->getRegOperand(this, 0);
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    ;
    COPY_OLD_VD(2);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
                            auto fd = ftype_freg<et>(freg(Fs1_bits));
                            Vd[i] = fd.v;
                        
            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vfmv_v_fMicro<float16_t>;
template class Vfmv_v_fMicro<float32_t>;
template class Vfmv_v_fMicro<float64_t>;
;


// Unknown::unknown(([], {}))

// VectorFloatMaskFormat::vmfeq_vf(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            feq<et>(ftype<et>(Vs2_vu[i]),\n                                    ftype_freg<et>(freg(Fs1_bits))));\n                    ', 'OPFVF', 'SimdFloatCmpOp'],{})


template <typename ElemType>
Fault
Vmfeq_vfMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    uint64_t Fs1_bits = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
Fs1_bits = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;

    const uint32_t bit_offset = vlenb / sizeof(ElemType);
    const uint32_t offset = bit_offset * microIdx;

    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,
                            feq<et>(ftype<et>(Vs2[i]),
                                    ftype_freg<et>(freg(Fs1_bits))));
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vmfeq_vfMicro<float16_t>;
template class Vmfeq_vfMicro<float32_t>;
template class Vmfeq_vfMicro<float64_t>;
;


// VectorFloatMaskFormat::vmfle_vf(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            fle<et>(ftype<et>(Vs2_vu[i]),\n                                    ftype_freg<et>(freg(Fs1_bits))));\n                    ', 'OPFVF', 'SimdFloatCmpOp'],{})


template <typename ElemType>
Fault
Vmfle_vfMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    uint64_t Fs1_bits = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
Fs1_bits = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;

    const uint32_t bit_offset = vlenb / sizeof(ElemType);
    const uint32_t offset = bit_offset * microIdx;

    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,
                            fle<et>(ftype<et>(Vs2[i]),
                                    ftype_freg<et>(freg(Fs1_bits))));
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vmfle_vfMicro<float16_t>;
template class Vmfle_vfMicro<float32_t>;
template class Vmfle_vfMicro<float64_t>;
;


// VectorFloatMaskFormat::vmflt_vf(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            flt<et>(ftype<et>(Vs2_vu[i]),\n                                    ftype_freg<et>(freg(Fs1_bits))));\n                    ', 'OPFVF', 'SimdFloatCmpOp'],{})


template <typename ElemType>
Fault
Vmflt_vfMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    uint64_t Fs1_bits = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
Fs1_bits = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;

    const uint32_t bit_offset = vlenb / sizeof(ElemType);
    const uint32_t offset = bit_offset * microIdx;

    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,
                            flt<et>(ftype<et>(Vs2[i]),
                                    ftype_freg<et>(freg(Fs1_bits))));
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vmflt_vfMicro<float16_t>;
template class Vmflt_vfMicro<float32_t>;
template class Vmflt_vfMicro<float64_t>;
;


// VectorFloatMaskFormat::vmfne_vf(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            !feq<et>(ftype<et>(Vs2_vu[i]),\n                                     ftype_freg<et>(freg(Fs1_bits))));\n                    ', 'OPFVF', 'SimdFloatCmpOp'],{})


template <typename ElemType>
Fault
Vmfne_vfMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    uint64_t Fs1_bits = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
Fs1_bits = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;

    const uint32_t bit_offset = vlenb / sizeof(ElemType);
    const uint32_t offset = bit_offset * microIdx;

    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,
                            !feq<et>(ftype<et>(Vs2[i]),
                                     ftype_freg<et>(freg(Fs1_bits))));
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vmfne_vfMicro<float16_t>;
template class Vmfne_vfMicro<float32_t>;
template class Vmfne_vfMicro<float64_t>;
;


// VectorFloatMaskFormat::vmfgt_vf(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            flt<et>(ftype_freg<et>(freg(Fs1_bits)),\n                                    ftype<et>(Vs2_vu[i])));\n                    ', 'OPFVF', 'SimdFloatCmpOp'],{})


template <typename ElemType>
Fault
Vmfgt_vfMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    uint64_t Fs1_bits = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
Fs1_bits = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;

    const uint32_t bit_offset = vlenb / sizeof(ElemType);
    const uint32_t offset = bit_offset * microIdx;

    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,
                            flt<et>(ftype_freg<et>(freg(Fs1_bits)),
                                    ftype<et>(Vs2[i])));
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vmfgt_vfMicro<float16_t>;
template class Vmfgt_vfMicro<float32_t>;
template class Vmfgt_vfMicro<float64_t>;
;


// VectorFloatMaskFormat::vmfge_vf(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            fle<et>(ftype_freg<et>(freg(Fs1_bits)),\n                                    ftype<et>(Vs2_vu[i])));\n                    ', 'OPFVF', 'SimdFloatCmpOp'],{})


template <typename ElemType>
Fault
Vmfge_vfMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    uint64_t Fs1_bits = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<uint8_t>();
Fs1_bits = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;

    const uint32_t bit_offset = vlenb / sizeof(ElemType);
    const uint32_t offset = bit_offset * microIdx;

    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,
                            fle<et>(ftype_freg<et>(freg(Fs1_bits)),
                                    ftype<et>(Vs2[i])));
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vmfge_vfMicro<float16_t>;
template class Vmfge_vfMicro<float32_t>;
template class Vmfge_vfMicro<float64_t>;
;


// VectorFloatFormat::vfdiv_vf(['\n                        auto fd = fdiv<et>(ftype<et>(Vs2_vu[i]),\n                                           ftype_freg<et>(freg(Fs1_bits)));\n                        Vd_vu[i] = fd.v;\n                    ', 'OPFVF', 'SimdFloatDivOp'],{})


template <typename ElemType>
Fault
Vfdiv_vfMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    uint64_t Fs1_bits = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Fs1_bits = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        auto fd = fdiv<et>(ftype<et>(Vs2[i]),
                                           ftype_freg<et>(freg(Fs1_bits)));
                        Vd[i] = fd.v;
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vfdiv_vfMicro<float16_t>;
template class Vfdiv_vfMicro<float32_t>;
template class Vfdiv_vfMicro<float64_t>;
;


// VectorFloatFormat::vfrdiv_vf(['\n                        auto fd = fdiv<et>(ftype_freg<et>(freg(Fs1_bits)),\n                                           ftype<et>(Vs2_vu[i]));\n                        Vd_vu[i] = fd.v;\n                    ', 'OPFVF', 'SimdFloatDivOp'],{})


template <typename ElemType>
Fault
Vfrdiv_vfMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    uint64_t Fs1_bits = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Fs1_bits = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        auto fd = fdiv<et>(ftype_freg<et>(freg(Fs1_bits)),
                                           ftype<et>(Vs2[i]));
                        Vd[i] = fd.v;
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vfrdiv_vfMicro<float16_t>;
template class Vfrdiv_vfMicro<float32_t>;
template class Vfrdiv_vfMicro<float64_t>;
;


// VectorFloatFormat::vfmul_vf(['\n                        auto fd = fmul<et>(ftype<et>(Vs2_vu[i]),\n                                           ftype_freg<et>(freg(Fs1_bits)));\n                        Vd_vu[i] = fd.v;\n                    ', 'OPFVF', 'SimdFloatMultOp'],{})


template <typename ElemType>
Fault
Vfmul_vfMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    uint64_t Fs1_bits = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Fs1_bits = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        auto fd = fmul<et>(ftype<et>(Vs2[i]),
                                           ftype_freg<et>(freg(Fs1_bits)));
                        Vd[i] = fd.v;
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vfmul_vfMicro<float16_t>;
template class Vfmul_vfMicro<float32_t>;
template class Vfmul_vfMicro<float64_t>;
;


// VectorFloatFormat::vfrsub_vf(['\n                        auto fd = fsub<et>(ftype_freg<et>(freg(Fs1_bits)),\n                                           ftype<et>(Vs2_vu[i]));\n                        Vd_vu[i] = fd.v;\n                    ', 'OPFVF', 'SimdFloatAddOp'],{})


template <typename ElemType>
Fault
Vfrsub_vfMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    uint64_t Fs1_bits = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Fs1_bits = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        auto fd = fsub<et>(ftype_freg<et>(freg(Fs1_bits)),
                                           ftype<et>(Vs2[i]));
                        Vd[i] = fd.v;
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vfrsub_vfMicro<float16_t>;
template class Vfrsub_vfMicro<float32_t>;
template class Vfrsub_vfMicro<float64_t>;
;


// VectorFloatFormat::vfmadd_vf(['\n                        auto fd = fmadd<et>(ftype<et>(Vs3_vu[i]),\n                                            ftype_freg<et>(freg(Fs1_bits)),\n                                            ftype<et>(Vs2_vu[i]));\n                        Vd_vu[i] = fd.v;\n                    ', 'OPFVF', 'SimdFloatMultAccOp'],{})


template <typename ElemType>
Fault
Vfmadd_vfMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    uint64_t Fs1_bits = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Fs1_bits = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        auto fd = fmadd<et>(ftype<et>(Vs3[i]),
                                            ftype_freg<et>(freg(Fs1_bits)),
                                            ftype<et>(Vs2[i]));
                        Vd[i] = fd.v;
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vfmadd_vfMicro<float16_t>;
template class Vfmadd_vfMicro<float32_t>;
template class Vfmadd_vfMicro<float64_t>;
;


// VectorFloatFormat::vfnmadd_vf(['\n                        auto fd = fmadd<et>(fneg(ftype<et>(Vs3_vu[i])),\n                                            ftype_freg<et>(freg(Fs1_bits)),\n                                            fneg(ftype<et>(Vs2_vu[i])));\n                        Vd_vu[i] = fd.v;\n                    ', 'OPFVF', 'SimdFloatMultAccOp'],{})


template <typename ElemType>
Fault
Vfnmadd_vfMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    uint64_t Fs1_bits = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Fs1_bits = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        auto fd = fmadd<et>(fneg(ftype<et>(Vs3[i])),
                                            ftype_freg<et>(freg(Fs1_bits)),
                                            fneg(ftype<et>(Vs2[i])));
                        Vd[i] = fd.v;
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vfnmadd_vfMicro<float16_t>;
template class Vfnmadd_vfMicro<float32_t>;
template class Vfnmadd_vfMicro<float64_t>;
;


// VectorFloatFormat::vfmsub_vf(['\n                        auto fd = fmadd<et>(ftype<et>(Vs3_vu[i]),\n                                            ftype_freg<et>(freg(Fs1_bits)),\n                                            fneg(ftype<et>(Vs2_vu[i])));\n                        Vd_vu[i] = fd.v;\n                    ', 'OPFVF', 'SimdFloatMultAccOp'],{})


template <typename ElemType>
Fault
Vfmsub_vfMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    uint64_t Fs1_bits = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Fs1_bits = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        auto fd = fmadd<et>(ftype<et>(Vs3[i]),
                                            ftype_freg<et>(freg(Fs1_bits)),
                                            fneg(ftype<et>(Vs2[i])));
                        Vd[i] = fd.v;
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vfmsub_vfMicro<float16_t>;
template class Vfmsub_vfMicro<float32_t>;
template class Vfmsub_vfMicro<float64_t>;
;


// VectorFloatFormat::vfnmsub_vf(['\n                        auto fd = fmadd<et>(fneg(ftype<et>(Vs3_vu[i])),\n                                            ftype_freg<et>(freg(Fs1_bits)),\n                                            ftype<et>(Vs2_vu[i]));\n                        Vd_vu[i] = fd.v;\n                    ', 'OPFVF', 'SimdFloatMultAccOp'],{})


template <typename ElemType>
Fault
Vfnmsub_vfMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    uint64_t Fs1_bits = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Fs1_bits = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        auto fd = fmadd<et>(fneg(ftype<et>(Vs3[i])),
                                            ftype_freg<et>(freg(Fs1_bits)),
                                            ftype<et>(Vs2[i]));
                        Vd[i] = fd.v;
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vfnmsub_vfMicro<float16_t>;
template class Vfnmsub_vfMicro<float32_t>;
template class Vfnmsub_vfMicro<float64_t>;
;


// VectorFloatFormat::vfmacc_vf(['\n                        auto fd = fmadd<et>(ftype_freg<et>(freg(Fs1_bits)),\n                                            ftype<et>(Vs2_vu[i]),\n                                            ftype<et>(Vs3_vu[i]));\n                        Vd_vu[i] = fd.v;\n                    ', 'OPFVF', 'SimdFloatMultAccOp'],{})


template <typename ElemType>
Fault
Vfmacc_vfMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    uint64_t Fs1_bits = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Fs1_bits = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        auto fd = fmadd<et>(ftype_freg<et>(freg(Fs1_bits)),
                                            ftype<et>(Vs2[i]),
                                            ftype<et>(Vs3[i]));
                        Vd[i] = fd.v;
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vfmacc_vfMicro<float16_t>;
template class Vfmacc_vfMicro<float32_t>;
template class Vfmacc_vfMicro<float64_t>;
;


// VectorFloatFormat::vfnmacc_vf(['\n                        auto fd = fmadd<et>(\n                            fneg(ftype_freg<et>(freg(Fs1_bits))),\n                            ftype<et>(Vs2_vu[i]),\n                            fneg(ftype<et>(Vs3_vu[i]))\n                        );\n                        Vd_vu[i] = fd.v;\n                    ', 'OPFVF', 'SimdFloatMultAccOp'],{})


template <typename ElemType>
Fault
Vfnmacc_vfMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    uint64_t Fs1_bits = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Fs1_bits = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        auto fd = fmadd<et>(
                            fneg(ftype_freg<et>(freg(Fs1_bits))),
                            ftype<et>(Vs2[i]),
                            fneg(ftype<et>(Vs3[i]))
                        );
                        Vd[i] = fd.v;
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vfnmacc_vfMicro<float16_t>;
template class Vfnmacc_vfMicro<float32_t>;
template class Vfnmacc_vfMicro<float64_t>;
;


// VectorFloatFormat::vfmsac_vf(['\n                        auto fd = fmadd<et>(ftype_freg<et>(freg(Fs1_bits)),\n                                            ftype<et>(Vs2_vu[i]),\n                                            fneg(ftype<et>(Vs3_vu[i])));\n                        Vd_vu[i] = fd.v;\n                    ', 'OPFVF', 'SimdFloatMultAccOp'],{})


template <typename ElemType>
Fault
Vfmsac_vfMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    uint64_t Fs1_bits = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Fs1_bits = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        auto fd = fmadd<et>(ftype_freg<et>(freg(Fs1_bits)),
                                            ftype<et>(Vs2[i]),
                                            fneg(ftype<et>(Vs3[i])));
                        Vd[i] = fd.v;
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vfmsac_vfMicro<float16_t>;
template class Vfmsac_vfMicro<float32_t>;
template class Vfmsac_vfMicro<float64_t>;
;


// VectorFloatFormat::vfnmsac_vf(['\n                        auto fd = fmadd<et>(\n                            fneg(ftype_freg<et>(freg(Fs1_bits))),\n                            ftype<et>(Vs2_vu[i]),\n                            ftype<et>(Vs3_vu[i])\n                        );\n                        Vd_vu[i] = fd.v;\n                    ', 'OPFVF', 'SimdFloatMultAccOp'],{})


template <typename ElemType>
Fault
Vfnmsac_vfMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu = decltype(et::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    uint64_t Fs1_bits = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Fs1_bits = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        auto fd = fmadd<et>(
                            fneg(ftype_freg<et>(freg(Fs1_bits))),
                            ftype<et>(Vs2[i]),
                            ftype<et>(Vs3[i])
                        );
                        Vd[i] = fd.v;
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vfnmsac_vfMicro<float16_t>;
template class Vfnmsac_vfMicro<float32_t>;
template class Vfnmsac_vfMicro<float64_t>;
;


// VectorFloatWideningFormat::vfwadd_vf(['\n                        auto fd = fadd<ewt>(\n                            fwiden(ftype<et>(Vs2_vu[i + offset])),\n                            fwiden(ftype_freg<et>(freg(Fs1_bits))));\n                        Vd_vwu[i] = fd.v;\n                    ', 'OPFVF', 'SimdFloatAddOp'],{})


template <typename ElemType>
Fault
Vfwadd_vfMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu [[maybe_unused]] = decltype(et::v);
    using ewt = typename double_width<et>::type;
    using vwu = decltype(ewt::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    uint64_t Fs1_bits = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwu>();
Fs1_bits = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vd % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned Vd group in Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            const int64_t vs2_emul = vlmul + 0;
            if (((vs2_emul < 0) && (VS2 == VD)) ||
                ((vs2_emul >= 0) &&
                 (VS2 < VD + num_microops - (1 << vs2_emul)) &&
                 (VD < VS2 + (1 << vs2_emul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        auto fd = fadd<ewt>(
                            fwiden(ftype<et>(Vs2[i + offset])),
                            fwiden(ftype_freg<et>(freg(Fs1_bits))));
                        Vd[i] = fd.v;
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vfwadd_vfMicro<float16_t>;
template class Vfwadd_vfMicro<float32_t>;
;


// VectorFloatWideningFormat::vfwsub_vf(['\n                        auto fd = fsub<ewt>(\n                            fwiden(ftype<et>(Vs2_vu[i + offset])),\n                            fwiden(ftype_freg<et>(freg(Fs1_bits))));\n                        Vd_vwu[i] = fd.v;\n                    ', 'OPFVF', 'SimdFloatAddOp'],{})


template <typename ElemType>
Fault
Vfwsub_vfMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu [[maybe_unused]] = decltype(et::v);
    using ewt = typename double_width<et>::type;
    using vwu = decltype(ewt::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    uint64_t Fs1_bits = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwu>();
Fs1_bits = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vd % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned Vd group in Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            const int64_t vs2_emul = vlmul + 0;
            if (((vs2_emul < 0) && (VS2 == VD)) ||
                ((vs2_emul >= 0) &&
                 (VS2 < VD + num_microops - (1 << vs2_emul)) &&
                 (VD < VS2 + (1 << vs2_emul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        auto fd = fsub<ewt>(
                            fwiden(ftype<et>(Vs2[i + offset])),
                            fwiden(ftype_freg<et>(freg(Fs1_bits))));
                        Vd[i] = fd.v;
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vfwsub_vfMicro<float16_t>;
template class Vfwsub_vfMicro<float32_t>;
;


// VectorFloatWideningFormat::vfwadd_wf(['\n                        auto fd = fadd<ewt>(\n                            ftype<ewt>(Vs2_vwu[i]),\n                            fwiden(ftype_freg<et>(freg(Fs1_bits))));\n                        Vd_vwu[i] = fd.v;\n                    ', 'OPFVF', 'SimdFloatAddOp'],{})


template <typename ElemType>
Fault
Vfwadd_wfMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu [[maybe_unused]] = decltype(et::v);
    using ewt = typename double_width<et>::type;
    using vwu = decltype(ewt::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    uint64_t Fs1_bits = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwu>();
Fs1_bits = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vwu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vd % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned Vd group in Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        auto fd = fadd<ewt>(
                            ftype<ewt>(Vs2[i]),
                            fwiden(ftype_freg<et>(freg(Fs1_bits))));
                        Vd[i] = fd.v;
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vfwadd_wfMicro<float16_t>;
template class Vfwadd_wfMicro<float32_t>;
;


// VectorFloatWideningFormat::vfwsub_wf(['\n                        auto fd = fsub<ewt>(\n                            ftype<ewt>(Vs2_vwu[i]),\n                            fwiden(ftype_freg<et>(freg(Fs1_bits))));\n                        Vd_vwu[i] = fd.v;\n                    ', 'OPFVF', 'SimdFloatAddOp'],{})


template <typename ElemType>
Fault
Vfwsub_wfMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu [[maybe_unused]] = decltype(et::v);
    using ewt = typename double_width<et>::type;
    using vwu = decltype(ewt::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    uint64_t Fs1_bits = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwu>();
Fs1_bits = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vwu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vd % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned Vd group in Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        auto fd = fsub<ewt>(
                            ftype<ewt>(Vs2[i]),
                            fwiden(ftype_freg<et>(freg(Fs1_bits))));
                        Vd[i] = fd.v;
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vfwsub_wfMicro<float16_t>;
template class Vfwsub_wfMicro<float32_t>;
;


// VectorFloatWideningFormat::vfwmul_vf(['\n                        auto fd = fmul<ewt>(\n                            fwiden(ftype<et>(Vs2_vu[i + offset])),\n                            fwiden(ftype_freg<et>(freg(Fs1_bits))));\n                        Vd_vwu[i] = fd.v;\n                    ', 'OPFVF', 'SimdFloatMultOp'],{})


template <typename ElemType>
Fault
Vfwmul_vfMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu [[maybe_unused]] = decltype(et::v);
    using ewt = typename double_width<et>::type;
    using vwu = decltype(ewt::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    uint64_t Fs1_bits = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwu>();
Fs1_bits = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vd % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned Vd group in Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            const int64_t vs2_emul = vlmul + 0;
            if (((vs2_emul < 0) && (VS2 == VD)) ||
                ((vs2_emul >= 0) &&
                 (VS2 < VD + num_microops - (1 << vs2_emul)) &&
                 (VD < VS2 + (1 << vs2_emul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        auto fd = fmul<ewt>(
                            fwiden(ftype<et>(Vs2[i + offset])),
                            fwiden(ftype_freg<et>(freg(Fs1_bits))));
                        Vd[i] = fd.v;
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vfwmul_vfMicro<float16_t>;
template class Vfwmul_vfMicro<float32_t>;
;


// VectorFloatWideningFormat::vfwmacc_vf(['\n                        auto fd = fmadd<ewt>(\n                            fwiden(ftype_freg<et>(freg(Fs1_bits))),\n                            fwiden(ftype<et>(Vs2_vu[i + offset])),\n                            ftype<ewt>(Vs3_vwu[i]));\n                        Vd_vwu[i] = fd.v;\n                    ', 'OPFVF', 'SimdFloatMultAccOp'],{})


template <typename ElemType>
Fault
Vfwmacc_vfMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu [[maybe_unused]] = decltype(et::v);
    using ewt = typename double_width<et>::type;
    using vwu = decltype(ewt::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    uint64_t Fs1_bits = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwu>();
Fs1_bits = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vwu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vd % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned Vd group in Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            const int64_t vs2_emul = vlmul + 0;
            if (((vs2_emul < 0) && (VS2 == VD)) ||
                ((vs2_emul >= 0) &&
                 (VS2 < VD + num_microops - (1 << vs2_emul)) &&
                 (VD < VS2 + (1 << vs2_emul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        auto fd = fmadd<ewt>(
                            fwiden(ftype_freg<et>(freg(Fs1_bits))),
                            fwiden(ftype<et>(Vs2[i + offset])),
                            ftype<ewt>(Vs3[i]));
                        Vd[i] = fd.v;
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vfwmacc_vfMicro<float16_t>;
template class Vfwmacc_vfMicro<float32_t>;
;


// VectorFloatWideningFormat::vfwnmacc_vf(['\n                        auto fd = fmadd<ewt>(\n                            fwiden(fneg(ftype_freg<et>(freg(Fs1_bits)))),\n                            fwiden(ftype<et>(Vs2_vu[i + offset])),\n                            fneg(ftype<ewt>(Vs3_vwu[i])));\n                        Vd_vwu[i] = fd.v;\n                    ', 'OPFVF', 'SimdFloatMultAccOp'],{})


template <typename ElemType>
Fault
Vfwnmacc_vfMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu [[maybe_unused]] = decltype(et::v);
    using ewt = typename double_width<et>::type;
    using vwu = decltype(ewt::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    uint64_t Fs1_bits = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwu>();
Fs1_bits = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vwu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vd % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned Vd group in Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            const int64_t vs2_emul = vlmul + 0;
            if (((vs2_emul < 0) && (VS2 == VD)) ||
                ((vs2_emul >= 0) &&
                 (VS2 < VD + num_microops - (1 << vs2_emul)) &&
                 (VD < VS2 + (1 << vs2_emul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        auto fd = fmadd<ewt>(
                            fwiden(fneg(ftype_freg<et>(freg(Fs1_bits)))),
                            fwiden(ftype<et>(Vs2[i + offset])),
                            fneg(ftype<ewt>(Vs3[i])));
                        Vd[i] = fd.v;
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vfwnmacc_vfMicro<float16_t>;
template class Vfwnmacc_vfMicro<float32_t>;
;


// VectorFloatWideningFormat::vfwmsac_vf(['\n                        auto fd = fmadd<ewt>(\n                            fwiden(ftype_freg<et>(freg(Fs1_bits))),\n                            fwiden(ftype<et>(Vs2_vu[i + offset])),\n                            fneg(ftype<ewt>(Vs3_vwu[i])));\n                        Vd_vwu[i] = fd.v;\n                    ', 'OPFVF', 'SimdFloatMultAccOp'],{})


template <typename ElemType>
Fault
Vfwmsac_vfMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu [[maybe_unused]] = decltype(et::v);
    using ewt = typename double_width<et>::type;
    using vwu = decltype(ewt::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    uint64_t Fs1_bits = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwu>();
Fs1_bits = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vwu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vd % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned Vd group in Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            const int64_t vs2_emul = vlmul + 0;
            if (((vs2_emul < 0) && (VS2 == VD)) ||
                ((vs2_emul >= 0) &&
                 (VS2 < VD + num_microops - (1 << vs2_emul)) &&
                 (VD < VS2 + (1 << vs2_emul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        auto fd = fmadd<ewt>(
                            fwiden(ftype_freg<et>(freg(Fs1_bits))),
                            fwiden(ftype<et>(Vs2[i + offset])),
                            fneg(ftype<ewt>(Vs3[i])));
                        Vd[i] = fd.v;
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vfwmsac_vfMicro<float16_t>;
template class Vfwmsac_vfMicro<float32_t>;
;


// VectorFloatWideningFormat::vfwnmsac_vf(['\n                        auto fd = fmadd<ewt>(\n                            fwiden(fneg(ftype_freg<et>(freg(Fs1_bits)))),\n                            fwiden(ftype<et>(Vs2_vu[i + offset])),\n                            ftype<ewt>(Vs3_vwu[i]));\n                        Vd_vwu[i] = fd.v;\n                    ', 'OPFVF', 'SimdFloatMultAccOp'],{})


template <typename ElemType>
Fault
Vfwnmsac_vfMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using et = ElemType;
    using vu [[maybe_unused]] = decltype(et::v);
    using ewt = typename double_width<et>::type;
    using vwu = decltype(ewt::v);

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    VRM_REQUIRED;

    uint64_t Fs1_bits = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwu>();
Fs1_bits = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vwu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vd % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned Vd group in Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            const int64_t vs2_emul = vlmul + 0;
            if (((vs2_emul < 0) && (VS2 == VD)) ||
                ((vs2_emul >= 0) &&
                 (VS2 < VD + num_microops - (1 << vs2_emul)) &&
                 (VD < VS2 + (1 << vs2_emul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
        std::feclearexcept(FE_ALL_EXCEPT);
        
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        auto fd = fmadd<ewt>(
                            fwiden(fneg(ftype_freg<et>(freg(Fs1_bits)))),
                            fwiden(ftype<et>(Vs2[i + offset])),
                            ftype<ewt>(Vs3[i]));
                        Vd[i] = fd.v;
                    }

            }
        
        xc->setMiscReg(MISCREG_FFLAGS_EXE, softfloat_exceptionFlags);
        softfloat_exceptionFlags = 0;
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vfwnmsac_vfMicro<float16_t>;
template class Vfwnmsac_vfMicro<float32_t>;
;


// Unknown::unknown(([], {}))

// VectorIntFormat::vaaddu_vx(['\n                        __uint128_t res = (__uint128_t)Vs2_vu[i] + Rs1_vu;\n                        res = int_rounding<__uint128_t>(res, 0 /* TODO */, 1);\n                        Vd_vu[i] = res >> 1;\n                    ', 'OPMVX', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vaaddu_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vu Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        __uint128_t res = (__uint128_t)Vs2[i] + Rs1;
                        res = int_rounding<__uint128_t>(res, 0 /* TODO */, 1);
                        Vd[i] = res >> 1;
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vaaddu_vxMicro<uint8_t>;
template class Vaaddu_vxMicro<uint16_t>;
template class Vaaddu_vxMicro<uint32_t>;
template class Vaaddu_vxMicro<uint64_t>;
;


// VectorIntFormat::vaadd_vx(['\n                        __uint128_t res = (__uint128_t)Vs2_vi[i] + Rs1_vi;\n                        res = int_rounding<__uint128_t>(res, 0 /* TODO */, 1);\n                        Vd_vi[i] = res >> 1;\n                    ', 'OPMVX', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vaadd_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vi Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        __uint128_t res = (__uint128_t)Vs2[i] + Rs1;
                        res = int_rounding<__uint128_t>(res, 0 /* TODO */, 1);
                        Vd[i] = res >> 1;
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vaadd_vxMicro<uint8_t>;
template class Vaadd_vxMicro<uint16_t>;
template class Vaadd_vxMicro<uint32_t>;
template class Vaadd_vxMicro<uint64_t>;
;


// VectorSlideUpFormat::vslide1up_vx((['\n                    const int offset = 1;\n                    const int microVlmax = vtype_VLMAX(machInst.vtype8,\n                        vlen, true);\n                    const int vregOffset = vdIdx - vs2Idx;\n                    const int offsetInVreg = offset - vregOffset * microVlmax;\n                    if (std::abs(offsetInVreg) < uint32_t(microVlmax)) {\n                        const int upperBound = (offsetInVreg >= 0)\n                            ? microVlmax - offsetInVreg\n                            : microVlmax + offsetInVreg;\n                        const int vdOffset = (offsetInVreg >= 0)\n                            ? offsetInVreg\n                            : 0;\n                        const int vs2Offset = (offsetInVreg >= 0)\n                            ? 0\n                            : -offsetInVreg;\n                        const int elemOffset = vdOffset + vdIdx * microVlmax;\n                        for (int i = 0;\n                            i < upperBound && i + vdOffset < microVl;\n                            i++) {\n                            if (this->vm || elem_mask(v0, i + elemOffset)) {\n                                Vd_vu[i + vdOffset] = Vs2_vu[i + vs2Offset];\n                            }\n                        }\n                        // TODO: dirty code\n                        if (vdIdx == 0 && vs2Idx == 0 &&\n                                (this->vm || elem_mask(v0, 0))) {\n                            tmp_d0.as<vu>()[0] = Rs1_vu;\n                        }\n                    }\n                ', 'OPIVX', 'SimdMiscOp'], {}))


template<typename ElemType>
Fault
Vslide1up_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vu Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    [[maybe_unused]]const uint32_t vlmax = vtype_VLMAX(vtype, vlen);

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    
                    const int offset = 1;
                    const int microVlmax = vtype_VLMAX(machInst.vtype8,
                        vlen, true);
                    const int vregOffset = vdIdx - vs2Idx;
                    const int offsetInVreg = offset - vregOffset * microVlmax;
                    if (std::abs(offsetInVreg) < uint32_t(microVlmax)) {
                        const int upperBound = (offsetInVreg >= 0)
                            ? microVlmax - offsetInVreg
                            : microVlmax + offsetInVreg;
                        const int vdOffset = (offsetInVreg >= 0)
                            ? offsetInVreg
                            : 0;
                        const int vs2Offset = (offsetInVreg >= 0)
                            ? 0
                            : -offsetInVreg;
                        const int elemOffset = vdOffset + vdIdx * microVlmax;
                        for (int i = 0;
                            i < upperBound && i + vdOffset < microVl;
                            i++) {
                            if (this->vm || elem_mask(v0, i + elemOffset)) {
                                Vd[i + vdOffset] = Vs2[i + vs2Offset];
                            }
                        }
                        // TODO: dirty code
                        if (vdIdx == 0 && vs2Idx == 0 &&
                                (this->vm || elem_mask(v0, 0))) {
                            tmp_d0.as<vu>()[0] = Rs1;
                        }
                    }
                ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
};

template class Vslide1up_vxMicro<uint8_t>;
template class Vslide1up_vxMicro<uint16_t>;
template class Vslide1up_vxMicro<uint32_t>;
template class Vslide1up_vxMicro<uint64_t>;
;


// VectorSlideDownFormat::vslide1down_vx((['\n                    const int offset = 1;\n                    const int microVlmax = vtype_VLMAX(machInst.vtype8,\n                        vlen, true);\n                    const int vregOffset = vs2Idx - vdIdx;\n                    const int offsetInVreg = offset - vregOffset * microVlmax;\n                    const int numVs2s = vtype_regs_per_group(vtype);\n                    if (std::abs(offsetInVreg) < uint32_t(microVlmax)) {\n                        const bool needZeroTail = numVs2s == vs2Idx + 1;\n                        const int upperBound = (offsetInVreg >= 0)\n                            ? microVlmax - offsetInVreg\n                            : microVlmax + offsetInVreg;\n                        const int vdOffset = (offsetInVreg >= 0)\n                            ? 0\n                            : -offsetInVreg;\n                        const int vs2Offset = (offsetInVreg >= 0)\n                            ? offsetInVreg\n                            : 0;\n                        const int elemIdxBase = vdIdx * microVlmax;\n                        vreg_t resVreg;\n                        auto res = resVreg.as<vu>();\n                        for (int i = 0;\n                            i < upperBound && i + vdOffset < microVl;\n                            i++) {\n                            res[i + vdOffset] = Vs2_vu[i + vs2Offset];\n                        }\n                        if (needZeroTail) {\n                            for (int i = upperBound + vdOffset;\n                                i < microVlmax; i++) {\n                                res[i] = 0;\n                            }\n                        }\n                        for (int i = vdOffset; i < microVl ; i++) {\n                            if (vm || elem_mask(v0, i + elemIdxBase)) {\n                                Vd_vu[i] = (i + elemIdxBase != machInst.vl - 1)\n                                    ? res[i]\n                                    : Rs1_vu;\n                            }\n                        }\n                    }\n                ', 'OPIVX', 'SimdMiscOp'], {}))


template<typename ElemType>
Fault
Vslide1down_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vu Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    [[maybe_unused]]const uint32_t vlmax = vtype_VLMAX(vtype, vlen);

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    
                    const int offset = 1;
                    const int microVlmax = vtype_VLMAX(machInst.vtype8,
                        vlen, true);
                    const int vregOffset = vs2Idx - vdIdx;
                    const int offsetInVreg = offset - vregOffset * microVlmax;
                    const int numVs2s = vtype_regs_per_group(vtype);
                    if (std::abs(offsetInVreg) < uint32_t(microVlmax)) {
                        const bool needZeroTail = numVs2s == vs2Idx + 1;
                        const int upperBound = (offsetInVreg >= 0)
                            ? microVlmax - offsetInVreg
                            : microVlmax + offsetInVreg;
                        const int vdOffset = (offsetInVreg >= 0)
                            ? 0
                            : -offsetInVreg;
                        const int vs2Offset = (offsetInVreg >= 0)
                            ? offsetInVreg
                            : 0;
                        const int elemIdxBase = vdIdx * microVlmax;
                        vreg_t resVreg;
                        auto res = resVreg.as<vu>();
                        for (int i = 0;
                            i < upperBound && i + vdOffset < microVl;
                            i++) {
                            res[i + vdOffset] = Vs2[i + vs2Offset];
                        }
                        if (needZeroTail) {
                            for (int i = upperBound + vdOffset;
                                i < microVlmax; i++) {
                                res[i] = 0;
                            }
                        }
                        for (int i = vdOffset; i < microVl ; i++) {
                            if (vm || elem_mask(v0, i + elemIdxBase)) {
                                Vd[i] = (i + elemIdxBase != machInst.vl - 1)
                                    ? res[i]
                                    : Rs1;
                            }
                        }
                    }
                ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
};

template class Vslide1down_vxMicro<uint8_t>;
template class Vslide1down_vxMicro<uint16_t>;
template class Vslide1down_vxMicro<uint32_t>;
template class Vslide1down_vxMicro<uint64_t>;
;


// VectorNonSplitFormat::vmv_s_x((['\n                            if (this->vl) {\n                                Vd_vu[0] = Rs1_vu;\n                            }\n                        ', 'OPMVX', 'SimdMiscOp'], {}))


template <typename ElemType>
Fault
Vmv_s_x<ElemType>::execute(ExecContext* xc,
                                    trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vu Rs1 = 0;
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Rs1 = xc->getRegOperand(this, 0);
;
    ;
    
                            if (this->vl) {
                                Vd[0] = Rs1;
                            }
                        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vmv_s_x<uint8_t>;
template class Vmv_s_x<uint16_t>;
template class Vmv_s_x<uint32_t>;
template class Vmv_s_x<uint64_t>;
;


// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// VectorIntFormat::vasubu_vx(['\n                        __uint128_t res = (__uint128_t)Vs2_vu[i] - Rs1_vu;\n                        res = int_rounding<__uint128_t>(res, 0 /* TODO */, 1);\n                        Vd_vu[i] = res >> 1;\n                    ', 'OPMVX', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vasubu_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vu Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        __uint128_t res = (__uint128_t)Vs2[i] - Rs1;
                        res = int_rounding<__uint128_t>(res, 0 /* TODO */, 1);
                        Vd[i] = res >> 1;
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vasubu_vxMicro<uint8_t>;
template class Vasubu_vxMicro<uint16_t>;
template class Vasubu_vxMicro<uint32_t>;
template class Vasubu_vxMicro<uint64_t>;
;


// VectorIntFormat::vasub_vx(['\n                        __uint128_t res = (__uint128_t)Vs2_vi[i] - Rs1_vi;\n                        res = int_rounding<__uint128_t>(res, 0 /* TODO */, 1);\n                        Vd_vi[i] = res >> 1;\n                    ', 'OPMVX', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vasub_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vi Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        __uint128_t res = (__uint128_t)Vs2[i] - Rs1;
                        res = int_rounding<__uint128_t>(res, 0 /* TODO */, 1);
                        Vd[i] = res >> 1;
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vasub_vxMicro<uint8_t>;
template class Vasub_vxMicro<uint16_t>;
template class Vasub_vxMicro<uint32_t>;
template class Vasub_vxMicro<uint64_t>;
;


// VectorIntFormat::vdivu_vx(['\n                        Vd_vu[i] = divu<vu>(Vs2_vu[i], Rs1_vu);\n                    ', 'OPMVX', 'SimdDivOp'],{})


template <typename ElemType>
Fault
Vdivu_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vu Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = divu<vu>(Vs2[i], Rs1);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vdivu_vxMicro<uint8_t>;
template class Vdivu_vxMicro<uint16_t>;
template class Vdivu_vxMicro<uint32_t>;
template class Vdivu_vxMicro<uint64_t>;
;


// VectorIntFormat::vdiv_vx(['\n                        Vd_vi[i] = div<vi>(Vs2_vi[i], Rs1_vi);\n                    ', 'OPMVX', 'SimdDivOp'],{})


template <typename ElemType>
Fault
Vdiv_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vi Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = div<vi>(Vs2[i], Rs1);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vdiv_vxMicro<uint8_t>;
template class Vdiv_vxMicro<uint16_t>;
template class Vdiv_vxMicro<uint32_t>;
template class Vdiv_vxMicro<uint64_t>;
;


// VectorIntFormat::vremu_vx(['\n                        Vd_vu[i] = remu<vu>(Vs2_vu[i], Rs1_vu);\n                    ', 'OPMVX', 'SimdDivOp'],{})


template <typename ElemType>
Fault
Vremu_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vu Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = remu<vu>(Vs2[i], Rs1);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vremu_vxMicro<uint8_t>;
template class Vremu_vxMicro<uint16_t>;
template class Vremu_vxMicro<uint32_t>;
template class Vremu_vxMicro<uint64_t>;
;


// VectorIntFormat::vrem_vx(['\n                        Vd_vi[i] = rem<vi>(Vs2_vi[i], Rs1_vi);\n                    ', 'OPMVX', 'SimdDivOp'],{})


template <typename ElemType>
Fault
Vrem_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vi Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = rem<vi>(Vs2[i], Rs1);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vrem_vxMicro<uint8_t>;
template class Vrem_vxMicro<uint16_t>;
template class Vrem_vxMicro<uint32_t>;
template class Vrem_vxMicro<uint64_t>;
;


// VectorIntFormat::vmulhu_vx(['\n                        Vd_vu[i] = mulhu<vu>(Vs2_vu[i], Rs1_vu);\n                    ', 'OPMVX', 'SimdMultOp'],{})


template <typename ElemType>
Fault
Vmulhu_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vu Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = mulhu<vu>(Vs2[i], Rs1);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vmulhu_vxMicro<uint8_t>;
template class Vmulhu_vxMicro<uint16_t>;
template class Vmulhu_vxMicro<uint32_t>;
template class Vmulhu_vxMicro<uint64_t>;
;


// VectorIntFormat::vmul_vx(['\n                        Vd_vi[i] = Vs2_vi[i] * Rs1_vi;\n                    ', 'OPMVX', 'SimdMultOp'],{})


template <typename ElemType>
Fault
Vmul_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vi Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = Vs2[i] * Rs1;
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vmul_vxMicro<uint8_t>;
template class Vmul_vxMicro<uint16_t>;
template class Vmul_vxMicro<uint32_t>;
template class Vmul_vxMicro<uint64_t>;
;


// VectorIntFormat::vmulhsu_vx(['\n                        Vd_vi[i] = mulhsu<vi>(Vs2_vi[i], Rs1_vu);\n                    ', 'OPMVX', 'SimdMultOp'],{})


template <typename ElemType>
Fault
Vmulhsu_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vu Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = mulhsu<vi>(Vs2[i], Rs1);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vmulhsu_vxMicro<uint8_t>;
template class Vmulhsu_vxMicro<uint16_t>;
template class Vmulhsu_vxMicro<uint32_t>;
template class Vmulhsu_vxMicro<uint64_t>;
;


// VectorIntFormat::vmulh_vx(['\n                        Vd_vi[i] = mulh<vi>(Vs2_vi[i], Rs1_vi);\n                    ', 'OPMVX', 'SimdMultOp'],{})


template <typename ElemType>
Fault
Vmulh_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vi Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = mulh<vi>(Vs2[i], Rs1);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vmulh_vxMicro<uint8_t>;
template class Vmulh_vxMicro<uint16_t>;
template class Vmulh_vxMicro<uint32_t>;
template class Vmulh_vxMicro<uint64_t>;
;


// VectorIntFormat::vmadd_vx(['\n                        Vd_vi[i] = Vs3_vi[i] * Rs1_vi + Vs2_vi[i];\n                    ', 'OPMVX', 'SimdMultAccOp'],{})


template <typename ElemType>
Fault
Vmadd_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vi Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = Vs3[i] * Rs1 + Vs2[i];
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vmadd_vxMicro<uint8_t>;
template class Vmadd_vxMicro<uint16_t>;
template class Vmadd_vxMicro<uint32_t>;
template class Vmadd_vxMicro<uint64_t>;
;


// VectorIntFormat::vnmsub_vx(['\n                        Vd_vi[i] = -(Vs3_vi[i] * Rs1_vi) + Vs2_vi[i];\n                    ', 'OPMVX', 'SimdMultAccOp'],{})


template <typename ElemType>
Fault
Vnmsub_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vi Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = -(Vs3[i] * Rs1) + Vs2[i];
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vnmsub_vxMicro<uint8_t>;
template class Vnmsub_vxMicro<uint16_t>;
template class Vnmsub_vxMicro<uint32_t>;
template class Vnmsub_vxMicro<uint64_t>;
;


// VectorIntFormat::vmacc_vx(['\n                        Vd_vi[i] = Vs2_vi[i] * Rs1_vi + Vs3_vi[i];\n                    ', 'OPMVX', 'SimdMultAccOp'],{})


template <typename ElemType>
Fault
Vmacc_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vi Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = Vs2[i] * Rs1 + Vs3[i];
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vmacc_vxMicro<uint8_t>;
template class Vmacc_vxMicro<uint16_t>;
template class Vmacc_vxMicro<uint32_t>;
template class Vmacc_vxMicro<uint64_t>;
;


// VectorIntFormat::vnmsac_vx(['\n                        Vd_vi[i] = -(Vs2_vi[i] * Rs1_vi) + Vs3_vi[i];\n                    ', 'OPMVX', 'SimdMultAccOp'],{})


template <typename ElemType>
Fault
Vnmsac_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    vi Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vi>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;
    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + vtype_VLMAX(vtype, vlen, true) * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = -(Vs2[i] * Rs1) + Vs3[i];
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;

    return NoFault;
}

template class Vnmsac_vxMicro<uint8_t>;
template class Vnmsac_vxMicro<uint16_t>;
template class Vnmsac_vxMicro<uint32_t>;
template class Vnmsac_vxMicro<uint64_t>;
;


// VectorIntWideningFormat::vwaddu_vx(['\n                        Vd_vwu[i] = vwu(Vs2_vu[i + offset]) + vwu(Rs1_vu);\n                    ', 'OPMVX', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vwaddu_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    using vwu [[maybe_unused]] = typename double_width<vu>::type;
    using vwi [[maybe_unused]] = typename double_width<vi>::type;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    vu Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vd % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned Vd group in Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            const int64_t vs2_emul = vlmul + 0;
            if (((vs2_emul < 0) && (VS2 == VD)) ||
                ((vs2_emul >= 0) &&
                 (VS2 < VD + num_microops - (1 << vs2_emul)) &&
                 (VD < VS2 + (1 << vs2_emul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = vwu(Vs2[i + offset]) + vwu(Rs1);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vwaddu_vxMicro<uint8_t>;
template class Vwaddu_vxMicro<uint16_t>;
template class Vwaddu_vxMicro<uint32_t>;
;


// VectorIntWideningFormat::vwadd_vx(['\n                        Vd_vwi[i] = vwi(Vs2_vi[i + offset]) + vwi(Rs1_vi);\n                    ', 'OPMVX', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vwadd_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    using vwu [[maybe_unused]] = typename double_width<vu>::type;
    using vwi [[maybe_unused]] = typename double_width<vi>::type;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    vi Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwi>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vd % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned Vd group in Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            const int64_t vs2_emul = vlmul + 0;
            if (((vs2_emul < 0) && (VS2 == VD)) ||
                ((vs2_emul >= 0) &&
                 (VS2 < VD + num_microops - (1 << vs2_emul)) &&
                 (VD < VS2 + (1 << vs2_emul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = vwi(Vs2[i + offset]) + vwi(Rs1);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vwadd_vxMicro<uint8_t>;
template class Vwadd_vxMicro<uint16_t>;
template class Vwadd_vxMicro<uint32_t>;
;


// VectorIntWideningFormat::vwsubu_vx(['\n                        Vd_vwu[i] = vwu(Vs2_vu[i + offset]) - vwu(Rs1_vu);\n                    ', 'OPMVX', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vwsubu_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    using vwu [[maybe_unused]] = typename double_width<vu>::type;
    using vwi [[maybe_unused]] = typename double_width<vi>::type;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    vu Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vd % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned Vd group in Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            const int64_t vs2_emul = vlmul + 0;
            if (((vs2_emul < 0) && (VS2 == VD)) ||
                ((vs2_emul >= 0) &&
                 (VS2 < VD + num_microops - (1 << vs2_emul)) &&
                 (VD < VS2 + (1 << vs2_emul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = vwu(Vs2[i + offset]) - vwu(Rs1);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vwsubu_vxMicro<uint8_t>;
template class Vwsubu_vxMicro<uint16_t>;
template class Vwsubu_vxMicro<uint32_t>;
;


// VectorIntWideningFormat::vwsub_vx(['\n                        Vd_vwi[i] = vwi(Vs2_vi[i + offset]) - vwi(Rs1_vi);\n                    ', 'OPMVX', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vwsub_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    using vwu [[maybe_unused]] = typename double_width<vu>::type;
    using vwi [[maybe_unused]] = typename double_width<vi>::type;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    vi Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwi>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vd % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned Vd group in Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            const int64_t vs2_emul = vlmul + 0;
            if (((vs2_emul < 0) && (VS2 == VD)) ||
                ((vs2_emul >= 0) &&
                 (VS2 < VD + num_microops - (1 << vs2_emul)) &&
                 (VD < VS2 + (1 << vs2_emul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = vwi(Vs2[i + offset]) - vwi(Rs1);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vwsub_vxMicro<uint8_t>;
template class Vwsub_vxMicro<uint16_t>;
template class Vwsub_vxMicro<uint32_t>;
;


// VectorIntWideningFormat::vwaddu_wx(['\n                        Vd_vwu[i] = Vs2_vwu[i] + vwu(Rs1_vu);\n                    ', 'OPMVX', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vwaddu_wxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    using vwu [[maybe_unused]] = typename double_width<vu>::type;
    using vwi [[maybe_unused]] = typename double_width<vi>::type;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    vu Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vwu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vd % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned Vd group in Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = Vs2[i] + vwu(Rs1);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vwaddu_wxMicro<uint8_t>;
template class Vwaddu_wxMicro<uint16_t>;
template class Vwaddu_wxMicro<uint32_t>;
;


// VectorIntWideningFormat::vwadd_wx(['\n                        Vd_vwi[i] = Vs2_vwi[i] + vwi(Rs1_vi);\n                    ', 'OPMVX', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vwadd_wxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    using vwu [[maybe_unused]] = typename double_width<vu>::type;
    using vwi [[maybe_unused]] = typename double_width<vi>::type;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    vi Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwi>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vwi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vd % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned Vd group in Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = Vs2[i] + vwi(Rs1);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vwadd_wxMicro<uint8_t>;
template class Vwadd_wxMicro<uint16_t>;
template class Vwadd_wxMicro<uint32_t>;
;


// VectorIntWideningFormat::vwsubu_wx(['\n                        Vd_vwu[i] = Vs2_vwu[i] - vwu(Rs1_vu);\n                    ', 'OPMVX', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vwsubu_wxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    using vwu [[maybe_unused]] = typename double_width<vu>::type;
    using vwi [[maybe_unused]] = typename double_width<vi>::type;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    vu Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vwu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vd % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned Vd group in Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = Vs2[i] - vwu(Rs1);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vwsubu_wxMicro<uint8_t>;
template class Vwsubu_wxMicro<uint16_t>;
template class Vwsubu_wxMicro<uint32_t>;
;


// VectorIntWideningFormat::vwsub_wx(['\n                        Vd_vwi[i] = Vs2_vwi[i] - vwi(Rs1_vi);\n                    ', 'OPMVX', 'SimdAddOp'],{})


template <typename ElemType>
Fault
Vwsub_wxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    using vwu [[maybe_unused]] = typename double_width<vu>::type;
    using vwi [[maybe_unused]] = typename double_width<vi>::type;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    vi Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwi>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vwi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vd % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned Vd group in Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = Vs2[i] - vwi(Rs1);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vwsub_wxMicro<uint8_t>;
template class Vwsub_wxMicro<uint16_t>;
template class Vwsub_wxMicro<uint32_t>;
;


// VectorIntWideningFormat::vwmulu_vx(['\n                        Vd_vwu[i] = vwu(Vs2_vu[i + offset]) * vwu(Rs1_vu);\n                    ', 'OPMVX', 'SimdMultOp'],{})


template <typename ElemType>
Fault
Vwmulu_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    using vwu [[maybe_unused]] = typename double_width<vu>::type;
    using vwi [[maybe_unused]] = typename double_width<vi>::type;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    vu Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vd % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned Vd group in Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            const int64_t vs2_emul = vlmul + 0;
            if (((vs2_emul < 0) && (VS2 == VD)) ||
                ((vs2_emul >= 0) &&
                 (VS2 < VD + num_microops - (1 << vs2_emul)) &&
                 (VD < VS2 + (1 << vs2_emul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = vwu(Vs2[i + offset]) * vwu(Rs1);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vwmulu_vxMicro<uint8_t>;
template class Vwmulu_vxMicro<uint16_t>;
template class Vwmulu_vxMicro<uint32_t>;
;


// VectorIntWideningFormat::vwmulsu_vx(['\n                        Vd_vwi[i] = vwi(Vs2_vi[i + offset]) * vwu(Rs1_vu);\n                    ', 'OPMVX', 'SimdMultOp'],{})


template <typename ElemType>
Fault
Vwmulsu_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    using vwu [[maybe_unused]] = typename double_width<vu>::type;
    using vwi [[maybe_unused]] = typename double_width<vi>::type;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    vu Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwi>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vd % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned Vd group in Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            const int64_t vs2_emul = vlmul + 0;
            if (((vs2_emul < 0) && (VS2 == VD)) ||
                ((vs2_emul >= 0) &&
                 (VS2 < VD + num_microops - (1 << vs2_emul)) &&
                 (VD < VS2 + (1 << vs2_emul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = vwi(Vs2[i + offset]) * vwu(Rs1);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vwmulsu_vxMicro<uint8_t>;
template class Vwmulsu_vxMicro<uint16_t>;
template class Vwmulsu_vxMicro<uint32_t>;
;


// VectorIntWideningFormat::vwmul_vx(['\n                        Vd_vwi[i] = vwi(Vs2_vi[i + offset]) * vwi(Rs1_vi);\n                    ', 'OPMVX', 'SimdMultOp'],{})


template <typename ElemType>
Fault
Vwmul_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    using vwu [[maybe_unused]] = typename double_width<vu>::type;
    using vwi [[maybe_unused]] = typename double_width<vi>::type;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    vi Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwi>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vd % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned Vd group in Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            const int64_t vs2_emul = vlmul + 0;
            if (((vs2_emul < 0) && (VS2 == VD)) ||
                ((vs2_emul >= 0) &&
                 (VS2 < VD + num_microops - (1 << vs2_emul)) &&
                 (VD < VS2 + (1 << vs2_emul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = vwi(Vs2[i + offset]) * vwi(Rs1);
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vwmul_vxMicro<uint8_t>;
template class Vwmul_vxMicro<uint16_t>;
template class Vwmul_vxMicro<uint32_t>;
;


// VectorIntWideningFormat::vwmaccu_vx(['\n                        Vd_vwu[i] = vwu(Rs1_vu) * vwu(Vs2_vu[i + offset])\n                                + Vs3_vwu[i];\n                    ', 'OPMVX', 'SimdMultAccOp'],{})


template <typename ElemType>
Fault
Vwmaccu_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    using vwu [[maybe_unused]] = typename double_width<vu>::type;
    using vwi [[maybe_unused]] = typename double_width<vi>::type;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    vu Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwu>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vwu>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vd % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned Vd group in Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            const int64_t vs2_emul = vlmul + 0;
            if (((vs2_emul < 0) && (VS2 == VD)) ||
                ((vs2_emul >= 0) &&
                 (VS2 < VD + num_microops - (1 << vs2_emul)) &&
                 (VD < VS2 + (1 << vs2_emul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = vwu(Rs1) * vwu(Vs2[i + offset])
                                + Vs3[i];
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vwmaccu_vxMicro<uint8_t>;
template class Vwmaccu_vxMicro<uint16_t>;
template class Vwmaccu_vxMicro<uint32_t>;
;


// VectorIntWideningFormat::vwmacc_vx(['\n                        Vd_vwi[i] = vwi(Rs1_vi) * vwi(Vs2_vi[i + offset])\n                                + Vs3_vwi[i];\n                    ', 'OPMVX', 'SimdMultAccOp'],{})


template <typename ElemType>
Fault
Vwmacc_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    using vwu [[maybe_unused]] = typename double_width<vu>::type;
    using vwi [[maybe_unused]] = typename double_width<vi>::type;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    vi Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwi>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vwi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vd % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned Vd group in Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            const int64_t vs2_emul = vlmul + 0;
            if (((vs2_emul < 0) && (VS2 == VD)) ||
                ((vs2_emul >= 0) &&
                 (VS2 < VD + num_microops - (1 << vs2_emul)) &&
                 (VD < VS2 + (1 << vs2_emul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = vwi(Rs1) * vwi(Vs2[i + offset])
                                + Vs3[i];
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vwmacc_vxMicro<uint8_t>;
template class Vwmacc_vxMicro<uint16_t>;
template class Vwmacc_vxMicro<uint32_t>;
;


// VectorIntWideningFormat::vwmaccus_vx(['\n                        Vd_vwi[i] = vwu(Rs1_vu) * vwi(Vs2_vi[i + offset])\n                                + Vs3_vwi[i];\n                    ', 'OPMVX', 'SimdMultAccOp'],{})


template <typename ElemType>
Fault
Vwmaccus_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    using vwu [[maybe_unused]] = typename double_width<vu>::type;
    using vwi [[maybe_unused]] = typename double_width<vi>::type;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    vu Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwi>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vi>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vwi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vd % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned Vd group in Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            const int64_t vs2_emul = vlmul + 0;
            if (((vs2_emul < 0) && (VS2 == VD)) ||
                ((vs2_emul >= 0) &&
                 (VS2 < VD + num_microops - (1 << vs2_emul)) &&
                 (VD < VS2 + (1 << vs2_emul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = vwu(Rs1) * vwi(Vs2[i + offset])
                                + Vs3[i];
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vwmaccus_vxMicro<uint8_t>;
template class Vwmaccus_vxMicro<uint16_t>;
template class Vwmaccus_vxMicro<uint32_t>;
;


// VectorIntWideningFormat::vwmaccsu_vx(['\n                        Vd_vwi[i] = vwi(Rs1_vi) * vwu(Vs2_vu[i + offset])\n                                + Vs3_vwi[i];\n                    ', 'OPMVX', 'SimdMultAccOp'],{})


template <typename ElemType>
Fault
Vwmaccsu_vxMicro<ElemType>::execute(ExecContext* xc,
                                  trace::InstRecord* traceData) const
{
    using vu [[maybe_unused]] = std::make_unsigned_t<ElemType>;
    using vi [[maybe_unused]] = std::make_signed_t<ElemType>;
    using vwu [[maybe_unused]] = typename double_width<vu>::type;
    using vwi [[maybe_unused]] = typename double_width<vi>::type;
    [[maybe_unused]] constexpr size_t sew = sizeof(vu) * 8;

    MISA misa = xc->readMiscReg(MISCREG_ISA);
    STATUS status = xc->readMiscReg(MISCREG_STATUS);
    if (!misa.rvv || status.vs == VPUStatus::OFF) {
        return std::make_shared<IllegalInstFault>(
            "RVV is disabled or VPU is off", machInst);
    }
    vi Rs1 = 0;
	/* Vars for Vs2*/	/* End vars for Vs2 */
	/* Vars for Vs3*/	/* End vars for Vs3 */
;
    		auto &tmp_d0 = 
		    *(RiscvISAInst::VecRegContainer *)
		    xc->getWritableRegOperand(
		        this, 0);
		auto Vd = tmp_d0.as<vwi>();
Rs1 = xc->getRegOperand(this, 0);
		RiscvISAInst::VecRegContainer tmp_s1;
		xc->getRegOperand(this, 1,
		    &tmp_s1);
		auto Vs2 = tmp_s1.as<vu>();
		RiscvISAInst::VecRegContainer tmp_s2;
		xc->getRegOperand(this, 2,
		    &tmp_s2);
		auto Vs3 = tmp_s2.as<vwi>();
;
    [[maybe_unused]] uint32_t vlenb = vlen >> 3;
;

    if (machInst.vill)
        return std::make_shared<IllegalInstFault>("VILL is set", machInst);

    status.vs = VPUStatus::DIRTY;
    xc->setMiscReg(MISCREG_STATUS, status);

    const int64_t vlmul = vtype_vlmul(machInst.vtype8);
    const int32_t t_micro_vlmax = vtype_VLMAX(machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    [[maybe_unused]] const size_t offset =
        (this->microIdx % 2 == 0) ? 0 : micro_vlmax;

    
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!machInst.vm) {
                xc->getRegOperand(this, _numSrcRegs-1, &tmp_v0);
                v0 = tmp_v0.as<uint8_t>();
            }
        ;
    COPY_OLD_VD(2);;
    
            const uint32_t num_microops =
                1 << std::max<int64_t>(0, vlmul + 1);
            if ((machInst.vd % alignToPowerOfTwo(num_microops)) != 0) {
                std::string error =
                    csprintf("Unaligned Vd group in Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            const int64_t vs2_emul = vlmul + 0;
            if (((vs2_emul < 0) && (VS2 == VD)) ||
                ((vs2_emul >= 0) &&
                 (VS2 < VD + num_microops - (1 << vs2_emul)) &&
                 (VD < VS2 + (1 << vs2_emul)))) {
                // A destination vector register group can overlap a source
                // vector register group if the destination EEW is greater than
                // the source EEW, the source EMUL is at least 1, and the
                // overlap is in the highest- numbered part of the destination
                // register group.
                std::string error =
                    csprintf("Unsupported overlap in VS2 and VD for "
                             "Widening op");
                return std::make_shared<IllegalInstFault>(error, machInst);
            }
            
            for (uint32_t i = 0; i < this->microVl; i++) {
                
            uint32_t ei = i + micro_vlmax * this->microIdx;
            if (this->vm || elem_mask(v0, ei)) {

                        Vd[i] = vwi(Rs1) * vwu(Vs2[i + offset])
                                + Vs3[i];
                    }

            }
        ;
    
        if (traceData) {
            traceData->setData(vecRegClass, &tmp_d0);
        }
        ;
    return NoFault;
}

template class Vwmaccsu_vxMicro<uint8_t>;
template class Vwmaccsu_vxMicro<uint16_t>;
template class Vwmaccsu_vxMicro<uint32_t>;
;


// Unknown::unknown(([], {}))

// VConfOp::vsetvli(['\n                        uint64_t rd_bits = RD;\n                        uint64_t rs1_bits = RS1;\n                        uint64_t requested_vl = Rs1_ud;\n                        uint64_t requested_vtype = zimm11;\n                        uint32_t vlmax = getVlmax(Vtype, vlen);\n                        uint32_t current_vl = VL;\n                    ', '\n                        Rd_ud = new_vl;\n                        VL = new_vl;\n                        Vtype = new_vtype;\n                    ', 'VSetVlDeclare', 'VSetVliBranchTarget', 'SimdConfigOp', 'IsUncondControl', 'IsIndirectControl'],{})

    VTYPE
    Vsetvli::getNewVtype(
        VTYPE oldVtype, VTYPE reqVtype)  const
    {
        VTYPE newVtype = oldVtype;
        if (oldVtype != reqVtype) {
            newVtype = reqVtype;

            float vflmul = getVflmul(newVtype.vlmul);

            uint32_t sew = getSew(newVtype.vsew);

            uint32_t newVill =
                !(vflmul >= 0.125 && vflmul <= 8) ||
                    (float)sew > std::min(vflmul, 1.0f) * (float)elen ||
                    bits(reqVtype, 62, 8) != 0;
            if (newVill) {
                newVtype = 0;
                newVtype.vill = 1;
            }
        }
        return newVtype;
    }

    uint32_t
    Vsetvli::getNewVL(uint32_t currentVl, uint32_t reqVl,
        uint32_t vlmax, uint64_t rdBits, uint64_t rs1Bits) const
    {
        uint32_t newVl = 0;
        if (vlmax == 0) {
            newVl = 0;
        } else if (rdBits == 0 && rs1Bits == 0) {
            newVl = currentVl > vlmax ? vlmax : currentVl;
        } else if (rdBits != 0 && rs1Bits == 0) {
            newVl = vlmax;
        } else if (rs1Bits != 0) {
            newVl = reqVl > vlmax ? vlmax : reqVl;
        }
        return newVl;
    }

    Fault
    Vsetvli::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        auto tc = xc->tcBase();
        MISA misa = xc->readMiscReg(MISCREG_ISA);
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (!misa.rvv || status.vs == VPUStatus::OFF) {
            return std::make_shared<IllegalInstFault>(
                "RVV is disabled or VPU is off", machInst);
        }

        uint64_t Rd = 0;
uint64_t Rs1 = 0;
uint64_t Vtype = 0;
uint32_t VL = 0;
RiscvISAInst::PCState __parserAutoPCState;
;
        set(__parserAutoPCState, xc->pcState());
Rs1 = xc->getRegOperand(this, 0);
Vtype = __parserAutoPCState.vtype();
VL = __parserAutoPCState.vl();
;
        
                        uint64_t rd_bits = RD;
                        uint64_t rs1_bits = RS1;
                        uint64_t requested_vl = Rs1;
                        uint64_t requested_vtype = zimm11;
                        uint32_t vlmax = getVlmax(Vtype, vlen);
                        uint32_t current_vl = VL;
                    ;

        tc->setMiscReg(MISCREG_VSTART, 0);

        VTYPE new_vtype = getNewVtype(Vtype, requested_vtype);
        vlmax = new_vtype.vill ? 0 : getVlmax(new_vtype, vlen);
        uint32_t new_vl = getNewVL(
            current_vl, requested_vl, vlmax, rd_bits, rs1_bits);



        
                        Rd = new_vl;
                        VL = new_vl;
                        Vtype = new_vtype;
                    ;

        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        }__parserAutoPCState.vtype(Vtype);
__parserAutoPCState.vl(VL);
xc->pcState(__parserAutoPCState);
;
        return NoFault;
    }

    std::unique_ptr<PCStateBase>
    Vsetvli::branchTarget(ThreadContext *tc) const
    {
        PCStateBase *pc_ptr = tc->pcState().clone();

        uint64_t rd_bits = machInst.rd;
        uint64_t rs1_bits = machInst.rs1;
        uint64_t requested_vl = tc->getReg(srcRegIdx(0));
        uint64_t requested_vtype = zimm11;

        VTYPE new_vtype = getNewVtype(
            pc_ptr->as<PCState>().vtype(), requested_vtype);
        uint32_t vlmax = new_vtype.vill ? 0 : getVlmax(new_vtype, vlen);
        uint32_t new_vl = getNewVL(
            pc_ptr->as<PCState>().vl(), requested_vl, vlmax, rd_bits, rs1_bits);

        pc_ptr->as<PCState>().vtype(new_vtype);
        pc_ptr->as<PCState>().vl(new_vl);
        return std::unique_ptr<PCStateBase>{pc_ptr};
    }

// VConfOp::vsetvl(['\n                            uint64_t rd_bits = RD;\n                            uint64_t rs1_bits = RS1;\n                            uint64_t requested_vl = Rs1_ud;\n                            uint64_t requested_vtype = Rs2_ud;\n                            uint32_t vlmax = getVlmax(Vtype, vlen);\n                            uint32_t current_vl = VL;\n                        ', '\n                            Rd_ud = new_vl;\n                            VL = new_vl;\n                            Vtype = new_vtype;\n                        ', 'VSetVlDeclare', 'VSetVlBranchTarget', 'SimdConfigOp', 'IsUncondControl', 'IsIndirectControl'],{})

    VTYPE
    Vsetvl::getNewVtype(
        VTYPE oldVtype, VTYPE reqVtype)  const
    {
        VTYPE newVtype = oldVtype;
        if (oldVtype != reqVtype) {
            newVtype = reqVtype;

            float vflmul = getVflmul(newVtype.vlmul);

            uint32_t sew = getSew(newVtype.vsew);

            uint32_t newVill =
                !(vflmul >= 0.125 && vflmul <= 8) ||
                    (float)sew > std::min(vflmul, 1.0f) * (float)elen ||
                    bits(reqVtype, 62, 8) != 0;
            if (newVill) {
                newVtype = 0;
                newVtype.vill = 1;
            }
        }
        return newVtype;
    }

    uint32_t
    Vsetvl::getNewVL(uint32_t currentVl, uint32_t reqVl,
        uint32_t vlmax, uint64_t rdBits, uint64_t rs1Bits) const
    {
        uint32_t newVl = 0;
        if (vlmax == 0) {
            newVl = 0;
        } else if (rdBits == 0 && rs1Bits == 0) {
            newVl = currentVl > vlmax ? vlmax : currentVl;
        } else if (rdBits != 0 && rs1Bits == 0) {
            newVl = vlmax;
        } else if (rs1Bits != 0) {
            newVl = reqVl > vlmax ? vlmax : reqVl;
        }
        return newVl;
    }

    Fault
    Vsetvl::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        auto tc = xc->tcBase();
        MISA misa = xc->readMiscReg(MISCREG_ISA);
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (!misa.rvv || status.vs == VPUStatus::OFF) {
            return std::make_shared<IllegalInstFault>(
                "RVV is disabled or VPU is off", machInst);
        }

        uint64_t Rd = 0;
uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
uint64_t Vtype = 0;
uint32_t VL = 0;
RiscvISAInst::PCState __parserAutoPCState;
;
        set(__parserAutoPCState, xc->pcState());
Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
Vtype = __parserAutoPCState.vtype();
VL = __parserAutoPCState.vl();
;
        
                            uint64_t rd_bits = RD;
                            uint64_t rs1_bits = RS1;
                            uint64_t requested_vl = Rs1;
                            uint64_t requested_vtype = Rs2;
                            uint32_t vlmax = getVlmax(Vtype, vlen);
                            uint32_t current_vl = VL;
                        ;

        tc->setMiscReg(MISCREG_VSTART, 0);

        VTYPE new_vtype = getNewVtype(Vtype, requested_vtype);
        vlmax = new_vtype.vill ? 0 : getVlmax(new_vtype, vlen);
        uint32_t new_vl = getNewVL(
            current_vl, requested_vl, vlmax, rd_bits, rs1_bits);



        
                            Rd = new_vl;
                            VL = new_vl;
                            Vtype = new_vtype;
                        ;

        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        }__parserAutoPCState.vtype(Vtype);
__parserAutoPCState.vl(VL);
xc->pcState(__parserAutoPCState);
;
        return NoFault;
    }

    std::unique_ptr<PCStateBase>
    Vsetvl::branchTarget(ThreadContext *tc) const
    {
        PCStateBase *pc_ptr = tc->pcState().clone();

        uint64_t rd_bits = machInst.rd;
        uint64_t rs1_bits = machInst.rs1;
        uint64_t requested_vl = tc->getReg(srcRegIdx(0));
        uint64_t requested_vtype = tc->getReg(srcRegIdx(1));

        VTYPE new_vtype = getNewVtype(
            pc_ptr->as<PCState>().vtype(), requested_vtype);
        uint32_t vlmax = new_vtype.vill ? 0 : getVlmax(new_vtype, vlen);
        uint32_t new_vl = getNewVL(
            pc_ptr->as<PCState>().vl(), requested_vl, vlmax, rd_bits, rs1_bits);

        pc_ptr->as<PCState>().vtype(new_vtype);
        pc_ptr->as<PCState>().vl(new_vl);
        return std::unique_ptr<PCStateBase>{pc_ptr};
    }

// VConfOp::vsetivli(['\n                            uint64_t rd_bits = RD;\n                            uint64_t rs1_bits = -1;\n                            uint64_t requested_vl = uimm;\n                            uint64_t requested_vtype = zimm10;\n                            uint32_t vlmax = getVlmax(Vtype, vlen);\n                            uint32_t current_vl = VL;\n                        ', '\n                            Rd_ud = new_vl;\n                            VL = new_vl;\n                            Vtype = new_vtype;\n                        ', 'VSetiVliDeclare', 'VSetiVliBranchTarget', 'SimdConfigOp', 'IsUncondControl', 'IsDirectControl'],{})

    VTYPE
    Vsetivli::getNewVtype(
        VTYPE oldVtype, VTYPE reqVtype)  const
    {
        VTYPE newVtype = oldVtype;
        if (oldVtype != reqVtype) {
            newVtype = reqVtype;

            float vflmul = getVflmul(newVtype.vlmul);

            uint32_t sew = getSew(newVtype.vsew);

            uint32_t newVill =
                !(vflmul >= 0.125 && vflmul <= 8) ||
                    (float)sew > std::min(vflmul, 1.0f) * (float)elen ||
                    bits(reqVtype, 62, 8) != 0;
            if (newVill) {
                newVtype = 0;
                newVtype.vill = 1;
            }
        }
        return newVtype;
    }

    uint32_t
    Vsetivli::getNewVL(uint32_t currentVl, uint32_t reqVl,
        uint32_t vlmax, uint64_t rdBits, uint64_t rs1Bits) const
    {
        uint32_t newVl = 0;
        if (vlmax == 0) {
            newVl = 0;
        } else if (rdBits == 0 && rs1Bits == 0) {
            newVl = currentVl > vlmax ? vlmax : currentVl;
        } else if (rdBits != 0 && rs1Bits == 0) {
            newVl = vlmax;
        } else if (rs1Bits != 0) {
            newVl = reqVl > vlmax ? vlmax : reqVl;
        }
        return newVl;
    }

    Fault
    Vsetivli::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        auto tc = xc->tcBase();
        MISA misa = xc->readMiscReg(MISCREG_ISA);
        STATUS status = xc->readMiscReg(MISCREG_STATUS);
        if (!misa.rvv || status.vs == VPUStatus::OFF) {
            return std::make_shared<IllegalInstFault>(
                "RVV is disabled or VPU is off", machInst);
        }

        uint64_t Rd = 0;
uint64_t Vtype = 0;
uint32_t VL = 0;
RiscvISAInst::PCState __parserAutoPCState;
;
        set(__parserAutoPCState, xc->pcState());
Vtype = __parserAutoPCState.vtype();
VL = __parserAutoPCState.vl();
;
        
                            uint64_t rd_bits = RD;
                            uint64_t rs1_bits = -1;
                            uint64_t requested_vl = uimm;
                            uint64_t requested_vtype = zimm10;
                            uint32_t vlmax = getVlmax(Vtype, vlen);
                            uint32_t current_vl = VL;
                        ;

        tc->setMiscReg(MISCREG_VSTART, 0);

        VTYPE new_vtype = getNewVtype(Vtype, requested_vtype);
        vlmax = new_vtype.vill ? 0 : getVlmax(new_vtype, vlen);
        uint32_t new_vl = getNewVL(
            current_vl, requested_vl, vlmax, rd_bits, rs1_bits);



        
                            Rd = new_vl;
                            VL = new_vl;
                            Vtype = new_vtype;
                        ;

        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        }__parserAutoPCState.vtype(Vtype);
__parserAutoPCState.vl(VL);
xc->pcState(__parserAutoPCState);
;
        return NoFault;
    }

    std::unique_ptr<PCStateBase>
    Vsetivli::branchTarget(const PCStateBase &branch_pc) const
    {
        auto &rpc = branch_pc.as<RiscvISA::PCState>();

        uint64_t rd_bits = machInst.rd;
        uint64_t rs1_bits = -1;
        uint64_t requested_vl = uimm;
        uint64_t requested_vtype = zimm10;

        VTYPE new_vtype = getNewVtype(rpc.vtype(), requested_vtype);
        uint32_t vlmax = new_vtype.vill ? 0 : getVlmax(new_vtype, vlen);
        uint32_t new_vl = getNewVL(
            rpc.vl(), requested_vl, vlmax, rd_bits, rs1_bits);

        std::unique_ptr<PCState> npc(dynamic_cast<PCState*>(rpc.clone()));
        npc->set(rvSext(npc->pc() + 4));
        npc->vtype(new_vtype);
        npc->vl(new_vl);
        return npc;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// BOp::beq(['\n                    if (rvSext(Rs1) == rvSext(Rs2)) {\n                        NPC = rvSext(PC + imm);\n                    } else {\n                        NPC = rvSext(NPC);\n                    }\n                ', 'IsDirectControl', 'IsCondControl'],{})

    Fault
    Beq::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
uint64_t PC = 0;
uint64_t NPC = 0;
RiscvISAInst::PCState __parserAutoPCState;
;
        set(__parserAutoPCState, xc->pcState());
Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
PC = __parserAutoPCState.pc();
NPC = __parserAutoPCState.npc();
;
        
                    if (rvSext(Rs1) == rvSext(Rs2)) {
                        NPC = rvSext(PC + imm);
                    } else {
                        NPC = rvSext(NPC);
                    }
                ;
        __parserAutoPCState.npc(NPC);
xc->pcState(__parserAutoPCState);
;
        return NoFault;
    }

    std::unique_ptr<PCStateBase>
    Beq::branchTarget(const PCStateBase &branch_pc) const
    {
        auto &rpc = branch_pc.as<RiscvISA::PCState>();
        std::unique_ptr<PCState> npc(dynamic_cast<PCState*>(rpc.clone()));
        npc->set(rvSext(rpc.pc() + imm));
        return npc;
    }

    std::string
    Beq::generateDisassembly(
            Addr pc, const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {srcRegIdx(0),srcRegIdx(1)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// BOp::bne(['\n                    if (rvSext(Rs1) != rvSext(Rs2)) {\n                        NPC = rvSext(PC + imm);\n                    } else {\n                        NPC = rvSext(NPC);\n                    }\n                ', 'IsDirectControl', 'IsCondControl'],{})

    Fault
    Bne::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
uint64_t PC = 0;
uint64_t NPC = 0;
RiscvISAInst::PCState __parserAutoPCState;
;
        set(__parserAutoPCState, xc->pcState());
Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
PC = __parserAutoPCState.pc();
NPC = __parserAutoPCState.npc();
;
        
                    if (rvSext(Rs1) != rvSext(Rs2)) {
                        NPC = rvSext(PC + imm);
                    } else {
                        NPC = rvSext(NPC);
                    }
                ;
        __parserAutoPCState.npc(NPC);
xc->pcState(__parserAutoPCState);
;
        return NoFault;
    }

    std::unique_ptr<PCStateBase>
    Bne::branchTarget(const PCStateBase &branch_pc) const
    {
        auto &rpc = branch_pc.as<RiscvISA::PCState>();
        std::unique_ptr<PCState> npc(dynamic_cast<PCState*>(rpc.clone()));
        npc->set(rvSext(rpc.pc() + imm));
        return npc;
    }

    std::string
    Bne::generateDisassembly(
            Addr pc, const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {srcRegIdx(0),srcRegIdx(1)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// BOp::blt(['\n                    if (rvSext(Rs1_sd) < rvSext(Rs2_sd)) {\n                        NPC = rvSext(PC + imm);\n                    } else {\n                        NPC = rvSext(NPC);\n                    }\n                ', 'IsDirectControl', 'IsCondControl'],{})

    Fault
    Blt::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int64_t Rs1 = 0;
int64_t Rs2 = 0;
uint64_t PC = 0;
uint64_t NPC = 0;
RiscvISAInst::PCState __parserAutoPCState;
;
        set(__parserAutoPCState, xc->pcState());
Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
PC = __parserAutoPCState.pc();
NPC = __parserAutoPCState.npc();
;
        
                    if (rvSext(Rs1) < rvSext(Rs2)) {
                        NPC = rvSext(PC + imm);
                    } else {
                        NPC = rvSext(NPC);
                    }
                ;
        __parserAutoPCState.npc(NPC);
xc->pcState(__parserAutoPCState);
;
        return NoFault;
    }

    std::unique_ptr<PCStateBase>
    Blt::branchTarget(const PCStateBase &branch_pc) const
    {
        auto &rpc = branch_pc.as<RiscvISA::PCState>();
        std::unique_ptr<PCState> npc(dynamic_cast<PCState*>(rpc.clone()));
        npc->set(rvSext(rpc.pc() + imm));
        return npc;
    }

    std::string
    Blt::generateDisassembly(
            Addr pc, const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {srcRegIdx(0),srcRegIdx(1)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// BOp::bge(['\n                    if (rvSext(Rs1_sd) >= rvSext(Rs2_sd)) {\n                        NPC = rvSext(PC + imm);\n                    } else {\n                        NPC = rvSext(NPC);\n                    }\n                ', 'IsDirectControl', 'IsCondControl'],{})

    Fault
    Bge::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        int64_t Rs1 = 0;
int64_t Rs2 = 0;
uint64_t PC = 0;
uint64_t NPC = 0;
RiscvISAInst::PCState __parserAutoPCState;
;
        set(__parserAutoPCState, xc->pcState());
Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
PC = __parserAutoPCState.pc();
NPC = __parserAutoPCState.npc();
;
        
                    if (rvSext(Rs1) >= rvSext(Rs2)) {
                        NPC = rvSext(PC + imm);
                    } else {
                        NPC = rvSext(NPC);
                    }
                ;
        __parserAutoPCState.npc(NPC);
xc->pcState(__parserAutoPCState);
;
        return NoFault;
    }

    std::unique_ptr<PCStateBase>
    Bge::branchTarget(const PCStateBase &branch_pc) const
    {
        auto &rpc = branch_pc.as<RiscvISA::PCState>();
        std::unique_ptr<PCState> npc(dynamic_cast<PCState*>(rpc.clone()));
        npc->set(rvSext(rpc.pc() + imm));
        return npc;
    }

    std::string
    Bge::generateDisassembly(
            Addr pc, const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {srcRegIdx(0),srcRegIdx(1)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// BOp::bltu(['\n                    if (rvZext(Rs1) < rvZext(Rs2)) {\n                        NPC = rvSext(PC + imm);\n                    } else {\n                        NPC = rvSext(NPC);\n                    }\n                ', 'IsDirectControl', 'IsCondControl'],{})

    Fault
    Bltu::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
uint64_t PC = 0;
uint64_t NPC = 0;
RiscvISAInst::PCState __parserAutoPCState;
;
        set(__parserAutoPCState, xc->pcState());
Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
PC = __parserAutoPCState.pc();
NPC = __parserAutoPCState.npc();
;
        
                    if (rvZext(Rs1) < rvZext(Rs2)) {
                        NPC = rvSext(PC + imm);
                    } else {
                        NPC = rvSext(NPC);
                    }
                ;
        __parserAutoPCState.npc(NPC);
xc->pcState(__parserAutoPCState);
;
        return NoFault;
    }

    std::unique_ptr<PCStateBase>
    Bltu::branchTarget(const PCStateBase &branch_pc) const
    {
        auto &rpc = branch_pc.as<RiscvISA::PCState>();
        std::unique_ptr<PCState> npc(dynamic_cast<PCState*>(rpc.clone()));
        npc->set(rvSext(rpc.pc() + imm));
        return npc;
    }

    std::string
    Bltu::generateDisassembly(
            Addr pc, const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {srcRegIdx(0),srcRegIdx(1)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// BOp::bgeu(['\n                    if (rvZext(Rs1) >= rvZext(Rs2)) {\n                        NPC = rvSext(PC + imm);\n                    } else {\n                        NPC = rvSext(NPC);\n                    }\n                ', 'IsDirectControl', 'IsCondControl'],{})

    Fault
    Bgeu::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
uint64_t PC = 0;
uint64_t NPC = 0;
RiscvISAInst::PCState __parserAutoPCState;
;
        set(__parserAutoPCState, xc->pcState());
Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
PC = __parserAutoPCState.pc();
NPC = __parserAutoPCState.npc();
;
        
                    if (rvZext(Rs1) >= rvZext(Rs2)) {
                        NPC = rvSext(PC + imm);
                    } else {
                        NPC = rvSext(NPC);
                    }
                ;
        __parserAutoPCState.npc(NPC);
xc->pcState(__parserAutoPCState);
;
        return NoFault;
    }

    std::unique_ptr<PCStateBase>
    Bgeu::branchTarget(const PCStateBase &branch_pc) const
    {
        auto &rpc = branch_pc.as<RiscvISA::PCState>();
        std::unique_ptr<PCState> npc(dynamic_cast<PCState*>(rpc.clone()));
        npc->set(rvSext(rpc.pc() + imm));
        return npc;
    }

    std::string
    Bgeu::generateDisassembly(
            Addr pc, const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {srcRegIdx(0),srcRegIdx(1)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// Unknown::unknown(([], {}))

// Jump::jalr((['\n                Rd = rvSext(NPC);\n                NPC = rvSext((imm + Rs1) & (~0x1));\n            ', 'IsIndirectControl', 'IsUncondControl'], {}))

    Fault
    Jalr::execute(
        ExecContext *xc, trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t Rs1 = 0;
uint64_t NPC = 0;
RiscvISAInst::PCState __parserAutoPCState;
;
        set(__parserAutoPCState, xc->pcState());
Rs1 = xc->getRegOperand(this, 0);
NPC = __parserAutoPCState.npc();
;
        
                Rd = rvSext(NPC);
                NPC = rvSext((imm + Rs1) & (~0x1));
            ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        }__parserAutoPCState.npc(NPC);
xc->pcState(__parserAutoPCState);
;
        return NoFault;
    }

    std::unique_ptr<PCStateBase>
    Jalr::branchTarget(ThreadContext *tc) const
    {
        PCStateBase *pc_ptr = tc->pcState().clone();
        pc_ptr->as<PCState>().set(
            rvSext((tc->getReg(srcRegIdx(0)) + imm) & ~0x1));
        return std::unique_ptr<PCStateBase>{pc_ptr};
    }

    std::string
    Jalr::generateDisassembly(
            Addr pc, const loader::SymbolTable *symtab) const
    {
        std::stringstream ss;
        ss << mnemonic << ' ' << registerName(destRegIdx(0)) << ", "
           << imm << "(" << registerName(srcRegIdx(0)) << ")";
        return ss.str();
    }

// Unknown::unknown(([], {}))

// JOp::jal((['\n            Rd = rvSext(NPC);\n            NPC = rvSext(PC + imm);\n        ', 'IsDirectControl', 'IsUncondControl'], {}))

    Fault
    Jal::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rd = 0;
uint64_t PC = 0;
uint64_t NPC = 0;
RiscvISAInst::PCState __parserAutoPCState;
;
        set(__parserAutoPCState, xc->pcState());
PC = __parserAutoPCState.pc();
NPC = __parserAutoPCState.npc();
;
        
            Rd = rvSext(NPC);
            NPC = rvSext(PC + imm);
        ;
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        }__parserAutoPCState.npc(NPC);
xc->pcState(__parserAutoPCState);
;
        return NoFault;
    }

    std::unique_ptr<PCStateBase>
    Jal::branchTarget(const PCStateBase &branch_pc) const
    {
        auto &rpc = branch_pc.as<RiscvISA::PCState>();
        std::unique_ptr<PCState> npc(dynamic_cast<PCState*>(rpc.clone()));
        npc->set(rvSext(rpc.pc() + imm));
        return npc;
    }

    std::string
    Jal::generateDisassembly(
            Addr pc, const loader::SymbolTable *symtab) const
    {
        std::vector<RegId> indices = {destRegIdx(0)};
        std::stringstream ss;
        ss << mnemonic << ' ';
        for (const RegId& idx: indices)
            ss << registerName(idx) << ", ";
        ss << imm;
        return ss.str();
    }

// SystemOp::ecall(['\n                            return std::make_shared<SyscallFault>(\n                                (PrivilegeMode)xc->readMiscReg(MISCREG_PRV));\n                        ', 'IsSerializeAfter', 'IsNonSpeculative', 'IsSyscall', 'No_OpClass'],{})

    Fault
    Ecall::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        ;
        ;
        
                            return std::make_shared<SyscallFault>(
                                (PrivilegeMode)xc->readMiscReg(MISCREG_PRV));
                        ;
        ;
        return NoFault;
    }

// SystemOp::ebreak(['\n                            return executeEBreakOrSemihosting(xc);\n                        ', 'IsSerializeAfter', 'IsNonSpeculative', 'No_OpClass'],{})

    Fault
    Ebreak::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        ;
        ;
        
                            return executeEBreakOrSemihosting(xc);
                        ;
        ;
        return NoFault;
    }

// SystemOp::uret(['\n                           MISA misa = xc->readMiscReg(MISCREG_ISA);\n                            if (!misa.rvn) {\n                                return std::make_shared<IllegalInstFault>(\n                                    "sret can\'t execute without N systems",\n                                    machInst);\n                            }\n                            STATUS status = xc->readMiscReg(MISCREG_STATUS);\n                            status.uie = status.upie;\n                            status.upie = 1;\n                            xc->setMiscReg(MISCREG_STATUS, status);\n                            NPC = rvSext(xc->readMiscReg(MISCREG_UEPC));\n                        ', 'IsSerializeAfter', 'IsNonSpeculative', 'IsReturn'],{})

    Fault
    Uret::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t NPC = 0;
RiscvISAInst::PCState __parserAutoPCState;
;
        set(__parserAutoPCState, xc->pcState());
;
        
                           MISA misa = xc->readMiscReg(MISCREG_ISA);
                            if (!misa.rvn) {
                                return std::make_shared<IllegalInstFault>(
                                    "sret can't execute without N systems",
                                    machInst);
                            }
                            STATUS status = xc->readMiscReg(MISCREG_STATUS);
                            status.uie = status.upie;
                            status.upie = 1;
                            xc->setMiscReg(MISCREG_STATUS, status);
                            NPC = rvSext(xc->readMiscReg(MISCREG_UEPC));
                        ;
        __parserAutoPCState.npc(NPC);
xc->pcState(__parserAutoPCState);
;
        return NoFault;
    }

// Unknown::unknown(([], {}))

// SystemOp::sret(['\n                            MISA misa = xc->readMiscReg(MISCREG_ISA);\n                            if (!misa.rvs) {\n                                return std::make_shared<IllegalInstFault>(\n                                            "sret can\'t execute without RVS",\n                                            machInst);\n                            }\n                            STATUS status = xc->readMiscReg(MISCREG_STATUS);\n                            auto pm = (PrivilegeMode)xc->readMiscReg(\n                                MISCREG_PRV);\n                            if (pm == PRV_U ||\n                                (pm == PRV_S && status.tsr == 1)) {\n                                return std::make_shared<IllegalInstFault>(\n                                            "sret in user mode or TSR enabled",\n                                            machInst);\n                                NPC = NPC;\n                            } else {\n                                xc->setMiscReg(MISCREG_PRV, status.spp);\n                                status.sie = status.spie;\n                                status.spie = 1;\n                                status.spp = PRV_U;\n                                xc->setMiscReg(MISCREG_STATUS, status);\n                                NPC = rvSext(xc->readMiscReg(MISCREG_SEPC));\n                            }\n                        ', 'IsSerializeAfter', 'IsNonSpeculative', 'IsReturn'],{})

    Fault
    Sret::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t NPC = 0;
RiscvISAInst::PCState __parserAutoPCState;
;
        set(__parserAutoPCState, xc->pcState());
NPC = __parserAutoPCState.npc();
;
        
                            MISA misa = xc->readMiscReg(MISCREG_ISA);
                            if (!misa.rvs) {
                                return std::make_shared<IllegalInstFault>(
                                            "sret can't execute without RVS",
                                            machInst);
                            }
                            STATUS status = xc->readMiscReg(MISCREG_STATUS);
                            auto pm = (PrivilegeMode)xc->readMiscReg(
                                MISCREG_PRV);
                            if (pm == PRV_U ||
                                (pm == PRV_S && status.tsr == 1)) {
                                return std::make_shared<IllegalInstFault>(
                                            "sret in user mode or TSR enabled",
                                            machInst);
                                NPC = NPC;
                            } else {
                                xc->setMiscReg(MISCREG_PRV, status.spp);
                                status.sie = status.spie;
                                status.spie = 1;
                                status.spp = PRV_U;
                                xc->setMiscReg(MISCREG_STATUS, status);
                                NPC = rvSext(xc->readMiscReg(MISCREG_SEPC));
                            }
                        ;
        __parserAutoPCState.npc(NPC);
xc->pcState(__parserAutoPCState);
;
        return NoFault;
    }

// SystemOp::wfi(['\n                            MISA misa = xc->readMiscReg(MISCREG_ISA);\n                            STATUS status = xc->readMiscReg(MISCREG_STATUS);\n                            auto pm = (PrivilegeMode)xc->readMiscReg(\n                                MISCREG_PRV);\n                            if (misa.rvs && (pm == PRV_U ||\n                                (pm == PRV_S && status.tw == 1))) {\n                                return std::make_shared<IllegalInstFault>(\n                                            "wfi in user mode or TW enabled",\n                                            machInst);\n                            }\n                            auto tc = xc->tcBase();\n                            auto cpu = tc->getCpuPtr();\n                            auto ic = dynamic_cast<RiscvISA::Interrupts*>(\n                                cpu->getInterruptController(tc->threadId()));\n                            auto isa = dynamic_cast<RiscvISA::ISA*>(\n                                tc->getIsaPtr());\n                            panic_if(!ic, "Invalid Interrupt Controller.");\n                            if (isa->resumeOnPending()) {\n                                // Go to sleep only if there are no pending\n                                // interrupts at all, and no non-maskable\n                                // interrupts.\n                                if (ic->readIP() == 0\n                                && xc->readMiscReg(MISCREG_NMIP) == 0) {\n                                    tc->quiesce();\n                                }\n                            } else {\n                                // Go to sleep only if there are no enabled\n                                // pending interrupts at all, and no\n                                // non-maskable interrupts\n                                if (!(ic->readIP() & ic->readIE())\n                                 && xc->readMiscReg(MISCREG_NMIP) == 0) {\n                                    tc->quiesce();\n                                 }\n                            }\n                        ', 'IsNonSpeculative', 'IsQuiesce', 'IsSerializeAfter', 'No_OpClass', 'IsSquashAfter'],{})

    Fault
    Wfi::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        ;
        ;
        
                            MISA misa = xc->readMiscReg(MISCREG_ISA);
                            STATUS status = xc->readMiscReg(MISCREG_STATUS);
                            auto pm = (PrivilegeMode)xc->readMiscReg(
                                MISCREG_PRV);
                            if (misa.rvs && (pm == PRV_U ||
                                (pm == PRV_S && status.tw == 1))) {
                                return std::make_shared<IllegalInstFault>(
                                            "wfi in user mode or TW enabled",
                                            machInst);
                            }
                            auto tc = xc->tcBase();
                            auto cpu = tc->getCpuPtr();
                            auto ic = dynamic_cast<RiscvISA::Interrupts*>(
                                cpu->getInterruptController(tc->threadId()));
                            auto isa = dynamic_cast<RiscvISA::ISA*>(
                                tc->getIsaPtr());
                            panic_if(!ic, "Invalid Interrupt Controller.");
                            if (isa->resumeOnPending()) {
                                // Go to sleep only if there are no pending
                                // interrupts at all, and no non-maskable
                                // interrupts.
                                if (ic->readIP() == 0
                                && xc->readMiscReg(MISCREG_NMIP) == 0) {
                                    tc->quiesce();
                                }
                            } else {
                                // Go to sleep only if there are no enabled
                                // pending interrupts at all, and no
                                // non-maskable interrupts
                                if (!(ic->readIP() & ic->readIE())
                                 && xc->readMiscReg(MISCREG_NMIP) == 0) {
                                    tc->quiesce();
                                 }
                            }
                        ;
        ;
        return NoFault;
    }

// Unknown::unknown(([], {}))

// SystemOp::sfence_vma(['\n                        MISA misa = xc->readMiscReg(MISCREG_ISA);\n                        if (!misa.rvs) {\n                            return std::make_shared<IllegalInstFault>(\n                                "sfence_vma can\'t execute without RVS",\n                                machInst);\n                        }\n                        STATUS status = xc->readMiscReg(MISCREG_STATUS);\n                        auto pm = (PrivilegeMode)xc->readMiscReg(MISCREG_PRV);\n                        if (pm == PRV_U || (pm == PRV_S && status.tvm == 1)) {\n                            return std::make_shared<IllegalInstFault>(\n                                        "sfence in user mode or TVM enabled",\n                                        machInst);\n                        }\n                        xc->tcBase()->getMMUPtr()->demapPage(Rs1, Rs2);\n                    ', 'IsNonSpeculative', 'IsSerializeAfter', 'No_OpClass'],{})

    Fault
    Sfence_vma::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t Rs1 = 0;
uint64_t Rs2 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
Rs2 = xc->getRegOperand(this, 1);
;
        
                        MISA misa = xc->readMiscReg(MISCREG_ISA);
                        if (!misa.rvs) {
                            return std::make_shared<IllegalInstFault>(
                                "sfence_vma can't execute without RVS",
                                machInst);
                        }
                        STATUS status = xc->readMiscReg(MISCREG_STATUS);
                        auto pm = (PrivilegeMode)xc->readMiscReg(MISCREG_PRV);
                        if (pm == PRV_U || (pm == PRV_S && status.tvm == 1)) {
                            return std::make_shared<IllegalInstFault>(
                                        "sfence in user mode or TVM enabled",
                                        machInst);
                        }
                        xc->tcBase()->getMMUPtr()->demapPage(Rs1, Rs2);
                    ;
        ;
        return NoFault;
    }

// SystemOp::mret(['\n                        if (xc->readMiscReg(MISCREG_PRV) != PRV_M) {\n                            return std::make_shared<IllegalInstFault>(\n                                        "mret at lower privilege", machInst);\n                            NPC = NPC;\n                        } else {\n                            STATUS status = xc->readMiscReg(MISCREG_STATUS);\n                            xc->setMiscReg(MISCREG_PRV, status.mpp);\n                            xc->setMiscReg(MISCREG_NMIE, 1);\n                            status.mie = status.mpie;\n                            status.mpie = 1;\n                            status.mpp = PRV_U;\n                            xc->setMiscReg(MISCREG_STATUS, status);\n                            NPC = rvSext(xc->readMiscReg(MISCREG_MEPC));\n                        }\n                    ', 'IsSerializeAfter', 'IsNonSpeculative', 'IsReturn'],{})

    Fault
    Mret::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t NPC = 0;
RiscvISAInst::PCState __parserAutoPCState;
;
        set(__parserAutoPCState, xc->pcState());
NPC = __parserAutoPCState.npc();
;
        
                        if (xc->readMiscReg(MISCREG_PRV) != PRV_M) {
                            return std::make_shared<IllegalInstFault>(
                                        "mret at lower privilege", machInst);
                            NPC = NPC;
                        } else {
                            STATUS status = xc->readMiscReg(MISCREG_STATUS);
                            xc->setMiscReg(MISCREG_PRV, status.mpp);
                            xc->setMiscReg(MISCREG_NMIE, 1);
                            status.mie = status.mpie;
                            status.mpie = 1;
                            status.mpp = PRV_U;
                            xc->setMiscReg(MISCREG_STATUS, status);
                            NPC = rvSext(xc->readMiscReg(MISCREG_MEPC));
                        }
                    ;
        __parserAutoPCState.npc(NPC);
xc->pcState(__parserAutoPCState);
;
        return NoFault;
    }

// Unknown::unknown(([], {}))

// CSROp::csrrw(['\n                    Rd = rvSext(data);\n                    data = rvZext(Rs1);\n                ', 'RD != 0', 'true', 'IsSerializeAfter', 'IsNonSpeculative', 'No_OpClass'],{})

    Fault
    Csrrw::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        // We assume a riscv instruction is always run with a riscv ISA.
        auto isa = static_cast<RiscvISA::ISA*>(xc->tcBase()->getIsaPtr());
        auto& csr_data = isa->getCSRDataMap();
        MISA misa = isa->readMiscRegNoEffect(MISCREG_ISA);

        auto csr_data_it = csr_data.find(csr);
        if (csr_data_it == csr_data.end()) {
            return std::make_shared<IllegalInstFault>(
                    csprintf("Illegal CSR index %#x\n", csr), machInst);
        }

        RegIndex midx = csr_data_it->second.physIndex;
        const std::string& csrName = csr_data_it->second.name;
        if ((csr_data_it->second.rvTypes & (1 << machInst.rv_type)) == 0) {
            return std::make_shared<IllegalInstFault>(
                    csprintf("%s is not support in mode %d\n",
                             csrName,
                             machInst.rv_type),
                    machInst);
        }

        MISA csr_exts = csr_data_it->second.isaExts;
        if ((csr_exts & misa) != csr_exts) {
            return std::make_shared<IllegalInstFault>(
                    csprintf("%s is not support in the isa spec %d\n",
                             csrName),
                    machInst);
        }

        uint64_t Rd = 0;
uint64_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;

        RegVal data = 0;
        auto lowestAllowedMode = (PrivilegeMode)bits(csr, 9, 8);
        auto pm = (PrivilegeMode)xc->readMiscReg(MISCREG_PRV);
        if (pm < lowestAllowedMode) {
            return std::make_shared<IllegalInstFault>(
                    csprintf("%s is not accessible in %s\n", csrName, pm),
                    machInst);
        }
        switch (csr) {
          case CSR_SATP: {
            STATUS status = xc->readMiscReg(MISCREG_STATUS);
            if (pm == PRV_S && status.tvm == 1) {
                return std::make_shared<IllegalInstFault>(
                        "SATP access with TVM enabled\n",
                        machInst);
            }
            break;
          }
          default:
            break;
        }

        if (RD != 0) {
            data = rvZext(xc->readMiscReg(midx));
        }

        
                    Rd = rvSext(data);
                    data = rvZext(Rs1);
                ;

        if (true) {
            if (bits(csr, 11, 10) == 0x3) {
                return std::make_shared<IllegalInstFault>(
                        csprintf("CSR %s is read-only\n", csrName), machInst);
            }
            DPRINTF(RiscvMisc, "Writing %#x to CSR %s.\n",
                    data, csrName);
            xc->setMiscReg(midx, data);
        }
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// CSROp::csrrs(['\n                    Rd = rvSext(data);\n                    data = rvZext(data | Rs1);\n                ', 'true', 'RS1 != 0', 'IsSerializeAfter', 'IsNonSpeculative', 'No_OpClass'],{})

    Fault
    Csrrs::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        // We assume a riscv instruction is always run with a riscv ISA.
        auto isa = static_cast<RiscvISA::ISA*>(xc->tcBase()->getIsaPtr());
        auto& csr_data = isa->getCSRDataMap();
        MISA misa = isa->readMiscRegNoEffect(MISCREG_ISA);

        auto csr_data_it = csr_data.find(csr);
        if (csr_data_it == csr_data.end()) {
            return std::make_shared<IllegalInstFault>(
                    csprintf("Illegal CSR index %#x\n", csr), machInst);
        }

        RegIndex midx = csr_data_it->second.physIndex;
        const std::string& csrName = csr_data_it->second.name;
        if ((csr_data_it->second.rvTypes & (1 << machInst.rv_type)) == 0) {
            return std::make_shared<IllegalInstFault>(
                    csprintf("%s is not support in mode %d\n",
                             csrName,
                             machInst.rv_type),
                    machInst);
        }

        MISA csr_exts = csr_data_it->second.isaExts;
        if ((csr_exts & misa) != csr_exts) {
            return std::make_shared<IllegalInstFault>(
                    csprintf("%s is not support in the isa spec %d\n",
                             csrName),
                    machInst);
        }

        uint64_t Rd = 0;
uint64_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;

        RegVal data = 0;
        auto lowestAllowedMode = (PrivilegeMode)bits(csr, 9, 8);
        auto pm = (PrivilegeMode)xc->readMiscReg(MISCREG_PRV);
        if (pm < lowestAllowedMode) {
            return std::make_shared<IllegalInstFault>(
                    csprintf("%s is not accessible in %s\n", csrName, pm),
                    machInst);
        }
        switch (csr) {
          case CSR_SATP: {
            STATUS status = xc->readMiscReg(MISCREG_STATUS);
            if (pm == PRV_S && status.tvm == 1) {
                return std::make_shared<IllegalInstFault>(
                        "SATP access with TVM enabled\n",
                        machInst);
            }
            break;
          }
          default:
            break;
        }

        if (true) {
            data = rvZext(xc->readMiscReg(midx));
        }

        
                    Rd = rvSext(data);
                    data = rvZext(data | Rs1);
                ;

        if (RS1 != 0) {
            if (bits(csr, 11, 10) == 0x3) {
                return std::make_shared<IllegalInstFault>(
                        csprintf("CSR %s is read-only\n", csrName), machInst);
            }
            DPRINTF(RiscvMisc, "Writing %#x to CSR %s.\n",
                    data, csrName);
            xc->setMiscReg(midx, data);
        }
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// CSROp::csrrc(['\n                    Rd = rvSext(data);\n                    data = rvZext(data & ~Rs1);\n                ', 'true', 'RS1 != 0', 'IsSerializeAfter', 'IsNonSpeculative', 'No_OpClass'],{})

    Fault
    Csrrc::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        // We assume a riscv instruction is always run with a riscv ISA.
        auto isa = static_cast<RiscvISA::ISA*>(xc->tcBase()->getIsaPtr());
        auto& csr_data = isa->getCSRDataMap();
        MISA misa = isa->readMiscRegNoEffect(MISCREG_ISA);

        auto csr_data_it = csr_data.find(csr);
        if (csr_data_it == csr_data.end()) {
            return std::make_shared<IllegalInstFault>(
                    csprintf("Illegal CSR index %#x\n", csr), machInst);
        }

        RegIndex midx = csr_data_it->second.physIndex;
        const std::string& csrName = csr_data_it->second.name;
        if ((csr_data_it->second.rvTypes & (1 << machInst.rv_type)) == 0) {
            return std::make_shared<IllegalInstFault>(
                    csprintf("%s is not support in mode %d\n",
                             csrName,
                             machInst.rv_type),
                    machInst);
        }

        MISA csr_exts = csr_data_it->second.isaExts;
        if ((csr_exts & misa) != csr_exts) {
            return std::make_shared<IllegalInstFault>(
                    csprintf("%s is not support in the isa spec %d\n",
                             csrName),
                    machInst);
        }

        uint64_t Rd = 0;
uint64_t Rs1 = 0;
;
        Rs1 = xc->getRegOperand(this, 0);
;

        RegVal data = 0;
        auto lowestAllowedMode = (PrivilegeMode)bits(csr, 9, 8);
        auto pm = (PrivilegeMode)xc->readMiscReg(MISCREG_PRV);
        if (pm < lowestAllowedMode) {
            return std::make_shared<IllegalInstFault>(
                    csprintf("%s is not accessible in %s\n", csrName, pm),
                    machInst);
        }
        switch (csr) {
          case CSR_SATP: {
            STATUS status = xc->readMiscReg(MISCREG_STATUS);
            if (pm == PRV_S && status.tvm == 1) {
                return std::make_shared<IllegalInstFault>(
                        "SATP access with TVM enabled\n",
                        machInst);
            }
            break;
          }
          default:
            break;
        }

        if (true) {
            data = rvZext(xc->readMiscReg(midx));
        }

        
                    Rd = rvSext(data);
                    data = rvZext(data & ~Rs1);
                ;

        if (RS1 != 0) {
            if (bits(csr, 11, 10) == 0x3) {
                return std::make_shared<IllegalInstFault>(
                        csprintf("CSR %s is read-only\n", csrName), machInst);
            }
            DPRINTF(RiscvMisc, "Writing %#x to CSR %s.\n",
                    data, csrName);
            xc->setMiscReg(midx, data);
        }
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// CSROp::csrrwi(['\n                    Rd = rvSext(data);\n                    data = rvZext(uimm);\n                ', 'RD != 0', 'true', 'IsSerializeAfter', 'IsNonSpeculative', 'No_OpClass'],{})

    Fault
    Csrrwi::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        // We assume a riscv instruction is always run with a riscv ISA.
        auto isa = static_cast<RiscvISA::ISA*>(xc->tcBase()->getIsaPtr());
        auto& csr_data = isa->getCSRDataMap();
        MISA misa = isa->readMiscRegNoEffect(MISCREG_ISA);

        auto csr_data_it = csr_data.find(csr);
        if (csr_data_it == csr_data.end()) {
            return std::make_shared<IllegalInstFault>(
                    csprintf("Illegal CSR index %#x\n", csr), machInst);
        }

        RegIndex midx = csr_data_it->second.physIndex;
        const std::string& csrName = csr_data_it->second.name;
        if ((csr_data_it->second.rvTypes & (1 << machInst.rv_type)) == 0) {
            return std::make_shared<IllegalInstFault>(
                    csprintf("%s is not support in mode %d\n",
                             csrName,
                             machInst.rv_type),
                    machInst);
        }

        MISA csr_exts = csr_data_it->second.isaExts;
        if ((csr_exts & misa) != csr_exts) {
            return std::make_shared<IllegalInstFault>(
                    csprintf("%s is not support in the isa spec %d\n",
                             csrName),
                    machInst);
        }

        uint64_t Rd = 0;
;
        ;

        RegVal data = 0;
        auto lowestAllowedMode = (PrivilegeMode)bits(csr, 9, 8);
        auto pm = (PrivilegeMode)xc->readMiscReg(MISCREG_PRV);
        if (pm < lowestAllowedMode) {
            return std::make_shared<IllegalInstFault>(
                    csprintf("%s is not accessible in %s\n", csrName, pm),
                    machInst);
        }
        switch (csr) {
          case CSR_SATP: {
            STATUS status = xc->readMiscReg(MISCREG_STATUS);
            if (pm == PRV_S && status.tvm == 1) {
                return std::make_shared<IllegalInstFault>(
                        "SATP access with TVM enabled\n",
                        machInst);
            }
            break;
          }
          default:
            break;
        }

        if (RD != 0) {
            data = rvZext(xc->readMiscReg(midx));
        }

        
                    Rd = rvSext(data);
                    data = rvZext(uimm);
                ;

        if (true) {
            if (bits(csr, 11, 10) == 0x3) {
                return std::make_shared<IllegalInstFault>(
                        csprintf("CSR %s is read-only\n", csrName), machInst);
            }
            DPRINTF(RiscvMisc, "Writing %#x to CSR %s.\n",
                    data, csrName);
            xc->setMiscReg(midx, data);
        }
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// CSROp::csrrsi(['\n                    Rd = rvSext(data);\n                    data = rvZext(data | uimm);\n                ', 'true', 'uimm != 0', 'IsSerializeAfter', 'IsNonSpeculative', 'No_OpClass'],{})

    Fault
    Csrrsi::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        // We assume a riscv instruction is always run with a riscv ISA.
        auto isa = static_cast<RiscvISA::ISA*>(xc->tcBase()->getIsaPtr());
        auto& csr_data = isa->getCSRDataMap();
        MISA misa = isa->readMiscRegNoEffect(MISCREG_ISA);

        auto csr_data_it = csr_data.find(csr);
        if (csr_data_it == csr_data.end()) {
            return std::make_shared<IllegalInstFault>(
                    csprintf("Illegal CSR index %#x\n", csr), machInst);
        }

        RegIndex midx = csr_data_it->second.physIndex;
        const std::string& csrName = csr_data_it->second.name;
        if ((csr_data_it->second.rvTypes & (1 << machInst.rv_type)) == 0) {
            return std::make_shared<IllegalInstFault>(
                    csprintf("%s is not support in mode %d\n",
                             csrName,
                             machInst.rv_type),
                    machInst);
        }

        MISA csr_exts = csr_data_it->second.isaExts;
        if ((csr_exts & misa) != csr_exts) {
            return std::make_shared<IllegalInstFault>(
                    csprintf("%s is not support in the isa spec %d\n",
                             csrName),
                    machInst);
        }

        uint64_t Rd = 0;
;
        ;

        RegVal data = 0;
        auto lowestAllowedMode = (PrivilegeMode)bits(csr, 9, 8);
        auto pm = (PrivilegeMode)xc->readMiscReg(MISCREG_PRV);
        if (pm < lowestAllowedMode) {
            return std::make_shared<IllegalInstFault>(
                    csprintf("%s is not accessible in %s\n", csrName, pm),
                    machInst);
        }
        switch (csr) {
          case CSR_SATP: {
            STATUS status = xc->readMiscReg(MISCREG_STATUS);
            if (pm == PRV_S && status.tvm == 1) {
                return std::make_shared<IllegalInstFault>(
                        "SATP access with TVM enabled\n",
                        machInst);
            }
            break;
          }
          default:
            break;
        }

        if (true) {
            data = rvZext(xc->readMiscReg(midx));
        }

        
                    Rd = rvSext(data);
                    data = rvZext(data | uimm);
                ;

        if (uimm != 0) {
            if (bits(csr, 11, 10) == 0x3) {
                return std::make_shared<IllegalInstFault>(
                        csprintf("CSR %s is read-only\n", csrName), machInst);
            }
            DPRINTF(RiscvMisc, "Writing %#x to CSR %s.\n",
                    data, csrName);
            xc->setMiscReg(midx, data);
        }
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// CSROp::csrrci(['\n                    Rd = rvSext(data);\n                    data = rvZext(data & ~uimm);\n                ', 'true', 'uimm != 0', 'IsSerializeAfter', 'IsNonSpeculative', 'No_OpClass'],{})

    Fault
    Csrrci::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        // We assume a riscv instruction is always run with a riscv ISA.
        auto isa = static_cast<RiscvISA::ISA*>(xc->tcBase()->getIsaPtr());
        auto& csr_data = isa->getCSRDataMap();
        MISA misa = isa->readMiscRegNoEffect(MISCREG_ISA);

        auto csr_data_it = csr_data.find(csr);
        if (csr_data_it == csr_data.end()) {
            return std::make_shared<IllegalInstFault>(
                    csprintf("Illegal CSR index %#x\n", csr), machInst);
        }

        RegIndex midx = csr_data_it->second.physIndex;
        const std::string& csrName = csr_data_it->second.name;
        if ((csr_data_it->second.rvTypes & (1 << machInst.rv_type)) == 0) {
            return std::make_shared<IllegalInstFault>(
                    csprintf("%s is not support in mode %d\n",
                             csrName,
                             machInst.rv_type),
                    machInst);
        }

        MISA csr_exts = csr_data_it->second.isaExts;
        if ((csr_exts & misa) != csr_exts) {
            return std::make_shared<IllegalInstFault>(
                    csprintf("%s is not support in the isa spec %d\n",
                             csrName),
                    machInst);
        }

        uint64_t Rd = 0;
;
        ;

        RegVal data = 0;
        auto lowestAllowedMode = (PrivilegeMode)bits(csr, 9, 8);
        auto pm = (PrivilegeMode)xc->readMiscReg(MISCREG_PRV);
        if (pm < lowestAllowedMode) {
            return std::make_shared<IllegalInstFault>(
                    csprintf("%s is not accessible in %s\n", csrName, pm),
                    machInst);
        }
        switch (csr) {
          case CSR_SATP: {
            STATUS status = xc->readMiscReg(MISCREG_STATUS);
            if (pm == PRV_S && status.tvm == 1) {
                return std::make_shared<IllegalInstFault>(
                        "SATP access with TVM enabled\n",
                        machInst);
            }
            break;
          }
          default:
            break;
        }

        if (true) {
            data = rvZext(xc->readMiscReg(midx));
        }

        
                    Rd = rvSext(data);
                    data = rvZext(data & ~uimm);
                ;

        if (uimm != 0) {
            if (bits(csr, 11, 10) == 0x3) {
                return std::make_shared<IllegalInstFault>(
                        csprintf("CSR %s is read-only\n", csrName), machInst);
            }
            DPRINTF(RiscvMisc, "Writing %#x to CSR %s.\n",
                    data, csrName);
            xc->setMiscReg(midx, data);
        }
        
        {
            RegVal final_val = Rd;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// Unknown::unknown(([], {}))

// M5Op::M5Op(([], {}))

    Fault
    M5Op::execute(ExecContext *xc,
        trace::InstRecord *traceData) const
    {
        uint64_t a0 = 0;
uint64_t a1 = 0;
;
        ;
        
            uint64_t result;
            if (machInst.rv_type == RV32) {
                pseudo_inst::pseudoInst<RegABI32>(xc->tcBase(), M5FUNC, result);
                a0 = bits(result, 31, 0);
                a1 = bits(result, 63, 32);
            } else {
                pseudo_inst::pseudoInst<RegABI64>(xc->tcBase(), M5FUNC, result);
                a0 = rvSext(result);
            };
        
        {
            RegVal final_val = a0;
            xc->setRegOperand(this, 0, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        }
        {
            RegVal final_val = a1;
            xc->setRegOperand(this, 1, final_val);
            if (traceData) {
                traceData->setData(intRegClass, final_val);
            }
        };
        return NoFault;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

#endif
